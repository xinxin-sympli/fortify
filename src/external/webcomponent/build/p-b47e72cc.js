!function(t,e,r){function n(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function i(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function s(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?i(Object(r),!0).forEach((function(e){n(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}let o={};"undefined"!=typeof self&&(o=self),t.nativeCrypto=o.msCrypto||o.crypto||{},t.nativeSubtle=null;try{t.nativeSubtle=(null==t.nativeCrypto?void 0:t.nativeCrypto.subtle)||(null==t.nativeCrypto?void 0:t.nativeCrypto.webkitSubtle)||null}catch($n){console.warn("Cannot get subtle from crypto",$n)}function c(t){return"undefined"!=typeof Buffer&&Buffer.isBuffer(t)?new Uint8Array(t):ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t)}class a{static ToString(t,e="utf8"){const r=c(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){const e=c(t);if("undefined"!=typeof btoa){const t=this.ToString(e,"binary");return btoa(t)}return Buffer.from(e).toString("base64")}static FromBase64(t){return t=t.replace(/\n/g,"").replace(/\r/g,"").replace(/\t/g,"").replace(/\s/g,""),"undefined"!=typeof atob?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(t){return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t){const e=unescape(encodeURIComponent(t)),r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r.buffer}static ToUtf8String(t){const e=c(t),r=String.fromCharCode.apply(null,e);return decodeURIComponent(escape(r))}static FromBinary(t){const e=t.length,r=new Uint8Array(e);for(let n=0;n<e;n++)r[n]=t.charCodeAt(n);return r.buffer}static ToBinary(t){const e=c(t);let r="";const n=e.length;for(let i=0;i<n;i++)r+=String.fromCharCode(e[i]);return r}static ToHex(t){const e=c(t),r=[],n=e.length;for(let i=0;i<n;i++){const t=e[i].toString(16);r.push(1===t.length?"0"+t:t)}return r.join("")}static FromHex(t){const e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2){const n=t.slice(r,r+2);e[r/2]=parseInt(n,16)}return e.buffer}static Base64Padding(t){const e=4-t.length%4;if(e<4)for(let r=0;r<e;r++)t+="=";return t}}class u{static toArrayBuffer(t){const e=this.toUint8Array(t);return e.byteOffset||e.length?e.buffer.slice(e.byteOffset,e.byteOffset+e.length):e.buffer}static toUint8Array(t){if("undefined"!=typeof Buffer&&Buffer.isBuffer(t))return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);if(t instanceof ArrayBuffer)return new Uint8Array(t);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return ArrayBuffer.isView(t)||t instanceof ArrayBuffer}}function h(t,e,r,n){var i,s=arguments.length,o=s<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,r,n);else for(var c=t.length-1;c>=0;c--)(i=t[c])&&(o=(s<3?i(o):s>3?i(e,r,o):i(e,r))||o);return s>3&&o&&Object.defineProperty(e,r,o),o}function f(t,e,r,n){return new(r||(r=Promise))((function(i,s){function o(t){try{a(n.next(t))}catch(e){s(e)}}function c(t){try{a(n.throw(t))}catch(e){s(e)}}function a(t){var e;t.done?i(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(o,c)}a((n=n.apply(t,e||[])).next())}))}function l(t,e){return t(e={exports:{}},e.exports),e.exports}function y(t,e){let r=0;if(1===t.length)return t[0];for(let n=t.length-1;n>=0;n--)r+=t[t.length-1-n]*Math.pow(2,e*n);return r}function d(t,e,r=-1){const n=r;let i=t,s=0,o=Math.pow(2,e);for(let c=1;c<8;c++){if(t<o){let t;if(n<0)t=new ArrayBuffer(c),s=c;else{if(n<c)return new ArrayBuffer(0);t=new ArrayBuffer(n),s=n}const r=new Uint8Array(t);for(let n=c-1;n>=0;n--){const t=Math.pow(2,n*e);r[s-n-1]=Math.floor(i/t),i-=r[s-n-1]*t}return t}o*=Math.pow(2,e)}return new ArrayBuffer(0)}const w="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",v=Math.log(2);var m,A=Object.freeze({__proto__:null,getUTCDate:function(t){return new Date(t.getTime()+6e4*t.getTimezoneOffset())},getParametersValue:function(t,e,r){return t instanceof Object==0?r:e in t?t[e]:r},bufferToHexCodes:function(t,e=0,r=t.byteLength-e,n=!1){let i="";for(const s of new Uint8Array(t,e,r)){const t=s.toString(16).toUpperCase();1===t.length&&(i+="0"),i+=t,n&&(i+=" ")}return i.trim()},checkBufferParams:function(t,e,r,n){return e instanceof ArrayBuffer==0?(t.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===e.byteLength?(t.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(t.error="Wrong parameter: inputOffset less than zero",!1):n<0?(t.error="Wrong parameter: inputLength less than zero",!1):!(e.byteLength-r-n<0&&(t.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1))},utilFromBase:y,utilToBase:d,utilConcatBuf:function(...t){let e=0,r=0;for(const s of t)e+=s.byteLength;const n=new ArrayBuffer(e),i=new Uint8Array(n);for(const s of t)i.set(new Uint8Array(s),r),r+=s.byteLength;return n},utilConcatView:function(...t){let e=0,r=0;for(const s of t)e+=s.length;const n=new ArrayBuffer(e),i=new Uint8Array(n);for(const s of t)i.set(s,r),r+=s.length;return i},utilDecodeTC:function(){const t=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const e=0===t[0]&&0==(128&t[1]);(255===t[0]&&128&t[1]||e)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(e);for(let o=0;o<this.valueHex.byteLength;o++)r[o]=0;r[0]=128&t[0];const n=y(r,8),i=new ArrayBuffer(this.valueHex.byteLength),s=new Uint8Array(i);for(let o=0;o<this.valueHex.byteLength;o++)s[o]=t[o];return s[0]&=127,y(s,8)-n},utilEncodeTC:function(t){const e=t<0?-1*t:t;let r=128;for(let n=1;n<8;n++){if(e<=r){if(t<0){const t=d(r-e,8,n);return new Uint8Array(t)[0]|=128,t}let i=d(e,8,n),s=new Uint8Array(i);if(128&s[0]){const t=i.slice(0),e=new Uint8Array(t);i=new ArrayBuffer(i.byteLength+1),s=new Uint8Array(i);for(let r=0;r<t.byteLength;r++)s[r+1]=e[r];s[0]=0}return i}r*=Math.pow(2,8)}return new ArrayBuffer(0)},isEqualBuffer:function(t,e){if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),n=new Uint8Array(e);for(let i=0;i<r.length;i++)if(r[i]!==n[i])return!1;return!0},padNumber:function(t,e){const r=t.toString(10);if(e<r.length)return"";const n=e-r.length,i=new Array(n);for(let s=0;s<n;s++)i[s]="0";return i.join("").concat(r)},toBase64:function(t,e=!1,r=!1,n=!1){let i=0,s=0,o=0,c="";const a=e?p:w;if(n){let e=0;for(let r=0;r<t.length;r++)if(0!==t.charCodeAt(r)){e=r;break}t=t.slice(e)}for(;i<t.length;){const e=t.charCodeAt(i++);i>=t.length&&(s=1);const n=t.charCodeAt(i++);i>=t.length&&(o=1);const u=t.charCodeAt(i++),h=e>>2,f=(3&e)<<4|n>>4;let l=(15&n)<<2|u>>6,y=63&u;1===s?l=y=64:1===o&&(y=64),c+=r?64===l?`${a.charAt(h)}${a.charAt(f)}`:64===y?`${a.charAt(h)}${a.charAt(f)}${a.charAt(l)}`:`${a.charAt(h)}${a.charAt(f)}${a.charAt(l)}${a.charAt(y)}`:`${a.charAt(h)}${a.charAt(f)}${a.charAt(l)}${a.charAt(y)}`}return c},fromBase64:function(t,e=!1,r=!1){const n=e?p:w;function i(t){for(let e=0;e<64;e++)if(n.charAt(e)===t)return e;return 64}function s(t){return 64===t?0:t}let o=0,c="";for(;o<t.length;){const e=i(t.charAt(o++)),r=o>=t.length?0:i(t.charAt(o++)),n=o>=t.length?0:i(t.charAt(o++)),a=o>=t.length?0:i(t.charAt(o++)),u=s(e)<<2|s(r)>>4,h=(15&s(r))<<4|s(n)>>2,f=(3&s(n))<<6|s(a);c+=String.fromCharCode(u),64!==n&&(c+=String.fromCharCode(h)),64!==a&&(c+=String.fromCharCode(f))}if(r){let t=-1;for(let e=c.length-1;e>=0;e--)if(0!==c.charCodeAt(e)){t=e;break}c=-1!==t?c.slice(0,t+1):""}return c},arrayBufferToString:function(t){let e="";const r=new Uint8Array(t);for(const n of r)e+=String.fromCharCode(n);return e},stringToArrayBuffer:function(t){const e=t.length,r=new ArrayBuffer(e),n=new Uint8Array(r);for(let i=0;i<e;i++)n[i]=t.charCodeAt(i);return r},nearestPowerOf2:function(t){const e=Math.log(t)/v,r=Math.floor(e),n=Math.round(e);return r===n?r:n},clearProps:function(t,e){for(const r of e)delete t[r]}}),g=l((function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.fromBER=at,e.compareSchema=ut,e.verifySchema=function(t,e){if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const r=at(t);return-1===r.offset?{verified:!1,result:r.result}:ut(r.result,r.result,e)},e.fromJSON=function(){},e.RawData=e.Repeated=e.Any=e.Choice=e.TIME=e.Duration=e.DateTime=e.TimeOfDay=e.DATE=e.GeneralizedTime=e.UTCTime=e.CharacterString=e.GeneralString=e.VisibleString=e.GraphicString=e.IA5String=e.VideotexString=e.TeletexString=e.PrintableString=e.NumericString=e.UniversalString=e.BmpString=e.RelativeObjectIdentifier=e.Utf8String=e.ObjectIdentifier=e.Enumerated=e.Integer=e.BitString=e.OctetString=e.Null=e.Set=e.Sequence=e.Boolean=e.EndOfContent=e.Constructed=e.Primitive=e.BaseBlock=e.ValueBlock=e.HexBlock=void 0;const r=[new Uint8Array([1])];class n{constructor(t={}){this.blockLength=(0,A.getParametersValue)(t,"blockLength",0),this.error=(0,A.getParametersValue)(t,"error",""),this.warnings=(0,A.getParametersValue)(t,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in t?t.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:(0,A.bufferToHexCodes)(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const i=t=>class extends t{constructor(t={}){super(t),this.isHexOnly=(0,A.getParametersValue)(t,"isHexOnly",!1),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(t,e,r){return!1===(0,A.checkBufferParams)(this,t,e,r)?-1:0===new Uint8Array(t,e,r).length?(this.warnings.push("Zero buffer length"),e):(this.valueHex=t.slice(e,e+r),this.blockLength=r,e+r)}toBER(t=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===t?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isHexOnly=this.isHexOnly,t.valueHex=(0,A.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}};e.HexBlock=i;class s extends(i(n)){constructor(t={}){super(),"idBlock"in t?(this.isHexOnly=(0,A.getParametersValue)(t.idBlock,"isHexOnly",!1),this.valueHex=(0,A.getParametersValue)(t.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=(0,A.getParametersValue)(t.idBlock,"tagClass",-1),this.tagNumber=(0,A.getParametersValue)(t.idBlock,"tagNumber",-1),this.isConstructed=(0,A.getParametersValue)(t.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(t=!1){let e,r,n=0;switch(this.tagClass){case 1:n|=0;break;case 2:n|=64;break;case 3:n|=128;break;case 4:n|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(n|=32),this.tagNumber<31&&!this.isHexOnly){if(e=new ArrayBuffer(1),r=new Uint8Array(e),!t){let t=this.tagNumber;t&=31,n|=t,r[0]=n}return e}if(!1===this.isHexOnly){const i=(0,A.utilToBase)(this.tagNumber,7),s=new Uint8Array(i),o=i.byteLength;if(e=new ArrayBuffer(o+1),r=new Uint8Array(e),r[0]=31|n,!t){for(let t=0;t<o-1;t++)r[t+1]=128|s[t];r[o]=s[o-1]}return e}if(e=new ArrayBuffer(this.valueHex.byteLength+1),r=new Uint8Array(e),r[0]=31|n,!1===t){const t=new Uint8Array(this.valueHex);for(let e=0;e<t.length-1;e++)r[e+1]=128|t[e];r[this.valueHex.byteLength]=t[t.length-1]}return e}fromBER(t,e,r){if(!1===(0,A.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);if(0===n.length)return this.error="Zero buffer length",-1;switch(192&n[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&n[0]),this.isHexOnly=!1;const i=31&n[0];if(31!==i)this.tagNumber=i,this.blockLength=1;else{let t=1;this.valueHex=new ArrayBuffer(255);let e=255,r=new Uint8Array(this.valueHex);for(;128&n[t];){if(r[t-1]=127&n[t],t++,t>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(t===e){e+=255;const t=new ArrayBuffer(e),n=new Uint8Array(t);for(let e=0;e<r.length;e++)n[e]=r[e];this.valueHex=new ArrayBuffer(e),r=new Uint8Array(this.valueHex)}}this.blockLength=t+1,r[t-1]=127&n[t];const i=new ArrayBuffer(t),s=new Uint8Array(i);for(let n=0;n<t;n++)s[n]=r[n];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex),r.set(s),this.blockLength<=9?this.tagNumber=(0,A.utilFromBase)(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.tagClass=this.tagClass,t.tagNumber=this.tagNumber,t.isConstructed=this.isConstructed,t}}class o extends n{constructor(t={}){super(),"lenBlock"in t?(this.isIndefiniteForm=(0,A.getParametersValue)(t.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=(0,A.getParametersValue)(t.lenBlock,"longFormUsed",!1),this.length=(0,A.getParametersValue)(t.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(t,e,r){if(!1===(0,A.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);if(0===n.length)return this.error="Zero buffer length",-1;if(255===n[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===n[0],!0===this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(128&n[0]),!1===this.longFormUsed)return this.length=n[0],this.blockLength=1,e+this.blockLength;const i=127&n[0];if(i>8)return this.error="Too big integer",-1;if(i+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const s=new Uint8Array(i);for(let o=0;o<i;o++)s[o]=n[o+1];return 0===s[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=(0,A.utilFromBase)(s,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=i+1,e+this.blockLength}toBER(t=!1){let e,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=128),e;if(!0===this.longFormUsed){const n=(0,A.utilToBase)(this.length,8);if(n.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(e=new ArrayBuffer(n.byteLength+1),!0===t)return e;const i=new Uint8Array(n);r=new Uint8Array(e),r[0]=128|n.byteLength;for(let t=0;t<n.byteLength;t++)r[t+1]=i[t];return e}return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=this.length),e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isIndefiniteForm=this.isIndefiniteForm,t.longFormUsed=this.longFormUsed,t.length=this.length,t}}class c extends n{constructor(t={}){super(t)}static blockName(){return"valueBlock"}fromBER(t,e,r){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(t=!1){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}e.ValueBlock=c;class a extends n{constructor(t={},e=c){super(t),"name"in t&&(this.name=t.name),"optional"in t&&(this.optional=t.optional),"primitiveSchema"in t&&(this.primitiveSchema=t.primitiveSchema),this.idBlock=new s(t),this.lenBlock=new o(t),this.valueBlock=new e(t)}static blockName(){return"BaseBlock"}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}toBER(t=!1){let e;const r=this.idBlock.toBER(t),n=this.valueBlock.toBER(!0);this.lenBlock.length=n.byteLength;const i=this.lenBlock.toBER(t);let s;if(e=(0,A.utilConcatBuf)(r,i),s=!1===t?this.valueBlock.toBER(t):new ArrayBuffer(this.lenBlock.length),e=(0,A.utilConcatBuf)(e,s),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===t){const t=new Uint8Array(r);t[0]=0,t[1]=0}e=(0,A.utilConcatBuf)(e,r)}return e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.idBlock=this.idBlock.toJSON(),t.lenBlock=this.lenBlock.toJSON(),t.valueBlock=this.valueBlock.toJSON(),"name"in this&&(t.name=this.name),"optional"in this&&(t.optional=this.optional),"primitiveSchema"in this&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}}e.BaseBlock=a;class u extends c{constructor(t={}){super(t),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=(0,A.getParametersValue)(t,"isHexOnly",!0)}fromBER(t,e,r){if(!1===(0,A.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);if(0===n.length)return this.warnings.push("Zero buffer length"),e;this.valueHex=new ArrayBuffer(n.length);const i=new Uint8Array(this.valueHex);for(let s=0;s<n.length;s++)i[s]=n[s];return this.blockLength=r,e+r}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueHex=(0,A.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t.isHexOnly=this.isHexOnly,t}}class h extends a{constructor(t={}){super(t,u),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}e.Primitive=h;class f extends c{constructor(t={}){super(t),this.value=(0,A.getParametersValue)(t,"value",[]),this.isIndefiniteForm=(0,A.getParametersValue)(t,"isIndefiniteForm",!1)}fromBER(t,e,r){const n=e,i=r;if(!1===(0,A.checkBufferParams)(this,t,e,r))return-1;if(0===new Uint8Array(t,e,r).length)return this.warnings.push("Zero buffer length"),e;let s=e;for(;(!0===this.isIndefiniteForm?1:r)>0;){const e=ct(t,s,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(s=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),!0===this.isIndefiniteForm&&e.result.constructor.blockName()===d.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===d.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=t.slice(n,n+i),s}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(t);e=(0,A.utilConcatBuf)(e,n)}return e}static blockName(){return"ConstructedValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.isIndefiniteForm=this.isIndefiniteForm,t.value=[];for(let r=0;r<this.value.length;r++)t.value.push(this.value[r].toJSON());return t}}class l extends a{constructor(t={}){super(t,f),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(t,e,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}}e.Constructed=l;class y extends c{constructor(t={}){super(t)}fromBER(t,e,r){return e}toBER(t=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class d extends a{constructor(t={}){super(t,y),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}e.EndOfContent=d;class w extends c{constructor(t={}){super(t),this.value=(0,A.getParametersValue)(t,"value",!1),this.isHexOnly=(0,A.getParametersValue)(t,"isHexOnly",!1),"valueHex"in t?this.valueHex=t.valueHex.slice(0):(this.valueHex=new ArrayBuffer(1),!0===this.value&&(new Uint8Array(this.valueHex)[0]=255))}fromBER(t,e,r){if(!1===(0,A.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(n.length);const i=new Uint8Array(this.valueHex);for(let s=0;s<n.length;s++)i[s]=n[s];return this.value=0!==A.utilDecodeTC.call(this),this.blockLength=r,e+r}toBER(t=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t.isHexOnly=this.isHexOnly,t.valueHex=(0,A.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class p extends a{constructor(t={}){super(t,w),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}e.Boolean=p;class v extends l{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}e.Sequence=v;class m extends l{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}e.Set=m;class g extends a{constructor(t={}){super(t,n),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(t,e,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,e+r>t.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):e+r}toBER(t=!1){const e=new ArrayBuffer(2);if(!0===t)return e;const r=new Uint8Array(e);return r[0]=5,r[1]=0,e}}e.Null=g;class b extends(i(f)){constructor(t={}){super(t),this.isConstructed=(0,A.getParametersValue)(t,"isConstructed",!1)}fromBER(t,e,r){let n=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,n=f.prototype.fromBER.call(this,t,e,r),-1===n)return n;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===d.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(e!==k.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,n=super.fromBER(t,e,r),this.blockLength=r;return n}toBER(t=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,t);let e=new ArrayBuffer(this.valueHex.byteLength);return!0===t||0===this.valueHex.byteLength||(e=this.valueHex.slice(0)),e}static blockName(){return"OctetStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=(0,A.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class k extends a{constructor(t={}){super(t,b),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(t,e,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),e):super.fromBER(t,e,r)}static blockName(){return"OctetString"}isEqual(t){return t instanceof k!=0&&JSON.stringify(this)===JSON.stringify(t)}}e.OctetString=k;class S extends(i(f)){constructor(t={}){super(t),this.unusedBits=(0,A.getParametersValue)(t,"unusedBits",0),this.isConstructed=(0,A.getParametersValue)(t,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(t,e,r){if(0===r)return e;let n=-1;if(!0===this.isConstructed){if(n=f.prototype.fromBER.call(this,t,e,r),-1===n)return n;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===d.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(e!==B.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[t].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[t].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return n}if(!1===(0,A.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(this.unusedBits=i[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(i.length-1);const s=new Uint8Array(this.valueHex);for(let o=0;o<r-1;o++)s[o]=i[o+1];return this.blockLength=i.length,e+r}toBER(t=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,t);if(!0===t)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const e=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),n=new Uint8Array(r);n[0]=this.unusedBits;for(let i=0;i<this.valueHex.byteLength;i++)n[i+1]=e[i];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.unusedBits=this.unusedBits,t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=(0,A.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class B extends a{constructor(t={}){super(t,S),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(t,e,r){return 0===r?e:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(t,e,r))}isEqual(t){return t instanceof B!=0&&JSON.stringify(this)===JSON.stringify(t)}}e.BitString=B;class E extends(i(c)){constructor(t={}){super(t),"value"in t&&(this.valueDec=t.value)}set valueHex(t){this._valueHex=t.slice(0),t.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,t.byteLength>0&&(this._valueDec=A.utilDecodeTC.call(this)))}get valueHex(){return this._valueHex}set valueDec(t){this._valueDec=t,this.isHexOnly=!1,this._valueHex=(0,A.utilEncodeTC)(t)}get valueDec(){return this._valueDec}fromDER(t,e,r,n=0){const i=this.fromBER(t,e,r);if(-1===i)return i;const s=new Uint8Array(this._valueHex);if(0===s[0]&&0!=(128&s[1])){const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}else if(0!==n&&this._valueHex.byteLength<n){n-this._valueHex.byteLength>1&&(n=this._valueHex.byteLength+1);const t=new ArrayBuffer(n);new Uint8Array(t).set(s,n-this._valueHex.byteLength),this._valueHex=t.slice(0)}return i}toDER(t=!1){const e=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&e[0]):{const t=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(t);r[0]=0,r.set(e,1),this._valueHex=t.slice(0)}break;case 0===e[0]&&0==(128&e[1]):{const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}}return this.toBER(t)}fromBER(t,e,r){const n=super.fromBER(t,e,r);return-1===n?n:(this.blockLength=r,e+r)}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}toString(){function t(t,e){const r=new Uint8Array([0]);let n=new Uint8Array(t),i=new Uint8Array(e),s=n.slice(0);const o=s.length-1;let c=i.slice(0);const a=c.length-1;let u=0,h=0;for(let f=a<o?o:a;f>=0;f--,h++){switch(!0){case h<c.length:u=s[o-h]+c[a-h]+r[0];break;default:u=s[o-h]+r[0]}switch(r[0]=u/10,!0){case h>=s.length:s=(0,A.utilConcatView)(new Uint8Array([u%10]),s);break;default:s[o-h]=u%10}}return r[0]>0&&(s=(0,A.utilConcatView)(r,s)),s.slice(0)}function e(t){if(t>=r.length)for(let e=r.length;e<=t;e++){const t=new Uint8Array([0]);let n=r[e-1].slice(0);for(let e=n.length-1;e>=0;e--){const r=new Uint8Array([(n[e]<<1)+t[0]]);t[0]=r[0]/10,n[e]=r[0]%10}t[0]>0&&(n=(0,A.utilConcatView)(t,n)),r.push(n)}return r[t]}function n(t,e){let r=0,n=new Uint8Array(t),i=new Uint8Array(e),s=n.slice(0);const o=s.length-1;let c=i.slice(0);const a=c.length-1;let u,h=0;for(let f=a;f>=0;f--,h++)switch(u=s[o-h]-c[a-h]-r,!0){case u<0:r=1,s[o-h]=u+10;break;default:r=0,s[o-h]=u}if(r>0)for(let f=o-a+1;f>=0;f--,h++){if(u=s[o-h]-r,!(u<0)){r=0,s[o-h]=u;break}r=1,s[o-h]=u+10}return s.slice()}const i=8*this._valueHex.byteLength-1;let s,o=new Uint8Array(8*this._valueHex.byteLength/3),c=0;const a=new Uint8Array(this._valueHex);let u="",h=!1;for(let r=this._valueHex.byteLength-1;r>=0;r--){s=a[r];for(let r=0;r<8;r++){if(1==(1&s))switch(c){case i:o=n(e(c),o),u="-";break;default:o=t(o,e(c))}c++,s>>=1}}for(let r=0;r<o.length;r++)o[r]&&(h=!0),h&&(u+="0123456789".charAt(o[r]));return!1===h&&(u+="0123456789".charAt(0)),u}}class x extends a{constructor(t={}){super(t,E),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(t){return t instanceof x?this.valueBlock.isHexOnly&&t.valueBlock.isHexOnly?(0,A.isEqualBuffer)(this.valueBlock.valueHex,t.valueBlock.valueHex):this.valueBlock.isHexOnly===t.valueBlock.isHexOnly&&this.valueBlock.valueDec===t.valueBlock.valueDec:t instanceof ArrayBuffer&&(0,A.isEqualBuffer)(this.valueBlock.valueHex,t)}convertToDER(){const t=new x({valueHex:this.valueBlock.valueHex});return t.valueBlock.toDER(),t}convertFromDER(){const t=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,e=new x({valueHex:this.valueBlock.valueHex});return e.valueBlock.fromDER(e.valueBlock.valueHex,0,e.valueBlock.valueHex.byteLength,t),e}}e.Integer=x;class N extends x{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}e.Enumerated=N;class K extends(i(n)){constructor(t={}){super(t),this.valueDec=(0,A.getParametersValue)(t,"valueDec",-1),this.isFirstSid=(0,A.getParametersValue)(t,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===(0,A.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let i=new Uint8Array(this.valueHex);for(let c=0;c<r&&(i[c]=127&n[c],this.blockLength++,0!=(128&n[c]));c++);const s=new ArrayBuffer(this.blockLength),o=new Uint8Array(s);for(let c=0;c<this.blockLength;c++)o[c]=i[c];return this.valueHex=s.slice(0),i=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===i[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,A.utilFromBase)(i,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const n=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|n[t];return r[this.blockLength-1]=n[this.blockLength-1],e}const n=(0,A.utilToBase)(this.valueDec,7);if(0===n.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(n.byteLength),!1===t){const t=new Uint8Array(n);r=new Uint8Array(e);for(let e=0;e<n.byteLength-1;e++)r[e]=128|t[e];r[n.byteLength-1]=t[n.byteLength-1]}return e}toString(){let t="";if(!0===this.isHexOnly)t=(0,A.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let e=this.valueDec;this.valueDec<=39?t="0.":this.valueDec<=79?(t="1.",e-=40):(t="2.",e-=80),t+=e.toString()}else t=this.valueDec.toString();return t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t.isFirstSid=this.isFirstSid,t}}class U extends c{constructor(t={}){super(t),this.fromString((0,A.getParametersValue)(t,"value",""))}fromBER(t,e,r){let n=e;for(;r>0;){const e=new K;if(n=e.fromBER(t,n,r),-1===n)return this.blockLength=0,this.error=e.error,n;0===this.value.length&&(e.isFirstSid=!0),this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return n}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(t);if(0===n.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=(0,A.utilConcatBuf)(e,n)}return e}fromString(t){this.value=[];let e=0,r=0,n="",i=!1;do{if(r=t.indexOf(".",e),n=-1===r?t.substr(e):t.substr(e,r-e),e=r+1,i){const t=this.value[0];let e=0;switch(t.valueDec){case 0:break;case 1:e=40;break;case 2:e=80;break;default:return this.value=[],!1}const r=parseInt(n,10);if(isNaN(r))return!0;t.valueDec=r+e,i=!1}else{const t=new K;if(t.valueDec=parseInt(n,10),isNaN(t.valueDec))return!0;0===this.value.length&&(t.isFirstSid=!0,i=!0),this.value.push(t)}}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(t+="."),e?(n=`{${n}}`,this.value[r].isFirstSid?t=`2.{${n} - 80}`:t+=n):t+=n}return t}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class C extends a{constructor(t={}){super(t,U),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}e.ObjectIdentifier=C;class O extends(i(n)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class I extends a{constructor(t={}){super(t,O),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(t){const e=unescape(encodeURIComponent(t)),r=e.length;this.valueBlock.valueHex=new ArrayBuffer(r);const n=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<r;i++)n[i]=e.charCodeAt(i);this.valueBlock.value=t}}e.Utf8String=I;class T extends(i(n)){constructor(t={}){super(t),this.valueDec=(0,A.getParametersValue)(t,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===(0,A.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let i=new Uint8Array(this.valueHex);for(let c=0;c<r&&(i[c]=127&n[c],this.blockLength++,0!=(128&n[c]));c++);const s=new ArrayBuffer(this.blockLength),o=new Uint8Array(s);for(let c=0;c<this.blockLength;c++)o[c]=i[c];return this.valueHex=s.slice(0),i=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===i[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,A.utilFromBase)(i,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const n=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|n[t];return r[this.blockLength-1]=n[this.blockLength-1],e}const n=(0,A.utilToBase)(this.valueDec,7);if(0===n.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(n.byteLength),!1===t){const t=new Uint8Array(n);r=new Uint8Array(e);for(let e=0;e<n.byteLength-1;e++)r[e]=128|t[e];r[n.byteLength-1]=t[n.byteLength-1]}return e}toString(){let t="";return t=!0===this.isHexOnly?(0,A.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength):this.valueDec.toString(),t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}}class j extends c{constructor(t={}){super(t),this.fromString((0,A.getParametersValue)(t,"value",""))}fromBER(t,e,r){let n=e;for(;r>0;){const e=new T;if(n=e.fromBER(t,n,r),-1===n)return this.blockLength=0,this.error=e.error,n;this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return n}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(t);if(0===n.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=(0,A.utilConcatBuf)(e,n)}return e}fromString(t){this.value=[];let e=0,r=0,n="";do{r=t.indexOf(".",e),n=-1===r?t.substr(e):t.substr(e,r-e),e=r+1;const i=new T;if(i.valueDec=parseInt(n,10),isNaN(i.valueDec))return!0;this.value.push(i)}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(t+="."),e?(n=`{${n}}`,t+=n):t+=n}return t}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class D extends a{constructor(t={}){super(t,j),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}e.RelativeObjectIdentifier=D;class R extends(i(n)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class P extends a{constructor(t={}){super(t,R),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let n=0;n<r.length;n+=2){const t=r[n];r[n]=r[n+1],r[n+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(2*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<e;n++){const e=(0,A.utilToBase)(t.charCodeAt(n),8),i=new Uint8Array(e);if(i.length>2)continue;const s=2-i.length;for(let t=i.length-1;t>=0;t--)r[2*n+t+s]=i[t]}this.valueBlock.value=t}}e.BmpString=P;class M extends(i(n)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class $ extends a{constructor(t={}){super(t,M),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let n=0;n<r.length;n+=4)r[n]=r[n+3],r[n+1]=r[n+2],r[n+2]=0,r[n+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(4*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<e;n++){const e=(0,A.utilToBase)(t.charCodeAt(n),8),i=new Uint8Array(e);if(i.length>4)continue;const s=4-i.length;for(let t=i.length-1;t>=0;t--)r[4*n+t+s]=i[t]}this.valueBlock.value=t}}e.UniversalString=$;class H extends(i(n)){constructor(t={}){super(t),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class J extends a{constructor(t={}){super(t,H),"value"in t&&this.fromString(t.value)}static blockName(){return"SIMPLESTRING"}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(e);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<e;n++)r[n]=t.charCodeAt(n);this.valueBlock.value=t}}class V extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}e.NumericString=V;class G extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}e.PrintableString=G;class W extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}e.TeletexString=W;class _ extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}e.VideotexString=_;class q extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}e.IA5String=q;class z extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}e.GraphicString=z;class F extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}e.VisibleString=F;class L extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}e.GeneralString=L;class Z extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}e.CharacterString=Z;class Q extends F{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(t){const e=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(t);if(null===e)return void(this.error="Wrong input string for convertion");const r=parseInt(e[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(e[2],10),this.day=parseInt(e[3],10),this.hour=parseInt(e[4],10),this.minute=parseInt(e[5],10),this.second=parseInt(e[6],10)}toString(){const t=new Array(7);return t[0]=(0,A.padNumber)(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=(0,A.padNumber)(this.month,2),t[2]=(0,A.padNumber)(this.day,2),t[3]=(0,A.padNumber)(this.hour,2),t[4]=(0,A.padNumber)(this.minute,2),t[5]=(0,A.padNumber)(this.second,2),t[6]="Z",t.join("")}static blockName(){return"UTCTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t}}e.UTCTime=Q;class X extends F{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(t){let e,r=!1,n="",i="",s=0,o=0,c=0;if("Z"===t[t.length-1])n=t.substr(0,t.length-1),r=!0;else{const e=new Number(t[t.length-1]);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");n=t}if(r){if(-1!==n.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==n.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let t=1,e=n.indexOf("+"),r="";if(-1===e&&(e=n.indexOf("-"),t=-1),-1!==e){if(r=n.substr(e+1),n=n.substr(0,e),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let i=new Number(r.substr(0,2));if(isNaN(i.valueOf()))throw new Error("Wrong input string for convertion");if(o=t*i,4===r.length){if(i=new Number(r.substr(2,2)),isNaN(i.valueOf()))throw new Error("Wrong input string for convertion");c=t*i}}}let a=n.indexOf(".");if(-1===a&&(a=n.indexOf(",")),-1!==a){const t=new Number("0"+n.substr(a));if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=t.valueOf(),i=n.substr(0,a)}else i=n;switch(!0){case 8===i.length:if(e=/(\d{4})(\d{2})(\d{2})/gi,-1!==a)throw new Error("Wrong input string for convertion");break;case 10===i.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==a){let t=60*s;this.minute=Math.floor(t),t=60*(t-this.minute),this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 12===i.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==a){let t=60*s;this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 14===i.length:e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==a&&(this.millisecond=Math.floor(1e3*s));break;default:throw new Error("Wrong input string for convertion")}const u=e.exec(i);if(null===u)throw new Error("Wrong input string for convertion");for(let h=1;h<u.length;h++)switch(h){case 1:this.year=parseInt(u[h],10);break;case 2:this.month=parseInt(u[h],10);break;case 3:this.day=parseInt(u[h],10);break;case 4:this.hour=parseInt(u[h],10)+o;break;case 5:this.minute=parseInt(u[h],10)+c;break;case 6:this.second=parseInt(u[h],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const t=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=t.getUTCFullYear(),this.month=t.getUTCMonth(),this.day=t.getUTCDay(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}}toString(){const t=[];return t.push((0,A.padNumber)(this.year,4)),t.push((0,A.padNumber)(this.month,2)),t.push((0,A.padNumber)(this.day,2)),t.push((0,A.padNumber)(this.hour,2)),t.push((0,A.padNumber)(this.minute,2)),t.push((0,A.padNumber)(this.second,2)),0!==this.millisecond&&(t.push("."),t.push((0,A.padNumber)(this.millisecond,3))),t.push("Z"),t.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t.millisecond=this.millisecond,t}}e.GeneralizedTime=X;class Y extends I{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}e.DATE=Y;class tt extends I{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}e.TimeOfDay=tt;class et extends I{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}e.DateTime=et;class rt extends I{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}e.Duration=rt;class nt extends I{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}e.TIME=nt;class it{constructor(t={}){this.value=(0,A.getParametersValue)(t,"value",[]),this.optional=(0,A.getParametersValue)(t,"optional",!1)}}e.Choice=it;class st{constructor(t={}){this.name=(0,A.getParametersValue)(t,"name",""),this.optional=(0,A.getParametersValue)(t,"optional",!1)}}e.Any=st;class ot{constructor(t={}){this.name=(0,A.getParametersValue)(t,"name",""),this.optional=(0,A.getParametersValue)(t,"optional",!1),this.value=(0,A.getParametersValue)(t,"value",new st),this.local=(0,A.getParametersValue)(t,"local",!1)}}function ct(t,e,r){const i=e;let s=new a({},Object);const o=new n;if(!1===(0,A.checkBufferParams)(o,t,e,r))return s.error=o.error,{offset:-1,result:s};if(0===new Uint8Array(t,e,r).length)return this.error="Zero buffer length",{offset:-1,result:s};let c=s.idBlock.fromBER(t,e,r);if(s.warnings.concat(s.idBlock.warnings),-1===c)return s.error=s.idBlock.error,{offset:-1,result:s};if(c=s.lenBlock.fromBER(t,e=c,r-=s.idBlock.blockLength),s.warnings.concat(s.lenBlock.warnings),-1===c)return s.error=s.lenBlock.error,{offset:-1,result:s};if(e=c,r-=s.lenBlock.blockLength,!1===s.idBlock.isConstructed&&!0===s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let u=a;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&!1===s.idBlock.isHexOnly)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(!0===s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};u=d;break;case 1:u=p;break;case 2:u=x;break;case 3:u=B;break;case 4:u=k;break;case 5:u=g;break;case 6:u=C;break;case 10:u=N;break;case 12:u=I;break;case 13:u=D;break;case 14:u=nt;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:u=v;break;case 17:u=m;break;case 18:u=V;break;case 19:u=G;break;case 20:u=W;break;case 21:u=_;break;case 22:u=q;break;case 23:u=Q;break;case 24:u=X;break;case 25:u=z;break;case 26:u=F;break;case 27:u=L;break;case 28:u=$;break;case 29:u=Z;break;case 30:u=P;break;case 31:u=Y;break;case 32:u=tt;break;case 33:u=et;break;case 34:u=rt;break;default:{let n;n=!0===s.idBlock.isConstructed?new l:new h,n.idBlock=s.idBlock,n.lenBlock=s.lenBlock,n.warnings=s.warnings,s=n,c=s.fromBER(t,e,r)}}break;case 2:case 3:case 4:default:u=!0===s.idBlock.isConstructed?l:h}return s=function(t,e){if(t instanceof e)return t;const r=new e;return r.idBlock=t.idBlock,r.lenBlock=t.lenBlock,r.warnings=t.warnings,r.valueBeforeDecode=t.valueBeforeDecode.slice(0),r}(s,u),c=s.fromBER(t,e,!0===s.lenBlock.isIndefiniteForm?r:s.lenBlock.length),s.valueBeforeDecode=t.slice(i,i+s.blockLength),{offset:c,result:s}}function at(t){if(0===t.byteLength){const t=new a({},Object);return t.error="Input buffer has zero length",{offset:-1,result:t}}return ct(t,0,t.byteLength)}function ut(t,e,r){if(r instanceof it){for(let n=0;n<r.value.length;n++)if(!0===ut(t,e,r.value[n]).verified)return{verified:!0,result:t};{const t={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(t.name=r.name),t}}if(r instanceof st)return r.hasOwnProperty("name")&&(t[r.name]=e),{verified:!0,result:t};if(t instanceof Object==0)return{verified:!1,result:{error:"Wrong root object"}};if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=r.idBlock.toBER(!1);if(0===n.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(n,0,n.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:t};if("isHexOnly"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:t};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=new Uint8Array(r.idBlock.valueHex),i=new Uint8Array(e.idBlock.valueHex);if(n.length!==i.length)return{verified:!1,result:t};for(let e=0;e<n.length;e++)if(n[e]!==i[1])return{verified:!1,result:t}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(t[r.name]=e)),!0===r.idBlock.isConstructed){let n=0,i={verified:!1},s=r.valueBlock.value.length;if(s>0&&r.valueBlock.value[0]instanceof ot&&(s=e.valueBlock.value.length),0===s)return{verified:!0,result:t};if(0===e.valueBlock.value.length&&0!==r.valueBlock.value.length){let e=!0;for(let t=0;t<r.valueBlock.value.length;t++)e=e&&(r.valueBlock.value[t].optional||!1);return!0===e?{verified:!0,result:t}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),t.error="Inconsistent object length",{verified:!1,result:t})}for(let o=0;o<s;o++)if(o-n>=e.valueBlock.value.length){if(!1===r.valueBlock.value[o].optional){const e={verified:!1,result:t};return t.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}}else if(r.valueBlock.value[0]instanceof ot){if(i=ut(t,e.valueBlock.value[o],r.valueBlock.value[0].value),!1===i.verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),i;n++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let n={};n="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?e:t,void 0===n[r.valueBlock.value[0].name]&&(n[r.valueBlock.value[0].name]=[]),n[r.valueBlock.value[0].name].push(e.valueBlock.value[o])}}else if(i=ut(t,e.valueBlock.value[o-n],r.valueBlock.value[o]),!1===i.verified){if(!0!==r.valueBlock.value[o].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),i;n++}if(!1===i.verified){const e={verified:!1,result:t};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return{verified:!0,result:t}}if("primitiveSchema"in r&&"valueHex"in e.valueBlock){const n=at(e.valueBlock.valueHex);if(-1===n.offset){const e={verified:!1,result:n.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return ut(t,n.result,r.primitiveSchema)}return{verified:!0,result:t}}e.Repeated=ot,e.RawData=class{constructor(t={}){this.data=(0,A.getParametersValue)(t,"data",new ArrayBuffer(0))}fromBER(t,e,r){return this.data=t.slice(e,r),e+r}toBER(t=!1){return this.data}}})),b=(m=g)&&m.__esModule&&Object.prototype.hasOwnProperty.call(m,"default")?m.default:m,k=g.fromBER,S=g.compareSchema,B=g.Repeated,E=g.Any,x=g.Choice,N=g.GeneralizedTime,K=g.UTCTime,U=g.CharacterString,C=g.GeneralString,O=g.VisibleString,I=g.GraphicString,T=g.IA5String,j=g.VideotexString,D=g.TeletexString,R=g.PrintableString,P=g.NumericString,M=g.UniversalString,$=g.BmpString,H=g.Utf8String,J=g.ObjectIdentifier,V=g.Enumerated,G=g.Integer,W=g.BitString,_=g.OctetString,q=g.Null,z=g.Set,F=g.Sequence,L=g.Boolean,Z=g.Constructed,Q=g.Primitive,X=g.BaseBlock,Y=Object.freeze({__proto__:null,default:b,__moduleExports:g,fromBER:k,compareSchema:S,verifySchema:g.verifySchema,fromJSON:g.fromJSON,RawData:g.RawData,Repeated:B,Any:E,Choice:x,TIME:g.TIME,Duration:g.Duration,DateTime:g.DateTime,TimeOfDay:g.TimeOfDay,DATE:g.DATE,GeneralizedTime:N,UTCTime:K,CharacterString:U,GeneralString:C,VisibleString:O,GraphicString:I,IA5String:T,VideotexString:j,TeletexString:D,PrintableString:R,NumericString:P,UniversalString:M,BmpString:$,RelativeObjectIdentifier:g.RelativeObjectIdentifier,Utf8String:H,ObjectIdentifier:J,Enumerated:V,Integer:G,BitString:W,OctetString:_,Null:q,Set:z,Sequence:F,Boolean:L,EndOfContent:g.EndOfContent,Constructed:Z,Primitive:Q,BaseBlock:X,ValueBlock:g.ValueBlock,HexBlock:g.HexBlock});const tt={fromASN:t=>t instanceof q?null:t.valueBeforeDecode,toASN:t=>{if(null===t)return new q;const e=k(t);if(e.result.error)throw new Error(e.result.error);return e.result}},et={fromASN:t=>!t.valueBlock.valueDec&&t.valueBlock.valueHex.byteLength>0?t.valueBlock.toString():t.valueBlock.valueDec,toASN:t=>new G({value:t})},rt={fromASN:t=>t.valueBlock.valueDec,toASN:t=>new V({value:t})},nt={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new G({valueHex:t})},it={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new W({valueHex:t})},st={fromASN:t=>t.valueBlock.toString(),toASN:t=>new J({value:t})},ot={fromASN:t=>t.valueBlock.value,toASN:t=>new L({value:t})},ct={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new _({valueHex:t})};function at(t){return{fromASN:t=>t.valueBlock.value,toASN:e=>new t({value:e})}}const ut=at(H),ht=at($),ft=at(M),lt=at(P),yt=at(R),dt=at(D),wt=at(j),pt=at(T),vt=at(I),mt=at(O),At=at(C),gt=at(U);var bt,kt,St=Object.freeze({__proto__:null,AsnAnyConverter:tt,AsnIntegerConverter:et,AsnEnumeratedConverter:rt,AsnIntegerArrayBufferConverter:nt,AsnBitStringConverter:it,AsnObjectIdentifierConverter:st,AsnBooleanConverter:ot,AsnOctetStringConverter:ct,AsnUtf8StringConverter:ut,AsnBmpStringConverter:ht,AsnUniversalStringConverter:ft,AsnNumericStringConverter:lt,AsnPrintableStringConverter:yt,AsnTeletexStringConverter:dt,AsnVideotexStringConverter:wt,AsnIA5StringConverter:pt,AsnGraphicStringConverter:vt,AsnVisibleStringConverter:mt,AsnGeneralStringConverter:At,AsnCharacterStringConverter:gt,AsnUTCTimeConverter:{fromASN:t=>t.toDate(),toASN:t=>new K({valueDate:t})},AsnGeneralizedTimeConverter:{fromASN:t=>t.toDate(),toASN:t=>new N({valueDate:t})},AsnNullConverter:{fromASN:()=>null,toASN:()=>new q}});function Bt(t){return t&&t.prototype?!(!t.prototype.toASN||!t.prototype.fromASN)||Bt(t.prototype):!!(t&&t.toASN&&t.fromASN)}function Et(t,e){if(!t||!e)return!1;if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),n=new Uint8Array(e);for(let i=0;i<t.byteLength;i++)if(r[i]!==n[i])return!1;return!0}!function(t){t[t.Sequence=0]="Sequence",t[t.Set=1]="Set",t[t.Choice=2]="Choice"}(bt||(bt={})),function(t){t[t.Any=1]="Any",t[t.Boolean=2]="Boolean",t[t.OctetString=3]="OctetString",t[t.BitString=4]="BitString",t[t.Integer=5]="Integer",t[t.Enumerated=6]="Enumerated",t[t.ObjectIdentifier=7]="ObjectIdentifier",t[t.Utf8String=8]="Utf8String",t[t.BmpString=9]="BmpString",t[t.UniversalString=10]="UniversalString",t[t.NumericString=11]="NumericString",t[t.PrintableString=12]="PrintableString",t[t.TeletexString=13]="TeletexString",t[t.VideotexString=14]="VideotexString",t[t.IA5String=15]="IA5String",t[t.GraphicString=16]="GraphicString",t[t.VisibleString=17]="VisibleString",t[t.GeneralString=18]="GeneralString",t[t.CharacterString=19]="CharacterString",t[t.UTCTime=20]="UTCTime",t[t.GeneralizedTime=21]="GeneralizedTime",t[t.DATE=22]="DATE",t[t.TimeOfDay=23]="TimeOfDay",t[t.DateTime=24]="DateTime",t[t.Duration=25]="Duration",t[t.TIME=26]="TIME",t[t.Null=27]="Null"}(kt||(kt={}));const xt=new class{constructor(){this.items=new WeakMap}has(t){return this.items.has(t)}get(t){var e,r,n,i;const s=this.items.get(t);if(!s)throw new Error(`Cannot get schema for '${null!==(i=null===(n=null===(r=null===(e=t)||void 0===e?void 0:e.prototype)||void 0===r?void 0:r.constructor)||void 0===n?void 0:n.name)&&void 0!==i?i:t}' target`);return s}cache(t){const e=this.get(t);e.schema||(e.schema=this.create(t,!0))}createDefault(t){const e={type:bt.Sequence,items:{}},r=this.findParentSchema(t);return r&&(Object.assign(e,r),e.items=Object.assign({},e.items,r.items)),e}create(t,e){const r=this.items.get(t)||this.createDefault(t),n=[];for(const i in r.items){const t=r.items[i],s=e?i:"";let o;if("number"==typeof t.type){const e=kt[t.type],r=Y[e];if(!r)throw new Error(`Cannot get ASN1 class by name '${e}'`);o=new r({name:s})}else o=Bt(t.type)?(new t.type).toSchema(s):new E({name:s});const c=!!t.optional||void 0!==t.defaultValue;if(t.repeated&&(o.name="",o=new("set"===t.repeated?z:F)({name:"",value:[new B({name:s,value:o})]})),null!=t.context)if(t.implicit)if("number"==typeof t.type||Bt(t.type))n.push(new(t.repeated?Z:Q)({name:s,optional:c,idBlock:{tagClass:3,tagNumber:t.context}}));else{this.cache(t.type);const e=!!t.repeated;let r=e?o:this.get(t.type).schema;r=r.valueBlock?r.valueBlock.value:r.value,n.push(new Z({name:e?"":s,optional:c,idBlock:{tagClass:3,tagNumber:t.context},value:r}))}else n.push(new Z({optional:c,idBlock:{tagClass:3,tagNumber:t.context},value:[o]}));else o.optional=c,n.push(o)}switch(r.type){case bt.Sequence:return new F({value:n,name:""});case bt.Set:return new z({value:n,name:""});case bt.Choice:return new x({value:n,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(t,e){return this.items.set(t,e),this}findParentSchema(t){const e=t.__proto__;return e?this.items.get(e)||this.findParentSchema(e):null}},Nt=t=>e=>{let r;xt.has(e)?r=xt.get(e):(r=xt.createDefault(e),xt.set(e,r)),Object.assign(r,t)},Kt=t=>(e,r)=>{let n;xt.has(e.constructor)?n=xt.get(e.constructor):(n=xt.createDefault(e.constructor),xt.set(e.constructor,n));const i=Object.assign({},t);if("number"==typeof i.type&&!i.converter){const n=`Asn${kt[t.type]}Converter`,s=St[n];if(!s)throw new Error(`Cannot get '${n}' for property '${r}' of ${e.constructor.name}`);i.converter=s}n.items[r]=i};class Ut extends Error{constructor(){super(...arguments),this.schemas=[]}}class Ct{static parse(t,e){let r;if(t instanceof ArrayBuffer)r=t;else if(void 0!==typeof Buffer&&Buffer.isBuffer(t))r=new Uint8Array(t).buffer;else{if(!ArrayBuffer.isView(t))throw new TypeError("Wrong type of 'data' argument");r=t.buffer}const n=k(r);if(n.result.error)throw new Error(n.result.error);return this.fromASN(n.result,e)}static fromASN(t,e){var r;try{if(Bt(e))return(new e).fromASN(t);const n=xt.get(e);xt.cache(e);let i=n.schema;if(t.constructor===Z&&n.type!==bt.Choice){i=new Z({idBlock:{tagClass:3,tagNumber:t.idBlock.tagNumber},value:n.schema.valueBlock.value});for(const e in n.items)delete t[e]}const s=S(t,t,i);if(!s.verified)throw new Ut(`Data does not match to ${e.name} ASN1 schema. ${s.result.error}`);const o=new e;if(function t(e){var r;if(e){const n=Object.getPrototypeOf(e);return(null===(r=null==n?void 0:n.prototype)||void 0===r?void 0:r.constructor)===Array||t(n)}return!1}(e))return e.from(t.valueBlock.value,t=>this.fromASN(t,n.itemType));for(const e in n.items){if(!t[e])continue;const i=n.items[e];if("number"==typeof i.type||Bt(i.type)){const n=null!==(r=i.converter)&&void 0!==r?r:Bt(i.type)?new i.type:null;if(!n)throw new Error("Converter is empty");if(i.repeated)if(i.implicit){const r=new("sequence"===i.repeated?F:z);r.valueBlock=t[e].valueBlock;const s=k(r.toBER(!1)).result.valueBlock.value;o[e]=Array.from(s,t=>n.fromASN(t))}else o[e]=Array.from(t[e],t=>n.fromASN(t));else{let r=t[e];if(i.implicit){let t;if(Bt(i.type))t=(new i.type).toSchema("");else{const e=kt[i.type],r=Y[e];if(!r)throw new Error(`Cannot get '${e}' class from asn1js module`);t=new r}t.valueBlock=r.valueBlock,r=k(t.toBER(!1)).result}o[e]=n.fromASN(r)}}else o[e]=i.repeated?Array.from(t[e],t=>this.fromASN(t,i.type)):this.fromASN(t[e],i.type)}return o}catch(n){throw n instanceof Ut&&n.schemas.push(e.name),n}}}class Ot{static serialize(t){return t instanceof X?t.toBER(!1):this.toASN(t).toBER(!1)}static toASN(t){if(t&&Bt(t.constructor))return t.toASN();const e=t.constructor,r=xt.get(e);xt.cache(e);let n,i=[];if(r.itemType)i=t.map(t=>this.toAsnItem({type:r.itemType},"[]",e,t));else for(const s in r.items){const n=r.items[s],o=t[s];if(void 0===o||n.defaultValue===o||"object"==typeof n.defaultValue&&"object"==typeof o&&Et(this.serialize(n.defaultValue),this.serialize(o)))continue;let c=Ot.toAsnItem(n,s,e,o);if("number"==typeof n.context)if(n.implicit)if(n.repeated||"number"!=typeof n.type&&!Bt(n.type))i.push(new Z({optional:n.optional,idBlock:{tagClass:3,tagNumber:n.context},value:c.valueBlock.value}));else{const t={};t.valueHex=c.valueBlock.toBER(),i.push(new Q(Object.assign({optional:n.optional,idBlock:{tagClass:3,tagNumber:n.context}},t)))}else i.push(new Z({optional:n.optional,idBlock:{tagClass:3,tagNumber:n.context},value:[c]}));else n.repeated?i=i.concat(c):i.push(c)}switch(r.type){case bt.Sequence:n=new F({value:i});break;case bt.Set:n=new z({value:i});break;case bt.Choice:if(!i[0])throw new Error(`Schema '${e.name}' has wrong data. Choice cannot be empty.`);n=i[0]}return n}static toAsnItem(t,e,r,n){let i;if("number"==typeof t.type){const s=t.converter;if(!s)throw new Error(`Property '${e}' doesn't have converter for type ${kt[t.type]} in schema '${r.name}'`);if(t.repeated){const e=Array.from(n,t=>s.toASN(t));i=new("sequence"===t.repeated?F:z)({value:e})}else i=s.toASN(n)}else if(t.repeated){const e=Array.from(n,t=>this.toASN(t));i=new("sequence"===t.repeated?F:z)({value:e})}else i=this.toASN(n);return i}}class It extends Error{constructor(t,e){super(e?t+". See the inner exception for more details.":t),this.message=t,this.innerError=e}}class Tt extends It{constructor(t,e,r){super(e,r),this.schema=t}}class jt extends Tt{constructor(t,e,r){super(t,`JSON doesn't match to '${t.target.name}' schema. ${e}`,r)}}class Dt extends It{}class Rt extends It{constructor(t,e,r){super(`Cannot serialize by '${t}' schema. ${e}`,r),this.schemaName=t}}class Pt extends jt{constructor(t,e,r={}){super(t,"Some keys doesn't match to schema"),this.keys=e,this.errors=r}}var Mt;function $t(t,e){if(!function(t,e){switch(e){case Mt.Boolean:return"boolean"==typeof t;case Mt.Number:return"number"==typeof t;case Mt.String:return"string"==typeof t}return!0}(t,e))throw new TypeError("Value must be "+Mt[e])}function Ht(t){return t&&t.prototype?!(!t.prototype.toJSON||!t.prototype.fromJSON)||Ht(t.prototype):!!(t&&t.toJSON&&t.fromJSON)}!function(t){t[t.Any=0]="Any",t[t.Boolean=1]="Boolean",t[t.Number=2]="Number",t[t.String=3]="String"}(Mt||(Mt={}));const Jt=new class{constructor(){this.items=new Map}has(t){return this.items.has(t)||!!this.findParentSchema(t)}get(t){const e=this.items.get(t)||this.findParentSchema(t);if(!e)throw new Error("Cannot get schema for current target");return e}create(t){const e={names:{}},r=this.findParentSchema(t);if(r){Object.assign(e,r),e.names={};for(const t in r.names)e.names[t]=Object.assign({},r.names[t])}return e.target=t,e}set(t,e){return this.items.set(t,e),this}findParentSchema(t){const e=t.__proto__;return e?this.items.get(e)||this.findParentSchema(e):null}};class Vt{constructor(t){this.pattern=new RegExp(t)}validate(t){const e=new RegExp(this.pattern.source,this.pattern.flags);if("string"!=typeof t)throw new Dt("Incoming value must be string");if(!e.exec(t))throw new Dt(`Value doesn't match to pattern '${e.toString()}'`)}}class Gt{constructor(t=Number.MIN_VALUE,e=Number.MAX_VALUE){this.min=t,this.max=e}validate(t){if($t(t,Mt.Number),!(this.min<=t&&t<=this.max))throw new Dt(`Value doesn't match to diapason [${this.min===Number.MIN_VALUE?"MIN":this.min},${this.max===Number.MAX_VALUE?"MAX":this.max}]`)}}class Wt{constructor(t=Number.MIN_VALUE,e=Number.MAX_VALUE){this.min=t,this.max=e}validate(t){if($t(t,Mt.Number),!(this.min<t&&t<this.max))throw new Dt(`Value doesn't match to diapason (${this.min===Number.MIN_VALUE?"MIN":this.min},${this.max===Number.MAX_VALUE?"MAX":this.max})`)}}class _t{constructor(t,e,r){this.length=t,this.minLength=e,this.maxLength=r}validate(t){if(void 0===this.length){if(void 0!==this.minLength&&t.length<this.minLength)throw new Dt(`Value length must be more than ${this.minLength}.`);if(void 0!==this.maxLength&&t.length>this.maxLength)throw new Dt(`Value length must be less than ${this.maxLength}.`)}else if(t.length!==this.length)throw new Dt(`Value length must be exactly ${this.length}.`)}}class qt{constructor(t){this.enumeration=t}validate(t){if($t(t,Mt.String),!this.enumeration.includes(t))throw new Dt("Value must be one of "+this.enumeration.map(t=>`'${t}'`).join(", "))}}class zt{static checkValues(t,e){const r=Array.isArray(t)?t:[t];for(const n of r)for(const r of e.validations)r.validate(r instanceof _t&&e.repeated?t:n)}static checkTypes(t,e){if(e.repeated&&!Array.isArray(t))throw new TypeError("Value must be Array");if("number"==typeof e.type){const r=Array.isArray(t)?t:[t];for(const t of r)$t(t,e.type)}}static getSchemaByName(t,e="default"){return s(s({},t.names.default),t.names[e])}}class Ft extends zt{static serialize(t,e,r,n){const i=this.toJSON(t,e);return JSON.stringify(i,r,n)}static toJSON(t,e={}){let r,n=e.targetSchema;const i=e.schemaName||"default";if(Ht(t))return t.toJSON();if(Array.isArray(t)){r=[];for(const n of t)r.push(this.toJSON(n,e))}else if("object"==typeof t){if(n&&!Jt.has(n))throw new It("Cannot get schema for `targetSchema` param");if(n=n||t.constructor,Jt.has(n)){const e=Jt.get(n);r={};const o=this.getSchemaByName(e,i);for(const c in o)try{const e=o[c],s=t[c];let a;if(e.optional&&void 0===s||void 0!==e.defaultValue&&s===e.defaultValue)continue;if(!e.optional&&void 0===s)throw new Rt(n.name,`Property '${c}' is required.`);a="number"==typeof e.type?e.converter?e.repeated?s.map(r=>e.converter.toJSON(r,t)):e.converter.toJSON(s,t):s:e.repeated?s.map(t=>this.toJSON(t,{schemaName:i})):this.toJSON(s,{schemaName:i}),this.checkTypes(a,e),this.checkValues(a,e),r[e.name||c]=a}catch(s){throw s instanceof Rt?s:new Rt(e.target.name,`Property '${c}' is wrong. ${s.message}`,s)}}else{r={};for(const e in t)r[e]=this.toJSON(t[e],{schemaName:i})}}else r=t;return r}}class Lt extends zt{static parse(t,e){const r=JSON.parse(t);return this.fromJSON(r,e)}static fromJSON(t,e){const r=e.targetSchema,n=e.schemaName||"default",i=new r;if(Ht(i))return i.fromJSON(t);const o=Jt.get(r),c=this.getSchemaByName(o,n),a={};e.strictProperty&&!Array.isArray(t)&&Lt.checkStrictProperty(t,c,o);for(const f in c)try{const r=c[f],a=r.name||f,u=t[a];if(void 0===u&&(r.optional||void 0!==r.defaultValue))continue;if(!r.optional&&void 0===u)throw new jt(o,`Property '${a}' is required.`);if(this.checkTypes(u,r),this.checkValues(u,r),"number"==typeof r.type)i[f]=r.converter?r.repeated?u.map(t=>r.converter.fromJSON(t,i)):r.converter.fromJSON(u,i):u;else{const t=s(s({},e),{},{targetSchema:r.type,schemaName:n});i[f]=r.repeated?u.map(e=>this.fromJSON(e,t)):this.fromJSON(u,t)}}catch(h){if(h instanceof jt||(h=new jt(o,`Property '${f}' is wrong. ${h.message}`,h)),!e.strictAllKeys)throw h;a[f]=h}const u=Object.keys(a);if(u.length)throw new Pt(o,u,a);return i}static checkStrictProperty(t,e,r){const n=Object.keys(t),i=Object.keys(e),s=[];for(const o of n)-1===i.indexOf(o)&&s.push(o);if(s.length)throw new Pt(r,s)}}const Zt=(t={})=>(e,r)=>{const n=`Cannot set type for ${r} property of ${e.constructor.name} schema`;let i;Jt.has(e.constructor)?(i=Jt.get(e.constructor),i.target!==e.constructor&&(i=Jt.create(e.constructor),Jt.set(e.constructor,i))):(i=Jt.create(e.constructor),Jt.set(e.constructor,i));const s=Object.assign({type:Mt.Any,validations:[]},t);if(s.validations=function(t){const e=[];return t.pattern&&e.push(new Vt(t.pattern)),t.type!==Mt.Number&&t.type!==Mt.Any||(void 0===t.minInclusive&&void 0===t.maxInclusive||e.push(new Gt(t.minInclusive,t.maxInclusive)),void 0===t.minExclusive&&void 0===t.maxExclusive||e.push(new Wt(t.minExclusive,t.maxExclusive)),void 0!==t.enumeration&&e.push(new qt(t.enumeration))),(t.type===Mt.String||t.repeated||t.type===Mt.Any)&&(void 0===t.length&&void 0===t.minLength&&void 0===t.maxLength||e.push(new _t(t.length,t.minLength,t.maxLength))),e}(s),"number"!=typeof s.type&&!Jt.has(s.type)&&!Ht(s.type))throw new Error(n+". Assigning type doesn't have schema.");let o;o=Array.isArray(t.schema)?t.schema:[t.schema||"default"];for(const t of o)i.names[t]||(i.names[t]={}),i.names[t][r]=s};class Qt extends Error{}class Xt extends Qt{}class Yt extends Qt{constructor(t){super("Unsupported operation: "+(t?""+t:""))}}class te extends Qt{}class ee extends Qt{constructor(t){super(t+": Missing required property")}}function re(t){return"object"==typeof t&&"kty"in t}class ne{async digest(...t){return this.checkDigest.apply(this,t),this.onDigest.apply(this,t)}checkDigest(t,e){this.checkAlgorithmName(t)}async onDigest(t,e){throw new Yt("digest")}async generateKey(...t){return this.checkGenerateKey.apply(this,t),this.onGenerateKey.apply(this,t)}checkGenerateKey(t,e,r){if(this.checkAlgorithmName(t),this.checkGenerateKeyParams(t),!r||!r.length)throw new TypeError("Usages cannot be empty when creating a key.");let n;n=Array.isArray(this.usages)?this.usages:this.usages.privateKey.concat(this.usages.publicKey),this.checkKeyUsages(r,n)}checkGenerateKeyParams(t){}async onGenerateKey(t,e,r){throw new Yt("generateKey")}async sign(...t){return this.checkSign.apply(this,t),this.onSign.apply(this,t)}checkSign(t,e,r){this.checkAlgorithmName(t),this.checkAlgorithmParams(t),this.checkCryptoKey(e,"sign")}async onSign(t,e,r){throw new Yt("sign")}async verify(...t){return this.checkVerify.apply(this,t),this.onVerify.apply(this,t)}checkVerify(t,e,r,n){this.checkAlgorithmName(t),this.checkAlgorithmParams(t),this.checkCryptoKey(e,"verify")}async onVerify(t,e,r,n){throw new Yt("verify")}async encrypt(...t){return this.checkEncrypt.apply(this,t),this.onEncrypt.apply(this,t)}checkEncrypt(t,e,r,n={}){this.checkAlgorithmName(t),this.checkAlgorithmParams(t),this.checkCryptoKey(e,n.keyUsage?"encrypt":void 0)}async onEncrypt(t,e,r){throw new Yt("encrypt")}async decrypt(...t){return this.checkDecrypt.apply(this,t),this.onDecrypt.apply(this,t)}checkDecrypt(t,e,r,n={}){this.checkAlgorithmName(t),this.checkAlgorithmParams(t),this.checkCryptoKey(e,n.keyUsage?"decrypt":void 0)}async onDecrypt(t,e,r){throw new Yt("decrypt")}async deriveBits(...t){return this.checkDeriveBits.apply(this,t),this.onDeriveBits.apply(this,t)}checkDeriveBits(t,e,r,n={}){if(this.checkAlgorithmName(t),this.checkAlgorithmParams(t),this.checkCryptoKey(e,n.keyUsage?"deriveBits":void 0),r%8!=0)throw new te("length: Is not multiple of 8")}async onDeriveBits(t,e,r){throw new Yt("deriveBits")}async exportKey(...t){return this.checkExportKey.apply(this,t),this.onExportKey.apply(this,t)}checkExportKey(t,e){if(this.checkKeyFormat(t),this.checkCryptoKey(e),!e.extractable)throw new Qt("key: Is not extractable")}async onExportKey(t,e){throw new Yt("exportKey")}async importKey(...t){return this.checkImportKey.apply(this,t),this.onImportKey.apply(this,t)}checkImportKey(t,e,r,n,i){this.checkKeyFormat(t),this.checkKeyData(t,e),this.checkAlgorithmName(r),this.checkImportParams(r),Array.isArray(this.usages)&&this.checkKeyUsages(i,this.usages)}async onImportKey(t,e,r,n,i){throw new Yt("importKey")}checkAlgorithmName(t){if(t.name.toLowerCase()!==this.name.toLowerCase())throw new Xt("Unrecognized name")}checkAlgorithmParams(t){}checkDerivedKeyParams(t){}checkKeyUsages(t,e){for(const r of t)if(-1===e.indexOf(r))throw new TypeError("Cannot create a key using the specified key usages")}checkCryptoKey(t,e){if(this.checkAlgorithmName(t.algorithm),e&&-1===t.usages.indexOf(e))throw new Qt("key does not match that of operation")}checkRequiredProperty(t,e){if(!(e in t))throw new ee(e)}checkHashAlgorithm(t,e){for(const r of e)if(r.toLowerCase()===t.name.toLowerCase())return;throw new te("hash: Must be one of "+e.join(", "))}checkImportParams(t){}checkKeyFormat(t){switch(t){case"raw":case"pkcs8":case"spki":case"jwk":break;default:throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'")}}checkKeyData(t,e){if(!e)throw new TypeError("keyData: Cannot be empty on empty on key importing");if("jwk"===t){if(!re(e))throw new TypeError("keyData: Is not JsonWebToken")}else if(!u.isBufferSource(e))throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer")}prepareData(t){return u.toArrayBuffer(t)}}class ie extends ne{checkGenerateKeyParams(t){if(this.checkRequiredProperty(t,"length"),"number"!=typeof t.length)throw new TypeError("length: Is not of type Number");switch(t.length){case 128:case 192:case 256:break;default:throw new TypeError("length: Must be 128, 192, or 256")}}checkDerivedKeyParams(t){this.checkGenerateKeyParams(t)}}class se extends ie{constructor(){super(...arguments),this.name="AES-CBC",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"iv"),!(t.iv instanceof ArrayBuffer||ArrayBuffer.isView(t.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==t.iv.byteLength)throw new TypeError("iv: Must have length 16 bytes")}}class oe extends ie{constructor(){super(...arguments),this.name="AES-CTR",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"counter"),!(t.counter instanceof ArrayBuffer||ArrayBuffer.isView(t.counter)))throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==t.counter.byteLength)throw new TypeError("iv: Must have length 16 bytes");if(this.checkRequiredProperty(t,"length"),"number"!=typeof t.length)throw new TypeError("length: Is not a Number");if(t.length<1)throw new te("length: Must be more than 0")}}class ce extends ie{constructor(){super(...arguments),this.name="AES-ECB",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}}class ae extends ie{constructor(){super(...arguments),this.name="AES-GCM",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"iv"),!(t.iv instanceof ArrayBuffer||ArrayBuffer.isView(t.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(t.iv.byteLength<1)throw new te("iv: Must have length more than 0 and less than 2^64 - 1");switch("tagLength"in t||(t.tagLength=128),t.tagLength){case 32:case 64:case 96:case 104:case 112:case 120:case 128:break;default:throw new te("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128")}}}class ue extends ie{constructor(){super(...arguments),this.name="AES-KW",this.usages=["wrapKey","unwrapKey"]}}class he extends ne{constructor(){super(...arguments),this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){if(this.ivSize){if(this.checkRequiredProperty(t,"iv"),!(t.iv instanceof ArrayBuffer||ArrayBuffer.isView(t.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(t.iv.byteLength!==this.ivSize)throw new TypeError(`iv: Must have length ${this.ivSize} bytes`)}}checkGenerateKeyParams(t){if(this.checkRequiredProperty(t,"length"),"number"!=typeof t.length)throw new TypeError("length: Is not of type Number");if(t.length!==this.keySizeBits)throw new te("algorith.length: Must be "+this.keySizeBits)}checkDerivedKeyParams(t){this.checkGenerateKeyParams(t)}}class fe extends ne{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}checkGenerateKeyParams(t){if(this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms),this.checkRequiredProperty(t,"publicExponent"),!(t.publicExponent&&t.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const e=a.ToBase64(t.publicExponent);if("Aw=="!==e&&"AQAB"!==e)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");switch(this.checkRequiredProperty(t,"modulusLength"),t.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}checkImportParams(t){this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms)}}class le extends fe{constructor(){super(...arguments),this.name="RSASSA-PKCS1-v1_5",this.usages={privateKey:["sign"],publicKey:["verify"]}}}class ye extends fe{constructor(){super(...arguments),this.name="RSA-PSS",this.usages={privateKey:["sign"],publicKey:["verify"]}}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"saltLength"),"number"!=typeof t.saltLength)throw new TypeError("saltLength: Is not a Number");if(t.saltLength<1)throw new RangeError("saltLength: Must be more than 0")}}class de extends fe{constructor(){super(...arguments),this.name="RSA-OAEP",this.usages={privateKey:["decrypt","unwrapKey"],publicKey:["encrypt","wrapKey"]}}checkAlgorithmParams(t){if(t.label&&!(t.label instanceof ArrayBuffer||ArrayBuffer.isView(t.label)))throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'")}}class we extends ne{checkGenerateKeyParams(t){this.checkRequiredProperty(t,"namedCurve"),this.checkNamedCurve(t.namedCurve)}checkNamedCurve(t){for(const e of this.namedCurves)if(e.toLowerCase()===t.toLowerCase())return;throw new te("namedCurve: Must be one of "+this.namedCurves.join(", "))}}class pe extends we{constructor(){super(...arguments),this.name="ECDSA",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(t){this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms)}}const ve=["secret","private","public"];class me{static create(t,e,r,n){const i=new this;return i.algorithm=t,i.type=e,i.extractable=r,i.usages=n,i}static isKeyType(t){return-1!==ve.indexOf(t)}}class Ae extends we{constructor(){super(...arguments),this.name="ECDH",this.usages={privateKey:["deriveBits","deriveKey"],publicKey:[]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"public"),!(t.public instanceof me))throw new TypeError("public: Is not a CryptoKey");if("public"!==t.public.type)throw new te("public: Is not a public key");if(t.public.algorithm.name!==this.name)throw new te(`public: Is not ${this.name} key`)}}class ge extends ne{constructor(){super(...arguments),this.name="HMAC",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["sign","verify"]}getDefaultLength(t){switch(t.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":return 512;default:throw new Error(`Unknown algorithm name '${t}'`)}}checkGenerateKeyParams(t){if(this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms),"length"in t){if("number"!=typeof t.length)throw new TypeError("length: Is not a Number");if(t.length<1)throw new RangeError("length: Number is out of range")}}checkImportParams(t){this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms)}}class be extends ne{constructor(){super(...arguments),this.name="PBKDF2",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveBits","deriveKey"]}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms),this.checkRequiredProperty(t,"salt"),!(t.salt instanceof ArrayBuffer||ArrayBuffer.isView(t.salt)))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(t,"iterations"),"number"!=typeof t.iterations)throw new TypeError("iterations: Is not a Number");if(t.iterations<1)throw new TypeError("iterations: Is less than 1")}checkImportKey(t,e,r,n,i){if(super.checkImportKey(t,e,r,n,i),n)throw new SyntaxError("extractable: Must be False")}}class ke{constructor(){this.items={}}get(t){return this.items[t.toLowerCase()]||null}set(t){this.items[t.name.toLowerCase()]=t}removeAt(t){const e=this.get(t.toLowerCase());return e&&delete this.items[t],e}has(t){return!!this.get(t)}get length(){return Object.keys(this.items).length}get algorithms(){const t=[];for(const e in this.items)t.push(this.items[e].name);return t.sort()}}class Se{constructor(){this.providers=new ke}static isHashedAlgorithm(t){return!!(t&&"object"==typeof t&&"name"in t&&"hash"in t)}async digest(...t){this.checkRequiredArguments(t,2,"digest");const[e,r]=t,n=this.prepareAlgorithm(e),i=u.toArrayBuffer(r),s=this.getProvider(n.name);return await s.digest(n,i)}async generateKey(...t){this.checkRequiredArguments(t,3,"generateKey");const[e,r,n]=t,i=this.prepareAlgorithm(e),o=this.getProvider(i.name);return await o.generateKey(s(s({},i),{},{name:o.name}),r,n)}async sign(...t){this.checkRequiredArguments(t,3,"sign");const[e,r,n]=t;this.checkCryptoKey(r);const i=this.prepareAlgorithm(e),o=u.toArrayBuffer(n),c=this.getProvider(i.name);return await c.sign(s(s({},i),{},{name:c.name}),r,o)}async verify(...t){this.checkRequiredArguments(t,4,"verify");const[e,r,n,i]=t;this.checkCryptoKey(r);const o=this.prepareAlgorithm(e),c=u.toArrayBuffer(i),a=u.toArrayBuffer(n),h=this.getProvider(o.name);return await h.verify(s(s({},o),{},{name:h.name}),r,a,c)}async encrypt(...t){this.checkRequiredArguments(t,3,"encrypt");const[e,r,n]=t;this.checkCryptoKey(r);const i=this.prepareAlgorithm(e),o=u.toArrayBuffer(n),c=this.getProvider(i.name);return await c.encrypt(s(s({},i),{},{name:c.name}),r,o,{keyUsage:!0})}async decrypt(...t){this.checkRequiredArguments(t,3,"decrypt");const[e,r,n]=t;this.checkCryptoKey(r);const i=this.prepareAlgorithm(e),o=u.toArrayBuffer(n),c=this.getProvider(i.name);return await c.decrypt(s(s({},i),{},{name:c.name}),r,o,{keyUsage:!0})}async deriveBits(...t){this.checkRequiredArguments(t,3,"deriveBits");const[e,r,n]=t;this.checkCryptoKey(r);const i=this.prepareAlgorithm(e),o=this.getProvider(i.name);return await o.deriveBits(s(s({},i),{},{name:o.name}),r,n,{keyUsage:!0})}async deriveKey(...t){this.checkRequiredArguments(t,5,"deriveKey");const[e,r,n,i,o]=t,c=this.prepareAlgorithm(n);this.getProvider(c.name).checkDerivedKeyParams(c);const a=this.prepareAlgorithm(e),u=this.getProvider(a.name);u.checkCryptoKey(r,"deriveKey");const h=await u.deriveBits(s(s({},a),{},{name:u.name}),r,n.length,{keyUsage:!1});return this.importKey("raw",h,n,i,o)}async exportKey(...t){this.checkRequiredArguments(t,2,"exportKey");const[e,r]=t;this.checkCryptoKey(r);const n=this.getProvider(r.algorithm.name);return await n.exportKey(e,r)}async importKey(...t){this.checkRequiredArguments(t,5,"importKey");const[e,r,n,i,o]=t,c=this.prepareAlgorithm(n),a=this.getProvider(c.name);if(-1!==["pkcs8","spki","raw"].indexOf(e)){const t=u.toArrayBuffer(r);return a.importKey(e,t,s(s({},c),{},{name:a.name}),i,o)}if(!r.kty)throw new TypeError("keyData: Is not JSON");return a.importKey(e,r,s(s({},c),{},{name:a.name}),i,o)}async wrapKey(t,e,r,n){let i=await this.exportKey(t,e);if("jwk"===t){const t=JSON.stringify(i);i=a.FromUtf8String(t)}const o=this.prepareAlgorithm(n),c=u.toArrayBuffer(i),h=this.getProvider(o.name);return h.encrypt(s(s({},o),{},{name:h.name}),r,c,{keyUsage:!1})}async unwrapKey(t,e,r,n,i,o,c){const h=this.prepareAlgorithm(n),f=u.toArrayBuffer(e),l=this.getProvider(h.name);let y=await l.decrypt(s(s({},h),{},{name:l.name}),r,f,{keyUsage:!1});if("jwk"===t)try{y=JSON.parse(a.ToUtf8String(y))}catch(d){const t=new TypeError("wrappedKey: Is not a JSON");throw t.internal=d,t}return this.importKey(t,y,i,o,c)}checkRequiredArguments(t,e,r){if(t.length!==e)throw new TypeError(`Failed to execute '${r}' on 'SubtleCrypto': ${e} arguments required, but only ${t.length} present`)}prepareAlgorithm(t){if("string"==typeof t)return{name:t};if(Se.isHashedAlgorithm(t)){const e=s({},t);return e.hash=this.prepareAlgorithm(t.hash),e}return s({},t)}getProvider(t){const e=this.providers.get(t);if(!e)throw new Xt("Unrecognized name");return e}checkCryptoKey(t){if(!(t instanceof me))throw new TypeError("Key is not of type 'CryptoKey'")}}let Be=class{constructor(t){t&&(this.value=t)}};h([Kt({type:kt.ObjectIdentifier})],Be.prototype,"value",void 0),Be=h([Nt({type:bt.Choice})],Be);class Ee{constructor(t){Object.assign(this,t)}}h([Kt({type:kt.ObjectIdentifier})],Ee.prototype,"algorithm",void 0),h([Kt({type:kt.Any,optional:!0})],Ee.prototype,"parameters",void 0);class xe{constructor(){this.version=0,this.privateKeyAlgorithm=new Ee,this.privateKey=new ArrayBuffer(0)}}h([Kt({type:kt.Integer})],xe.prototype,"version",void 0),h([Kt({type:Ee})],xe.prototype,"privateKeyAlgorithm",void 0),h([Kt({type:kt.OctetString})],xe.prototype,"privateKey",void 0),h([Kt({type:kt.Any,optional:!0})],xe.prototype,"attributes",void 0);class Ne{constructor(){this.publicKeyAlgorithm=new Ee,this.publicKey=new ArrayBuffer(0)}}h([Kt({type:Ee})],Ne.prototype,"publicKeyAlgorithm",void 0),h([Kt({type:kt.BitString})],Ne.prototype,"publicKey",void 0);const Ke={fromJSON:t=>a.FromBase64Url(t),toJSON:t=>a.ToBase64Url(new Uint8Array(t))},Ue={fromASN:t=>new Uint8Array(t.valueBlock.valueHex)[0]?t.valueBlock.valueHex:t.valueBlock.valueHex.slice(1),toASN:t=>{const e=new Uint8Array(t)[0]>127?Buffer.concat([Buffer.from([0]),Buffer.from(t)]):Buffer.from(t);return new G({valueHex:new Uint8Array(e).buffer})}};class Ce{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}h([Kt({type:kt.Integer,converter:et})],Ce.prototype,"version",void 0),h([Kt({type:kt.Integer,converter:Ue}),Zt({name:"n",converter:Ke})],Ce.prototype,"modulus",void 0),h([Kt({type:kt.Integer,converter:Ue}),Zt({name:"e",converter:Ke})],Ce.prototype,"publicExponent",void 0),h([Kt({type:kt.Integer,converter:Ue}),Zt({name:"d",converter:Ke})],Ce.prototype,"privateExponent",void 0),h([Kt({type:kt.Integer,converter:Ue}),Zt({name:"p",converter:Ke})],Ce.prototype,"prime1",void 0),h([Kt({type:kt.Integer,converter:Ue}),Zt({name:"q",converter:Ke})],Ce.prototype,"prime2",void 0),h([Kt({type:kt.Integer,converter:Ue}),Zt({name:"dp",converter:Ke})],Ce.prototype,"exponent1",void 0),h([Kt({type:kt.Integer,converter:Ue}),Zt({name:"dq",converter:Ke})],Ce.prototype,"exponent2",void 0),h([Kt({type:kt.Integer,converter:Ue}),Zt({name:"qi",converter:Ke})],Ce.prototype,"coefficient",void 0),h([Kt({type:kt.Any,optional:!0})],Ce.prototype,"otherPrimeInfos",void 0);class Oe{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}h([Kt({type:kt.Integer,converter:Ue}),Zt({name:"n",converter:Ke})],Oe.prototype,"modulus",void 0),h([Kt({type:kt.Integer,converter:Ue}),Zt({name:"e",converter:Ke})],Oe.prototype,"publicExponent",void 0);let Ie=class{constructor(t){this.value=new ArrayBuffer(0),t&&(this.value=t)}toJSON(){let t=new Uint8Array(this.value);if(4!==t[0])throw new Qt("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");t=new Uint8Array(this.value.slice(1));const e=t.length/2;return{x:a.ToBase64Url(t.buffer.slice(0,0+e)),y:a.ToBase64Url(t.buffer.slice(0+e,0+e+e))}}fromJSON(t){if(!("x"in t))throw new Error("x: Missing required property");if(!("y"in t))throw new Error("y: Missing required property");const e=a.FromBase64Url(t.x),r=a.FromBase64Url(t.y),n=Buffer.concat([new Uint8Array([4]),new Uint8Array(e),new Uint8Array(r)]);return this.value=new Uint8Array(n).buffer,this}};h([Kt({type:kt.OctetString})],Ie.prototype,"value",void 0),Ie=h([Nt({type:bt.Choice})],Ie);class Te{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(t){if(!("d"in t))throw new Error("d: Missing required property");if(this.privateKey=a.FromBase64Url(t.d),"x"in t){const e=new Ie;e.fromJSON(t),this.publicKey=Ot.toASN(e).valueBlock.valueHex}return this}toJSON(){const t={};return t.d=a.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(t,new Ie(this.publicKey).toJSON()),t}}h([Kt({type:kt.Integer,converter:et})],Te.prototype,"version",void 0),h([Kt({type:kt.OctetString})],Te.prototype,"privateKey",void 0),h([Kt({context:0,type:kt.Any,optional:!0})],Te.prototype,"parameters",void 0),h([Kt({context:1,type:kt.BitString,optional:!0})],Te.prototype,"publicKey",void 0);const je={fromASN:t=>{const e=new Uint8Array(t.valueBlock.valueHex);return 0===e[0]?e.buffer.slice(1):e.buffer},toASN:t=>{const e=new Uint8Array(t);if(e[0]>127){const t=new Uint8Array(e.length+1);return t.set(e,1),new G({valueHex:t.buffer})}return new G({valueHex:t})}};class De{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(t){const e=u.toUint8Array(t),r=e.byteLength/2,n=new this;return n.r=n.removePadding(e.slice(0,r)),n.s=n.removePadding(e.slice(r,2*r)),n}toWebCryptoSignature(t){t=this.getPointSize();const e=this.addPadding(t,u.toUint8Array(this.r)),r=this.addPadding(t,u.toUint8Array(this.s)),n=new Uint8Array(e.byteLength+r.byteLength);return n.set(e,0),n.set(r,e.length),n.buffer}getPointSize(){switch(Math.max(this.r.byteLength,this.s.byteLength)){case 31:case 32:return 32;case 47:case 48:return 48;case 65:case 66:return 66}throw new Error("Unsupported EC point size")}addPadding(t,e){const r=new Uint8Array(t),n=u.toUint8Array(e);return r.set(n,t-n.length),r}removePadding(t){const e=u.toUint8Array(t);for(let r=0;r<e.length;r++)if(e[r])return e.slice(r);return new Uint8Array(0)}}h([Kt({type:kt.Integer,converter:je})],De.prototype,"r",void 0),h([Kt({type:kt.Integer,converter:je})],De.prototype,"s",void 0);let Re=(()=>{let t=class{constructor(t){t&&(this.value=t)}};return h([Kt({type:kt.ObjectIdentifier})],t.prototype,"value",void 0),t=h([Nt({type:bt.Choice})],t),t})(),Pe=(()=>{class t{constructor(t){Object.assign(this,t)}}return h([Kt({type:kt.ObjectIdentifier})],t.prototype,"algorithm",void 0),h([Kt({type:kt.Any,optional:!0})],t.prototype,"parameters",void 0),t})(),Me=(()=>{class t{constructor(){this.version=0,this.privateKeyAlgorithm=new Pe,this.privateKey=new ArrayBuffer(0)}}return h([Kt({type:kt.Integer})],t.prototype,"version",void 0),h([Kt({type:Pe})],t.prototype,"privateKeyAlgorithm",void 0),h([Kt({type:kt.OctetString})],t.prototype,"privateKey",void 0),h([Kt({type:kt.Any,optional:!0})],t.prototype,"attributes",void 0),t})(),$e=(()=>{class t{constructor(){this.publicKeyAlgorithm=new Pe,this.publicKey=new ArrayBuffer(0)}}return h([Kt({type:Pe})],t.prototype,"publicKeyAlgorithm",void 0),h([Kt({type:kt.BitString})],t.prototype,"publicKey",void 0),t})();const He={fromJSON:t=>a.FromBase64Url(t),toJSON:t=>a.ToBase64Url(new Uint8Array(t))};var Je;function Ve(...t){const e=new Uint8Array(t.map(t=>t.length).reduce((t,e)=>t+e));let r=0;return t.forEach(t=>{for(let n=0;n<t.length;n++)e[r+n]=t[n];r+=t.length}),e}!function(t){t.Unknown="Unknown",t.IE="Internet Explorer",t.Safari="Safari",t.Edge="Edge",t.Chrome="Chrome",t.Firefox="Firefox Mozilla",t.Mobile="Mobile"}(Je||(Je={}));const Ge={fromASN:t=>new Uint8Array(t.valueBlock.valueHex)[0]?t.valueBlock.valueHex:t.valueBlock.valueHex.slice(1),toASN:t=>{const e=new Uint8Array(t)[0]>127?Ve(new Uint8Array([0]),new Uint8Array(t)):new Uint8Array(t);return new G({valueHex:new Uint8Array(e).buffer})}};let We=(()=>{class t{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}return h([Kt({type:kt.Integer,converter:et})],t.prototype,"version",void 0),h([Kt({type:kt.Integer,converter:Ge}),Zt({name:"n",converter:He})],t.prototype,"modulus",void 0),h([Kt({type:kt.Integer,converter:Ge}),Zt({name:"e",converter:He})],t.prototype,"publicExponent",void 0),h([Kt({type:kt.Integer,converter:Ge}),Zt({name:"d",converter:He})],t.prototype,"privateExponent",void 0),h([Kt({type:kt.Integer,converter:Ge}),Zt({name:"p",converter:He})],t.prototype,"prime1",void 0),h([Kt({type:kt.Integer,converter:Ge}),Zt({name:"q",converter:He})],t.prototype,"prime2",void 0),h([Kt({type:kt.Integer,converter:Ge}),Zt({name:"dp",converter:He})],t.prototype,"exponent1",void 0),h([Kt({type:kt.Integer,converter:Ge}),Zt({name:"dq",converter:He})],t.prototype,"exponent2",void 0),h([Kt({type:kt.Integer,converter:Ge}),Zt({name:"qi",converter:He})],t.prototype,"coefficient",void 0),h([Kt({type:kt.Any,optional:!0})],t.prototype,"otherPrimeInfos",void 0),t})(),_e=(()=>{class t{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}return h([Kt({type:kt.Integer,converter:Ge}),Zt({name:"n",converter:He})],t.prototype,"modulus",void 0),h([Kt({type:kt.Integer,converter:Ge}),Zt({name:"e",converter:He})],t.prototype,"publicExponent",void 0),t})(),qe=(()=>{let t=class{constructor(t){this.value=new ArrayBuffer(0),t&&(this.value=t)}toJSON(){let t=new Uint8Array(this.value);if(4!==t[0])throw new Qt("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");t=new Uint8Array(this.value.slice(1));const e=t.length/2;return{x:a.ToBase64Url(t.buffer.slice(0,0+e)),y:a.ToBase64Url(t.buffer.slice(0+e,0+e+e))}}fromJSON(t){if(!("x"in t))throw new Error("x: Missing required property");if(!("y"in t))throw new Error("y: Missing required property");const e=a.FromBase64Url(t.x),r=a.FromBase64Url(t.y),n=Ve(new Uint8Array([4]),new Uint8Array(e),new Uint8Array(r));return this.value=new Uint8Array(n).buffer,this}};return h([Kt({type:kt.OctetString})],t.prototype,"value",void 0),t=h([Nt({type:bt.Choice})],t),t})(),ze=(()=>{class t{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(t){if(!("d"in t))throw new Error("d: Missing required property");if(this.privateKey=a.FromBase64Url(t.d),"x"in t){const e=new qe;e.fromJSON(t),this.publicKey=Ot.toASN(e).valueBlock.valueHex}return this}toJSON(){const t={};return t.d=a.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(t,new qe(this.publicKey).toJSON()),t}}return h([Kt({type:kt.Integer,converter:et})],t.prototype,"version",void 0),h([Kt({type:kt.OctetString})],t.prototype,"privateKey",void 0),h([Kt({context:0,type:kt.Any,optional:!0})],t.prototype,"parameters",void 0),h([Kt({context:1,type:kt.BitString,optional:!0})],t.prototype,"publicKey",void 0),t})();const Fe={fromASN:t=>{const e=new Uint8Array(t.valueBlock.valueHex);return 0===e[0]?e.buffer.slice(1):e.buffer},toASN:t=>{const e=new Uint8Array(t);if(e[0]>127){const t=new Uint8Array(e.length+1);return t.set(e,1),new G({valueHex:t})}return new G({valueHex:t})}};(()=>{class t{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}}h([Kt({type:kt.Integer,converter:Fe})],t.prototype,"r",void 0),h([Kt({type:kt.Integer,converter:Fe})],t.prototype,"s",void 0)})();class Le{static get enabled(){return"undefined"!=typeof self&&self.PV_WEBCRYPTO_LINER_LOG}static log(...t){this.enabled&&console.log.apply(console,t)}static error(...t){this.enabled&&console.error.apply(console,t)}static info(...t){this.enabled&&console.info.apply(console,t)}static warn(...t){this.enabled&&console.warn.apply(console,t)}static trace(...t){this.enabled&&console.trace.apply(console,t)}}class Ze extends me{constructor(t,e,r,n){super(),this.extractable=e,this.type=r,this.usages=n,this.algorithm=Object.assign({},t)}}function Qe(t,e){return t.name.toUpperCase()===e.toUpperCase()}class Xe extends Ze{constructor(t,e,r,n){super(t,e,"secret",r),this.raw=n}toJSON(){return{kty:"oct",alg:this.getJwkAlgorithm(),k:a.ToBase64Url(this.raw),ext:this.extractable,key_ops:this.usages}}getJwkAlgorithm(){switch(this.algorithm.name.toUpperCase()){case"AES-CBC":return`A${this.algorithm.length}CBC`;case"AES-CTR":return`A${this.algorithm.length}CTR`;case"AES-GCM":return`A${this.algorithm.length}GCM`;case"AES-ECB":return`A${this.algorithm.length}ECB`;default:throw new Xt("Unsupported algorithm name")}}}let Ye=(()=>{class r{static checkCryptoKey(t){if(!(t instanceof Xe))throw new TypeError("key: Is not AesCryptoKey")}static generateKey(e,r,n){return f(this,void 0,void 0,(function*(){const i=t.nativeCrypto.getRandomValues(new Uint8Array(e.length/8));return new Xe(e,r,n,i)}))}static encrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,u.toUint8Array(r),!0)}))}static decrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,u.toUint8Array(r),!1)}))}static exportKey(t,e){return f(this,void 0,void 0,(function*(){switch(t){case"jwk":return e.toJSON();case"raw":return e.raw.buffer;default:throw new te("format: Must be 'jwk' or 'raw'")}}))}static importKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){let t;switch(t=re(e)?a.FromBase64Url(e.k):u.toArrayBuffer(e),t.byteLength<<3){case 128:case 192:case 256:break;default:throw new te("keyData: Is wrong key length")}return new Xe({name:r.name,length:t.byteLength<<3},n,i,new Uint8Array(t))}))}static cipher(t,n,i,s){return f(this,void 0,void 0,(function*(){const o=s?"encrypt":"decrypt";let c;if(Qe(t,r.AesCBC)){const r=u.toUint8Array(t.iv);c=e.AES_CBC[o](i,n.raw,void 0,r)}else if(Qe(t,r.AesGCM)){const r=u.toUint8Array(t.iv);let s;t.additionalData&&(s=u.toArrayBuffer(t.additionalData)),c=e.AES_GCM[o](i,n.raw,r,s,(t.tagLength||128)/8)}else{if(!Qe(t,r.AesECB))throw new te("algorithm: Is not recognized");c=e.AES_ECB[o](i,n.raw,!0)}return u.toArrayBuffer(c)}))}}return r.AesCBC="AES-CBC",r.AesECB="AES-ECB",r.AesGCM="AES-GCM",r})();class tr extends se{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ye.generateKey(t,e,r)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ye.encrypt(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ye.decrypt(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ye.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ye.importKey(t,e,r,n,i)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ye.checkCryptoKey(t)}}class er extends ce{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ye.generateKey(t,e,r)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ye.encrypt(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ye.decrypt(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ye.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ye.importKey(t,e,r,n,i)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ye.checkCryptoKey(t)}}class rr extends ae{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ye.generateKey(t,e,r)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ye.encrypt(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ye.decrypt(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ye.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ye.importKey(t,e,r,n,i)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ye.checkCryptoKey(t)}}class nr extends oe{onEncrypt(t,r,n){return f(this,void 0,void 0,(function*(){const i=new e.AES_CTR(r.raw,u.toUint8Array(t.counter)).encrypt(u.toUint8Array(n));return u.toArrayBuffer(i)}))}onDecrypt(t,r,n){return f(this,void 0,void 0,(function*(){const i=new e.AES_CTR(r.raw,u.toUint8Array(t.counter)).decrypt(u.toUint8Array(n));return u.toArrayBuffer(i)}))}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ye.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ye.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ye.importKey(t,e,r,n,i)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ye.checkCryptoKey(t)}}class ir extends ue{onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){throw new Error("Method not implemented.")}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){throw new Error("Method not implemented.")}))}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){throw new Error("Method not implemented.")}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){throw new Error("Method not implemented.")}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){throw new Error("Method not implemented.")}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ye.checkCryptoKey(t)}}class sr extends Ze{constructor(t,e,r,n,i){super(t,e,r,n),this.data=i}}let or=(()=>{class e{static checkCryptoKey(t){if(!(t instanceof sr))throw new TypeError("key: Is not RsaCryptoKey")}static generateKey(e,r,n){return f(this,void 0,void 0,(function*(){const i={name:"RSA-PSS",hash:"SHA-256",publicExponent:e.publicExponent,modulusLength:e.modulusLength},s=yield t.nativeSubtle.generateKey(i,!0,["sign","verify"]),o=new Dn,c=yield o.subtle.exportKey("pkcs8",s.privateKey),a=yield o.subtle.importKey("pkcs8",c,e,r,n.filter(t=>this.privateUsages.includes(t))),u=yield o.subtle.exportKey("spki",s.publicKey);return{privateKey:a,publicKey:yield o.subtle.importKey("spki",u,e,!0,n.filter(t=>this.publicUsages.includes(t)))}}))}static exportKey(t,e){return f(this,void 0,void 0,(function*(){switch(t){case"pkcs8":return this.exportPkcs8Key(e);case"spki":return this.exportSpkiKey(e);case"jwk":return this.exportJwkKey(e);default:throw new te("format: Must be 'jwk', 'pkcs8' or 'spki'")}}))}static importKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){let s;switch(t){case"pkcs8":s=this.importPkcs8Key(e);break;case"spki":s=this.importSpkiKey(e);break;case"jwk":s=this.importJwkKey(e);break;default:throw new te("format: Must be 'jwk', 'pkcs8' or 'spki'")}return new sr(Object.assign({publicExponent:s[1].slice(1===s[1][1]?1:3),modulusLength:s[0].byteLength<<3},r),n,2===s.length?"public":"private",i,s)}))}static randomNonZeroValues(e){return(e=t.nativeCrypto.getRandomValues(e)).map(e=>{for(;!e;)e=t.nativeCrypto.getRandomValues(new Uint8Array(1))[0];return e})}static exportPkcs8Key(t){const e=new Me;return e.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",e.privateKeyAlgorithm.parameters=null,e.privateKey=Ot.serialize(this.exportAsmKey(t.data)),Ot.serialize(e)}static importPkcs8Key(t){const e=Ct.parse(t,Me),r=Ct.parse(e.privateKey,We);return this.importAsmKey(r)}static importSpkiKey(t){const e=Ct.parse(t,$e),r=Ct.parse(e.publicKey,_e);return this.importAsmKey(r)}static exportSpkiKey(t){const e=new _e;e.modulus=t.data[0].buffer,e.publicExponent=t.data[1].buffer.slice(1===t.data[1][1]?1:3);const r=new $e;return r.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",r.publicKeyAlgorithm.parameters=null,r.publicKey=Ot.serialize(e),Ot.serialize(r)}static importJwkKey(t){let e;return e=Lt.fromJSON(t,t.d?{targetSchema:We}:{targetSchema:_e}),this.importAsmKey(e)}static exportJwkKey(t){const e=this.exportAsmKey(t.data),r=Ft.toJSON(e);return r.ext=!0,r.key_ops=t.usages,r.kty="RSA",r.alg=this.getJwkAlgorithm(t.algorithm),r}static getJwkAlgorithm(t){switch(t.name.toUpperCase()){case"RSA-OAEP":const e=/(\d+)$/.exec(t.hash.name)[1];return"RSA-OAEP"+("1"!==e?"-"+e:"");case"RSASSA-PKCS1-V1_5":return"RS"+/(\d+)$/.exec(t.hash.name)[1];case"RSA-PSS":return"PS"+/(\d+)$/.exec(t.hash.name)[1];case"RSAES-PKCS1-V1_5":return"PS1";default:throw new te("algorithm: Is not recognized")}}static exportAsmKey(t){let e;if(t.length>2){const r=new We;r.privateExponent=t[2].buffer,r.prime1=t[3].buffer,r.prime2=t[4].buffer,r.exponent1=t[5].buffer,r.exponent2=t[6].buffer,r.coefficient=t[7].buffer,e=r}else e=new _e;return e.modulus=t[0].buffer,e.publicExponent=t[1].buffer.slice(1===t[1][1]?1:3),e}static importAsmKey(t){const e=new Uint8Array(4-t.publicExponent.byteLength),r=[new Uint8Array(t.modulus),Ve(e,new Uint8Array(t.publicExponent))];return t instanceof We&&(r.push(new Uint8Array(t.privateExponent)),r.push(new Uint8Array(t.prime1)),r.push(new Uint8Array(t.prime2)),r.push(new Uint8Array(t.exponent1)),r.push(new Uint8Array(t.exponent2)),r.push(new Uint8Array(t.coefficient))),r}}return e.RsaSsa="RSASSA-PKCS1-v1_5",e.RsaPss="RSA-PSS",e.RsaOaep="RSA-OAEP",e.privateUsages=["sign","decrypt","unwrapKey"],e.publicUsages=["verify","encrypt","wrapKey"],e})();class cr{static getDigest(t){switch(t){case"SHA-1":return new e.Sha1;case"SHA-256":return new e.Sha256;case"SHA-512":return new e.Sha512;default:throw new Xt("keyAlgorithm.hash: Is not recognized")}}static digest(t,e){return f(this,void 0,void 0,(function*(){const r=this.getDigest(t.name).process(u.toUint8Array(e)).finish().result;return u.toArrayBuffer(r)}))}}class ar extends de{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return or.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return or.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return or.importKey(t,e,r,n,i)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,r)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),or.checkCryptoKey(t)}cipher(t,r,n){const i=cr.getDigest(r.algorithm.hash.name);let s;t.label&&(s=u.toUint8Array(t.label));const o=new e.RSA_OAEP(r.data,i,s);let c;const a=u.toUint8Array(n);return c="public"===r.type?o.encrypt(a):o.decrypt(a),u.toArrayBuffer(c)}}class ur extends ye{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return or.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return or.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return or.importKey(t,e,r,n,i)}))}onSign(t,r,n){return f(this,void 0,void 0,(function*(){const i=new e.RSA_PSS(r.data,cr.getDigest(r.algorithm.hash.name),t.saltLength).sign(u.toUint8Array(n));return u.toArrayBuffer(i)}))}onVerify(t,r,n,i){return f(this,void 0,void 0,(function*(){const s=new e.RSA_PSS(r.data,cr.getDigest(r.algorithm.hash.name),t.saltLength);try{s.verify(u.toUint8Array(n),u.toUint8Array(i))}catch(o){return!1}return!0}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),or.checkCryptoKey(t)}}class hr extends le{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return or.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return or.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return or.importKey(t,e,r,n,i)}))}onSign(t,r,n){return f(this,void 0,void 0,(function*(){const t=new e.RSA_PKCS1_v1_5(r.data,cr.getDigest(r.algorithm.hash.name)).sign(u.toUint8Array(n));return u.toArrayBuffer(t)}))}onVerify(t,r,n,i){return f(this,void 0,void 0,(function*(){const t=new e.RSA_PKCS1_v1_5(r.data,cr.getDigest(r.algorithm.hash.name));try{t.verify(u.toUint8Array(n),u.toUint8Array(i))}catch(s){return!1}return!0}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),or.checkCryptoKey(t)}}class fr extends ne{constructor(){super(...arguments),this.name="RSAES-PKCS1-v1_5",this.usages={publicKey:["encrypt","wrapKey"],privateKey:["decrypt","unwrapKey"]},this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return or.generateKey(t,e,r)}))}checkGenerateKeyParams(t){if(this.checkRequiredProperty(t,"publicExponent"),!(t.publicExponent&&t.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const e=a.ToBase64(t.publicExponent);if("Aw=="!==e&&"AQAB"!==e)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");switch(this.checkRequiredProperty(t,"modulusLength"),t.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}onDecrypt(t,r,n){return f(this,void 0,void 0,(function*(){const t=new e.RSA(r.data).decrypt(new e.BigNumber(u.toUint8Array(n))).result;if(n.byteLength!==r.algorithm.modulusLength>>3)throw new Qt("Decryption error. Encrypted message size doesn't match to key length");let i=0;if(t[i++]||2!==t[i++])throw new Qt("Decryption error");do{if(0===t[i++])break}while(i<t.length);if(i<11)throw new Qt("Decryption error. PS is less than 8 octets.");if(i===t.length)throw new Qt("Decryption error. There is no octet with hexadecimal value 0x00 to separate PS from M");return t.buffer.slice(i)}))}onEncrypt(t,r,n){return f(this,void 0,void 0,(function*(){const t=r.algorithm.modulusLength>>3;if(n.byteLength>t-11)throw new Qt("Message too long");const i=t-n.byteLength-3,s=or.randomNonZeroValues(new Uint8Array(i)),o=new Uint8Array(t);o[0]=0,o[1]=2,o.set(s,2),o[2+i]=0,o.set(new Uint8Array(n),3+i);const c=new e.RSA(r.data).encrypt(new e.BigNumber(o)).result;return u.toArrayBuffer(c)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return or.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return yield or.importKey(t,e,Object.assign(Object.assign({},r),{name:this.name}),n,i)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),or.checkCryptoKey(t)}prepareSignData(t,e){return f(this,void 0,void 0,(function*(){return(new Dn).subtle.digest(t.hash,e)}))}}const lr={"1.2.840.10045.3.1.7":"P-256","P-256":"1.2.840.10045.3.1.7","1.3.132.0.34":"P-384","P-384":"1.3.132.0.34","1.3.132.0.35":"P-521","P-521":"1.3.132.0.35","1.3.132.0.10":"K-256","K-256":"1.3.132.0.10"};function yr(t){const e=lr[t];if(!e)throw new te(`Cannot convert WebCrypto named curve '${t}' to OID`);return e}class dr extends Ze{constructor(t,e,r,n,i){super(t,e,r,n),this.data=i}}let wr=(()=>{class t{static checkLib(){if(void 0===r)throw new te("Cannot implement EC mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/elliptic.js' script to your project")}static generateKey(t,e,r){return f(this,void 0,void 0,(function*(){this.checkLib();const n=this.initEcKey(t.namedCurve).genKeyPair();return n.getPublic(),{privateKey:new dr(Object.assign({},t),e,"private",r.filter(t=>~this.privateUsages.indexOf(t)),n),publicKey:new dr(Object.assign({},t),!0,"public",r.filter(t=>~this.publicUsages.indexOf(t)),n)}}))}static checkCryptoKey(t){if(!(t instanceof dr))throw new TypeError("key: Is not EcCryptoKey")}static concat(...t){const e=new Uint8Array(t.map(t=>t.length).reduce((t,e)=>t+e));let r=0;return t.forEach(t=>{for(let n=0;n<t.length;n++)e[r+n]=t[n];r+=t.length}),e}static exportKey(t,e){return f(this,void 0,void 0,(function*(){switch(this.checkLib(),t){case"pkcs8":return this.exportPkcs8Key(e);case"spki":return this.exportSpkiKey(e);case"jwk":return this.exportJwkKey(e);case"raw":return new Uint8Array(e.data.getPublic("der")).buffer;default:throw new te("format: Must be 'jwk', 'raw, 'pkcs8' or 'spki'")}}))}static importKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){let s;switch(this.checkLib(),t){case"pkcs8":s=this.importPkcs8Key(e,r.namedCurve);break;case"spki":s=this.importSpkiKey(e,r.namedCurve);break;case"raw":s=this.importEcKey(new qe(e),r.namedCurve);break;case"jwk":s=this.importJwkKey(e);break;default:throw new te("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}return new dr(Object.assign({},r),n,s.priv?"private":"public",i,s)}))}static getNamedCurve(t){const e=t.toUpperCase();let r="";if(["P-256","P-384","P-521"].indexOf(e)>-1)r=e.replace("-","").toLowerCase();else{if("K-256"!==e)throw new te(`Unsupported named curve '${t}'`);r="secp256k1"}return r}static initEcKey(t){return r.ec(this.getNamedCurve(t))}static exportPkcs8Key(t){const e=new Me;return e.privateKeyAlgorithm.algorithm=this.ASN_ALGORITHM,e.privateKeyAlgorithm.parameters=Ot.serialize(new Re(yr(t.algorithm.namedCurve))),e.privateKey=Ot.serialize(this.exportEcKey(t)),Ot.serialize(e)}static importPkcs8Key(t,e){const r=Ct.parse(t,Me),n=Ct.parse(r.privateKey,ze);return this.importEcKey(n,e)}static importSpkiKey(t,e){const r=Ct.parse(t,$e),n=new qe(r.publicKey);return this.importEcKey(n,e)}static exportSpkiKey(t){const e=new qe(new Uint8Array(t.data.getPublic("der")).buffer),r=new $e;return r.publicKeyAlgorithm.algorithm=this.ASN_ALGORITHM,r.publicKeyAlgorithm.parameters=Ot.serialize(new Re(yr(t.algorithm.namedCurve))),r.publicKey=e.value,Ot.serialize(r)}static importJwkKey(t){let e;return e=Lt.fromJSON(t,t.d?{targetSchema:ze}:{targetSchema:qe}),this.importEcKey(e,t.crv)}static exportJwkKey(t){const e=this.exportEcKey(t),r=Ft.toJSON(e);return r.ext=!0,r.key_ops=t.usages,r.crv=t.algorithm.namedCurve,r.kty="EC",r}static exportEcKey(t){if("private"===t.type){const e=new ze,r=new Uint8Array(t.data.getPrivate("der").toArray()),n=new Uint8Array(this.getPointSize(t.algorithm.namedCurve)-r.length);return e.privateKey=Ve(n,r),e.publicKey=new Uint8Array(t.data.getPublic("der")),e}if(t.data.pub)return new qe(new Uint8Array(t.data.getPublic("der")).buffer);throw new Error("Cannot get private or public key")}static importEcKey(t,e){const r=this.initEcKey(e);return t instanceof qe?r.keyFromPublic(new Uint8Array(t.value)):r.keyFromPrivate(new Uint8Array(t.privateKey))}static getPointSize(t){switch(t){case"P-256":case"K-256":return 32;case"P-384":return 48;case"P-521":return 66}throw new Error("namedCurve: Is not recognized")}}return t.privateUsages=["sign","deriveKey","deriveBits"],t.publicUsages=["verify"],t.ASN_ALGORITHM="1.2.840.10045.2.1",t})();class pr extends Ae{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return wr.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return wr.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return wr.importKey(t,e,r,n,i)}))}onDeriveBits(t,e,r){return f(this,void 0,void 0,(function*(){wr.checkLib();const n=e.data.derive(t.public.data.getPublic());let i=new Uint8Array(n.toArray()),s=i.length;return s=s>32?s>48?66:48:32,i.length<s&&(i=wr.concat(new Uint8Array(s-i.length),i)),i.slice(0,r/8).buffer}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),wr.checkCryptoKey(t)}}function vr(t){const e=new Uint8Array(t),r=[];for(let n=0;n<e.length;n++)r.push(e[n]);return r}function mr(t,e){let r="";for(let n=0;n<t.length;n++){const e=t[n].toString(16);r+=e.length%2?"0"+e:e}if(e){let e=t.length;e=e>32?e>48?66:48:32,r.length/2<e&&(r=new Array(2*e-r.length+1).join("0")+r)}return r}class Ar extends pe{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return wr.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return wr.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return wr.importKey(t,e,r,n,i)}))}onSign(t,e,r){return f(this,void 0,void 0,(function*(){wr.checkLib();const n=new Dn;let i;i=vr(yield n.subtle.digest(t.hash,r));const s=yield e.data.sign(i);return function(t){t.length%2&&(t="0"+t);let e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r++){const n=t.slice(r,1+ ++r);e[(r-1)/2]=parseInt(n,16)}return e}(mr(s.r.toArray(),!0)+mr(s.s.toArray(),!0)).buffer}))}onVerify(t,e,r,n){return f(this,void 0,void 0,(function*(){wr.checkLib();const i=new Dn,s={r:new Uint8Array(r.slice(0,r.byteLength/2)),s:new Uint8Array(r.slice(r.byteLength/2))},o=vr(yield i.subtle.digest(t.hash,n));return e.data.verify(o,s)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),wr.checkCryptoKey(t)}}class gr extends ne{constructor(){super(...arguments),this.name="SHA-1",this.usages=[]}onDigest(t,e){return f(this,void 0,void 0,(function*(){return cr.digest(t,e)}))}}class br extends gr{constructor(){super(...arguments),this.name="SHA-256"}}class kr extends gr{constructor(){super(...arguments),this.name="SHA-512"}}class Sr extends Ze{constructor(t,e,r,n){super(t,e,"secret",r),this.raw=n}}class Br extends be{onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return new Sr(r,n,i,u.toUint8Array(e))}))}onDeriveBits(t,r,n){return f(this,void 0,void 0,(function*(){let i;const s=u.toUint8Array(t.salt),o=r.raw;switch(t.hash.name.toUpperCase()){case"SHA-1":i=e.Pbkdf2HmacSha1(o,s,t.iterations,n>>3);break;case"SHA-256":i=e.Pbkdf2HmacSha256(o,s,t.iterations,n>>3);break;case"SHA-512":i=e.Pbkdf2HmacSha512(o,s,t.iterations,n>>3);break;default:throw new te(`algorithm.hash: '${t.hash.name}' hash algorithm is not supported`)}return u.toArrayBuffer(i)}))}checkCryptoKey(t,e){if(super.checkCryptoKey(t,e),!(t instanceof Sr))throw new TypeError("key: Is not PbkdfCryptoKey")}}var Er=[14,11,17,4,27,23,25,0,13,22,7,18,5,9,16,24,2,20,12,21,1,8,15,26,15,4,25,19,9,1,26,16,5,11,23,8,12,7,17,0,22,3,10,14,6,20,27,24],xr=[14,0,4,15,13,7,1,4,2,14,15,2,11,13,8,1,3,10,10,6,6,12,12,11,5,9,9,5,0,3,7,8,4,15,1,12,14,8,8,2,13,4,6,9,2,1,11,7,15,5,12,11,9,3,7,14,3,10,10,0,5,6,0,13,15,3,1,13,8,4,14,7,6,15,11,2,3,8,4,14,9,12,7,0,2,1,13,10,12,6,0,9,5,11,10,5,0,13,14,8,7,10,11,1,10,3,4,15,13,4,1,2,5,11,8,6,12,7,6,12,9,0,3,5,2,14,15,9,10,13,0,7,9,0,14,9,6,3,3,4,15,6,5,10,1,2,13,8,12,5,7,14,11,12,4,11,2,15,8,1,13,1,6,10,4,13,9,0,8,6,15,9,3,8,0,7,11,4,1,15,2,14,12,3,5,11,10,5,14,2,7,12,7,13,13,8,14,11,3,5,0,6,6,15,9,0,10,3,1,4,2,7,8,2,5,12,11,1,12,10,4,14,15,9,10,3,6,15,9,0,0,6,12,10,11,1,7,13,13,8,15,9,1,4,3,5,14,11,5,12,2,7,8,2,4,14,2,14,12,11,4,2,1,12,7,4,10,7,11,13,6,1,8,5,5,0,3,15,15,10,13,3,0,9,14,8,9,6,4,11,2,8,1,12,11,7,10,1,13,14,7,2,8,13,15,6,9,15,12,0,5,9,6,10,3,4,0,5,14,3,12,10,1,15,10,4,15,2,9,7,2,12,6,9,8,5,0,6,13,1,3,13,4,14,14,0,7,11,5,3,11,8,9,4,14,3,15,2,5,12,2,9,8,5,12,15,3,10,7,11,0,14,4,1,10,7,1,6,13,0,11,8,6,13,4,13,11,0,2,11,14,7,15,4,0,9,8,1,13,10,3,14,12,3,9,5,7,12,5,2,10,15,6,8,1,6,1,6,4,11,11,13,13,8,12,1,3,4,7,10,14,7,10,9,15,5,6,0,8,15,0,14,5,2,9,3,2,12,13,1,2,15,8,13,4,8,6,10,15,3,11,7,1,4,10,12,9,5,3,6,14,11,5,0,0,14,12,9,7,2,7,2,11,1,4,14,1,7,9,4,12,10,14,8,2,13,0,15,6,12,10,9,13,0,15,3,3,5,5,6,8,11],Nr=[16,25,12,11,3,20,4,15,31,17,9,6,27,14,1,22,30,24,8,18,0,5,29,23,13,19,2,26,10,21,28,7],Kr={readUInt32BE:function(t,e){return(t[0+e]<<24|t[1+e]<<16|t[2+e]<<8|t[3+e])>>>0},writeUInt32BE:function(t,e,r){t[0+r]=e>>>24,t[1+r]=e>>>16&255,t[2+r]=e>>>8&255,t[3+r]=255&e},ip:function(t,e,r,n){for(var i=0,s=0,o=6;o>=0;o-=2){for(var c=0;c<=24;c+=8)i<<=1,i|=e>>>c+o&1;for(c=0;c<=24;c+=8)i<<=1,i|=t>>>c+o&1}for(o=6;o>=0;o-=2){for(c=1;c<=25;c+=8)s<<=1,s|=e>>>c+o&1;for(c=1;c<=25;c+=8)s<<=1,s|=t>>>c+o&1}r[n+0]=i>>>0,r[n+1]=s>>>0},rip:function(t,e,r,n){for(var i=0,s=0,o=0;o<4;o++)for(var c=24;c>=0;c-=8)i<<=1,i|=e>>>c+o&1,i<<=1,i|=t>>>c+o&1;for(o=4;o<8;o++)for(c=24;c>=0;c-=8)s<<=1,s|=e>>>c+o&1,s<<=1,s|=t>>>c+o&1;r[n+0]=i>>>0,r[n+1]=s>>>0},pc1:function(t,e,r,n){for(var i=0,s=0,o=7;o>=5;o--){for(var c=0;c<=24;c+=8)i<<=1,i|=e>>c+o&1;for(c=0;c<=24;c+=8)i<<=1,i|=t>>c+o&1}for(c=0;c<=24;c+=8)i<<=1,i|=e>>c+o&1;for(o=1;o<=3;o++){for(c=0;c<=24;c+=8)s<<=1,s|=e>>c+o&1;for(c=0;c<=24;c+=8)s<<=1,s|=t>>c+o&1}for(c=0;c<=24;c+=8)s<<=1,s|=t>>c+o&1;r[n+0]=i>>>0,r[n+1]=s>>>0},r28shl:function(t,e){return t<<e&268435455|t>>>28-e},pc2:function(t,e,r,n){for(var i=0,s=0,o=Er.length>>>1,c=0;c<o;c++)i<<=1,i|=t>>>Er[c]&1;for(c=o;c<Er.length;c++)s<<=1,s|=e>>>Er[c]&1;r[n+0]=i>>>0,r[n+1]=s>>>0},expand:function(t,e,r){var n=0,i=0;n=(1&t)<<5|t>>>27;for(var s=23;s>=15;s-=4)n<<=6,n|=t>>>s&63;for(s=11;s>=3;s-=4)i|=t>>>s&63,i<<=6;i|=(31&t)<<1|t>>>31,e[r+0]=n>>>0,e[r+1]=i>>>0},substitute:function(t,e){for(var r=0,n=0;n<4;n++)r<<=4,r|=xr[64*n+(t>>>18-6*n&63)];for(n=0;n<4;n++)r<<=4,r|=xr[256+64*n+(e>>>18-6*n&63)];return r>>>0},permute:function(t){for(var e=0,r=0;r<Nr.length;r++)e<<=1,e|=t>>>Nr[r]&1;return e>>>0},padSplit:function(t,e,r){for(var n=t.toString(2);n.length<e;)n="0"+n;for(var i=[],s=0;s<e;s+=r)i.push(n.slice(s,s+r));return i.join(" ")}},Ur=Cr;function Cr(t,e){if(!t)throw new Error(e||"Assertion failed")}function Or(t){this.options=t,this.type=this.options.type,this.blockSize=8,this._init(),this.buffer=new Array(this.blockSize),this.bufferOff=0}Cr.equal=function(t,e,r){if(t!=e)throw new Error(r||"Assertion failed: "+t+" != "+e)};var Ir=Or;Or.prototype._init=function(){},Or.prototype.update=function(t){return 0===t.length?[]:"decrypt"===this.type?this._updateDecrypt(t):this._updateEncrypt(t)},Or.prototype._buffer=function(t,e){for(var r=Math.min(this.buffer.length-this.bufferOff,t.length-e),n=0;n<r;n++)this.buffer[this.bufferOff+n]=t[e+n];return this.bufferOff+=r,r},Or.prototype._flushBuffer=function(t,e){return this._update(this.buffer,0,t,e),this.bufferOff=0,this.blockSize},Or.prototype._updateEncrypt=function(t){var e=0,r=0,n=new Array(((this.bufferOff+t.length)/this.blockSize|0)*this.blockSize);0!==this.bufferOff&&(e+=this._buffer(t,e),this.bufferOff===this.buffer.length&&(r+=this._flushBuffer(n,r)));for(var i=t.length-(t.length-e)%this.blockSize;e<i;e+=this.blockSize)this._update(t,e,n,r),r+=this.blockSize;for(;e<t.length;e++,this.bufferOff++)this.buffer[this.bufferOff]=t[e];return n},Or.prototype._updateDecrypt=function(t){for(var e=0,r=0,n=Math.ceil((this.bufferOff+t.length)/this.blockSize)-1,i=new Array(n*this.blockSize);n>0;n--)e+=this._buffer(t,e),r+=this._flushBuffer(i,r);return e+=this._buffer(t,e),i},Or.prototype.final=function(t){var e,r;return t&&(e=this.update(t)),r="encrypt"===this.type?this._finalEncrypt():this._finalDecrypt(),e?e.concat(r):r},Or.prototype._pad=function(t,e){if(0===e)return!1;for(;e<t.length;)t[e++]=0;return!0},Or.prototype._finalEncrypt=function(){if(!this._pad(this.buffer,this.bufferOff))return[];var t=new Array(this.blockSize);return this._update(this.buffer,0,t,0),t},Or.prototype._unpad=function(t){return t},Or.prototype._finalDecrypt=function(){Ur.equal(this.bufferOff,this.blockSize,"Not enough data to decrypt");var t=new Array(this.blockSize);return this._flushBuffer(t,0),this._unpad(t)};var Tr="function"==typeof Object.create?function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:function(t,e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t},jr=/%[sdj%]/g;function Dr(t){if(!Fr(t)){for(var e=[],r=0;r<arguments.length;r++)e.push(Mr(arguments[r]));return e.join(" ")}r=1;for(var n=arguments,i=n.length,s=String(t).replace(jr,(function(t){if("%%"===t)return"%";if(r>=i)return t;switch(t){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(e){return"[Circular]"}default:return t}})),o=n[r];r<i;o=n[++r])qr(o)||!Qr(o)?s+=" "+o:s+=" "+Mr(o);return s}var Rr,Pr={};function Mr(t,e){var r={seen:[],stylize:Hr};return arguments.length>=3&&(r.depth=arguments[2]),arguments.length>=4&&(r.colors=arguments[3]),_r(e)?r.showHidden=e:e&&on(r,e),Lr(r.showHidden)&&(r.showHidden=!1),Lr(r.depth)&&(r.depth=2),Lr(r.colors)&&(r.colors=!1),Lr(r.customInspect)&&(r.customInspect=!0),r.colors&&(r.stylize=$r),Jr(r,t,r.depth)}function $r(t,e){var r=Mr.styles[e];return r?"["+Mr.colors[r][0]+"m"+t+"["+Mr.colors[r][1]+"m":t}function Hr(t){return t}function Jr(t,e,r){if(t.customInspect&&e&&tn(e.inspect)&&e.inspect!==Mr&&(!e.constructor||e.constructor.prototype!==e)){var n=e.inspect(r,t);return Fr(n)||(n=Jr(t,n,r)),n}var i=function(t,e){if(Lr(e))return t.stylize("undefined","undefined");if(Fr(e)){var r="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return t.stylize(r,"string")}return zr(e)?t.stylize(""+e,"number"):_r(e)?t.stylize(""+e,"boolean"):qr(e)?t.stylize("null","null"):void 0}(t,e);if(i)return i;var s=Object.keys(e),o=function(t){var e={};return t.forEach((function(t){e[t]=!0})),e}(s);if(t.showHidden&&(s=Object.getOwnPropertyNames(e)),Yr(e)&&(s.indexOf("message")>=0||s.indexOf("description")>=0))return Vr(e);if(0===s.length){if(tn(e))return t.stylize("[Function"+(e.name?": "+e.name:"")+"]","special");if(Zr(e))return t.stylize(RegExp.prototype.toString.call(e),"regexp");if(Xr(e))return t.stylize(Date.prototype.toString.call(e),"date");if(Yr(e))return Vr(e)}var c,a="",u=!1,h=["{","}"];return Wr(e)&&(u=!0,h=["[","]"]),tn(e)&&(a=" [Function"+(e.name?": "+e.name:"")+"]"),Zr(e)&&(a=" "+RegExp.prototype.toString.call(e)),Xr(e)&&(a=" "+Date.prototype.toUTCString.call(e)),Yr(e)&&(a=" "+Vr(e)),0!==s.length||u&&0!=e.length?r<0?Zr(e)?t.stylize(RegExp.prototype.toString.call(e),"regexp"):t.stylize("[Object]","special"):(t.seen.push(e),c=u?function(t,e,r,n,i){for(var s=[],o=0,c=e.length;o<c;++o)cn(e,String(o))?s.push(Gr(t,e,r,n,String(o),!0)):s.push("");return i.forEach((function(i){i.match(/^\d+$/)||s.push(Gr(t,e,r,n,i,!0))})),s}(t,e,r,o,s):s.map((function(n){return Gr(t,e,r,o,n,u)})),t.seen.pop(),function(t,e,r){return t.reduce((function(t,e){return e.indexOf("\n"),t+e.replace(/\u001b\[\d\d?m/g,"").length+1}),0)>60?r[0]+(""===e?"":e+"\n ")+" "+t.join(",\n  ")+" "+r[1]:r[0]+e+" "+t.join(", ")+" "+r[1]}(c,a,h)):h[0]+a+h[1]}function Vr(t){return"["+Error.prototype.toString.call(t)+"]"}function Gr(t,e,r,n,i,s){var o,c,a;if((a=Object.getOwnPropertyDescriptor(e,i)||{value:e[i]}).get?c=t.stylize(a.set?"[Getter/Setter]":"[Getter]","special"):a.set&&(c=t.stylize("[Setter]","special")),cn(n,i)||(o="["+i+"]"),c||(t.seen.indexOf(a.value)<0?(c=qr(r)?Jr(t,a.value,null):Jr(t,a.value,r-1)).indexOf("\n")>-1&&(c=s?c.split("\n").map((function(t){return"  "+t})).join("\n").substr(2):"\n"+c.split("\n").map((function(t){return"   "+t})).join("\n")):c=t.stylize("[Circular]","special")),Lr(o)){if(s&&i.match(/^\d+$/))return c;(o=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(o=o.substr(1,o.length-2),o=t.stylize(o,"name")):(o=o.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),o=t.stylize(o,"string"))}return o+": "+c}function Wr(t){return Array.isArray(t)}function _r(t){return"boolean"==typeof t}function qr(t){return null===t}function zr(t){return"number"==typeof t}function Fr(t){return"string"==typeof t}function Lr(t){return void 0===t}function Zr(t){return Qr(t)&&"[object RegExp]"===en(t)}function Qr(t){return"object"==typeof t&&null!==t}function Xr(t){return Qr(t)&&"[object Date]"===en(t)}function Yr(t){return Qr(t)&&("[object Error]"===en(t)||t instanceof Error)}function tn(t){return"function"==typeof t}function en(t){return Object.prototype.toString.call(t)}function rn(t){return t<10?"0"+t.toString(10):t.toString(10)}Mr.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},Mr.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};var nn=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function sn(){var t=new Date,e=[rn(t.getHours()),rn(t.getMinutes()),rn(t.getSeconds())].join(":");return[t.getDate(),nn[t.getMonth()],e].join(" ")}function on(t,e){if(!e||!Qr(e))return t;for(var r=Object.keys(e),n=r.length;n--;)t[r[n]]=e[r[n]];return t}function cn(t,e){return Object.prototype.hasOwnProperty.call(t,e)}var an={inherits:Tr,_extend:on,log:function(){console.log("%s - %s",sn(),Dr.apply(null,arguments))},isBuffer:function(t){return Buffer.isBuffer(t)},isPrimitive:function(t){return null===t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"symbol"==typeof t||void 0===t},isFunction:tn,isError:Yr,isDate:Xr,isObject:Qr,isRegExp:Zr,isUndefined:Lr,isSymbol:function(t){return"symbol"==typeof t},isString:Fr,isNumber:zr,isNullOrUndefined:function(t){return null==t},isNull:qr,isBoolean:_r,isArray:Wr,inspect:Mr,deprecate:function t(e,r){if(Lr(global.process))return function(){return t(e,r).apply(this,arguments)};var n=!1;return function(){return n||(console.error(r),n=!0),e.apply(this,arguments)}},format:Dr,debuglog:function(t){return Lr(Rr)&&(Rr=""),t=t.toUpperCase(),Pr[t]||(Pr[t]=new RegExp("\\b"+t+"\\b","i").test(Rr)?function(){var e=Dr.apply(null,arguments);console.error("%s %d: %s",t,0,e)}:function(){}),Pr[t]}},un=l((function(t){t.exports="function"==typeof Object.create?function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:function(t,e){if(e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}}})),hn=l((function(t){try{if("function"!=typeof an.inherits)throw"";t.exports=an.inherits}catch(e){t.exports=un}}));function fn(){this.tmp=new Array(2),this.keys=null}function ln(t){Ir.call(this,t);var e=new fn;this._desState=e,this.deriveKeys(e,t.key)}hn(ln,Ir);var yn=ln;ln.create=function(t){return new ln(t)};var dn=[1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1];ln.prototype.deriveKeys=function(t,e){t.keys=new Array(32),Ur.equal(e.length,this.blockSize,"Invalid key length");var r=Kr.readUInt32BE(e,0),n=Kr.readUInt32BE(e,4);Kr.pc1(r,n,t.tmp,0),r=t.tmp[0],n=t.tmp[1];for(var i=0;i<t.keys.length;i+=2){var s=dn[i>>>1];r=Kr.r28shl(r,s),n=Kr.r28shl(n,s),Kr.pc2(r,n,t.keys,i)}},ln.prototype._update=function(t,e,r,n){var i=this._desState,s=Kr.readUInt32BE(t,e),o=Kr.readUInt32BE(t,e+4);Kr.ip(s,o,i.tmp,0),s=i.tmp[0],o=i.tmp[1],"encrypt"===this.type?this._encrypt(i,s,o,i.tmp,0):this._decrypt(i,s,o,i.tmp,0),o=i.tmp[1],Kr.writeUInt32BE(r,s=i.tmp[0],n),Kr.writeUInt32BE(r,o,n+4)},ln.prototype._pad=function(t,e){for(var r=t.length-e,n=e;n<t.length;n++)t[n]=r;return!0},ln.prototype._unpad=function(t){for(var e=t[t.length-1],r=t.length-e;r<t.length;r++)Ur.equal(t[r],e);return t.slice(0,t.length-e)},ln.prototype._encrypt=function(t,e,r,n,i){for(var s=e,o=r,c=0;c<t.keys.length;c+=2){var a=t.keys[c],u=t.keys[c+1];Kr.expand(o,t.tmp,0);var h=Kr.substitute(a^=t.tmp[0],u^=t.tmp[1]),f=o;o=(s^Kr.permute(h))>>>0,s=f}Kr.rip(o,s,n,i)},ln.prototype._decrypt=function(t,e,r,n,i){for(var s=r,o=e,c=t.keys.length-2;c>=0;c-=2){var a=t.keys[c],u=t.keys[c+1];Kr.expand(s,t.tmp,0);var h=Kr.substitute(a^=t.tmp[0],u^=t.tmp[1]),f=s;s=(o^Kr.permute(h))>>>0,o=f}Kr.rip(s,o,n,i)};var wn={};function pn(t){Ur.equal(t.length,8,"Invalid IV length"),this.iv=new Array(8);for(var e=0;e<this.iv.length;e++)this.iv[e]=t[e]}wn._cbcInit=function(){var t=new pn(this.options.iv);this._cbcState=t},wn._update=function(t,e,r,n){var i=this.constructor.super_.prototype,s=this._cbcState.iv;if("encrypt"===this.type){for(var o=0;o<this.blockSize;o++)s[o]^=t[e+o];for(i._update.call(this,s,0,r,n),o=0;o<this.blockSize;o++)s[o]=r[n+o]}else{for(i._update.call(this,t,e,r,n),o=0;o<this.blockSize;o++)r[n+o]^=s[o];for(o=0;o<this.blockSize;o++)s[o]=t[e+o]}};var vn={instantiate:function(t){function e(e){t.call(this,e),this._cbcInit()}hn(e,t);for(var r=Object.keys(wn),n=0;n<r.length;n++){var i=r[n];e.prototype[i]=wn[i]}return e.create=function(t){return new e(t)},e}};function mn(t,e){Ur.equal(e.length,24,"Invalid key length");var r=e.slice(0,8),n=e.slice(8,16),i=e.slice(16,24);this.ciphers="encrypt"===t?[yn.create({type:"encrypt",key:r}),yn.create({type:"decrypt",key:n}),yn.create({type:"encrypt",key:i})]:[yn.create({type:"decrypt",key:i}),yn.create({type:"encrypt",key:n}),yn.create({type:"decrypt",key:r})]}function An(t){Ir.call(this,t);var e=new mn(this.type,this.options.key);this._edeState=e}hn(An,Ir);var gn=An;An.create=function(t){return new An(t)},An.prototype._update=function(t,e,r,n){var i=this._edeState;i.ciphers[0]._update(t,e,r,n),i.ciphers[1]._update(r,n,r,n),i.ciphers[2]._update(r,n,r,n)},An.prototype._pad=yn.prototype._pad,An.prototype._unpad=yn.prototype._unpad;var bn=yn,kn=vn,Sn=gn,Bn={utils:Kr,Cipher:Ir,DES:bn,CBC:kn,EDE:Sn},En=Object.freeze({__proto__:null,default:Bn,__moduleExports:Bn,utils:Kr,Cipher:Ir,DES:bn,CBC:kn,EDE:Sn});class xn extends Ze{constructor(t,e,r,n){super(t,e,"secret",r),this.raw=n}toJSON(){return{kty:"oct",alg:this.getJwkAlgorithm(),k:a.ToBase64Url(this.raw),ext:this.extractable,key_ops:this.usages}}getJwkAlgorithm(){switch(this.algorithm.name.toUpperCase()){case"DES-CBC":return"DES-CBC";case"DES-EDE3-CBC":return"3DES-CBC";default:throw new Xt("Unsupported algorithm name")}}}class Nn{static checkLib(){if(void 0===En)throw new te("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/des.js' script to your project")}static checkCryptoKey(t){if(!(t instanceof xn))throw new TypeError("key: Is not DesCryptoKey")}static generateKey(e,r,n){return f(this,void 0,void 0,(function*(){this.checkLib();const i=t.nativeCrypto.getRandomValues(new Uint8Array(e.length/8));return new xn(e,r,n,i)}))}static exportKey(t,e){return f(this,void 0,void 0,(function*(){switch(this.checkLib(),t){case"jwk":return e.toJSON();case"raw":return e.raw.buffer;default:throw new te("format: Must be 'jwk' or 'raw'")}}))}static importKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){let t;if(this.checkLib(),t=re(e)?a.FromBase64Url(e.k):u.toArrayBuffer(e),"DES-CBC"===r.name&&8!==t.byteLength||"DES-EDE3-CBC"===r.name&&24!==t.byteLength)throw new te("keyData: Is wrong key length");return new xn({name:r.name,length:t.byteLength<<3},n,i,new Uint8Array(t))}))}static encrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,r,!0)}))}static decrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,r,!1)}))}static cipher(t,e,r,n){return f(this,void 0,void 0,(function*(){this.checkLib();const i=n?"encrypt":"decrypt";let s;const o=u.toUint8Array(t.iv);switch(t.name.toUpperCase()){case"DES-CBC":s=kn.instantiate(bn).create({key:e.raw,type:i,iv:o});break;case"DES-EDE3-CBC":s=kn.instantiate(Sn).create({key:e.raw,type:i,iv:o});break;default:throw new te("algorithm: Is not recognized")}const c=s.update(new Uint8Array(r)).concat(s.final());return new Uint8Array(c).buffer}))}}class Kn extends he{constructor(){super(...arguments),this.keySizeBits=64,this.ivSize=8,this.name="DES-CBC"}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Nn.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Nn.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Nn.importKey(t,e,r,n,i)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Nn.encrypt(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Nn.decrypt(t,e,r)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Nn.checkCryptoKey(t)}}class Un extends he{constructor(){super(...arguments),this.keySizeBits=192,this.ivSize=8,this.name="DES-EDE3-CBC"}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Nn.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Nn.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Nn.importKey(t,e,r,n,i)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Nn.encrypt(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Nn.decrypt(t,e,r)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Nn.checkCryptoKey(t)}}let Cn=(()=>{class t extends Ze{constructor(t={name:"HMAC"},e=!1,r=[],n=new Uint8Array(0)){super(t,e,"secret",r),this.kty="oct",this.data=n}get alg(){return"HS"+this.algorithm.hash.name.toUpperCase().replace("SHA-","")}set alg(t){}}return h([Zt({name:"ext",type:Mt.Boolean,optional:!0})],t.prototype,"extractable",void 0),h([Zt({name:"key_ops",type:Mt.String,repeated:!0,optional:!0})],t.prototype,"usages",void 0),h([Zt({name:"k",converter:He})],t.prototype,"data",void 0),h([Zt({type:Mt.String})],t.prototype,"kty",void 0),h([Zt({type:Mt.String})],t.prototype,"alg",null),t})();class On extends ge{onGenerateKey(e,r,n){return f(this,void 0,void 0,(function*(){const i=e.length||this.getDefaultLength(e.hash.name),s=t.nativeCrypto.getRandomValues(new Uint8Array(i>>3));return new Cn(e,r,n,s)}))}onSign(t,r,n){return f(this,void 0,void 0,(function*(){let t;switch(r.algorithm.hash.name.toUpperCase()){case"SHA-1":t=e.HmacSha1;break;case"SHA-256":t=e.HmacSha256;break;case"SHA-512":t=e.HmacSha512;break;default:throw new te("key.algorithm.hash: Is not recognized")}const i=new t(r.data).process(u.toUint8Array(n)).finish().result;return u.toArrayBuffer(i)}))}onVerify(t,e,r,n){return f(this,void 0,void 0,(function*(){const i=yield this.onSign(t,e,n);return a.ToHex(i)===a.ToHex(r)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){let s;switch(t.toLowerCase()){case"jwk":s=Lt.fromJSON(e,{targetSchema:Cn});break;case"raw":if(!u.isBufferSource(e))throw new TypeError("keyData: Is not ArrayBuffer or ArrayBufferView");s=new Cn(r,n,i,u.toUint8Array(e));break;default:throw new te("format: Must be 'jwk' or 'raw'")}return s.algorithm={hash:{name:r.hash.name},name:this.name,length:s.data.length<<3},s.extractable=n,s.usages=i,s}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){switch(t.toLowerCase()){case"jwk":return Ft.toJSON(e);case"raw":return new Uint8Array(e.data).buffer;default:throw new te("format: Must be 'jwk' or 'raw'")}}))}checkCryptoKey(t,e){if(super.checkCryptoKey(t,e),!(t instanceof Cn))throw new TypeError("key: Is not HMAC CryptoKey")}}var In;class Tn extends Ze{constructor(t,e,r,n,i){super(t,e,r,n),In.set(this,void 0),function(t,e,r){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");e.set(t,r)}(this,In,i)}getNative(){return function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)}(this,In)}}In=new WeakMap;let jn=(()=>{class e extends Se{constructor(){super(),this.browserInfo=function(){const t={name:Je.Unknown,version:"0"};if("undefined"==typeof self)return t;const e=self.navigator.userAgent;let r;return(r=/edge\/([\d\.]+)/i.exec(e))?(t.name=Je.Edge,t.version=r[1]):/msie/i.test(e)?(t.name=Je.IE,t.version=/msie ([\d\.]+)/i.exec(e)[1]):/Trident/i.test(e)?(t.name=Je.IE,t.version=/rv:([\d\.]+)/i.exec(e)[1]):/chrome/i.test(e)?(t.name=Je.Chrome,t.version=/chrome\/([\d\.]+)/i.exec(e)[1]):/firefox/i.test(e)?(t.name=Je.Firefox,t.version=/firefox\/([\d\.]+)/i.exec(e)[1]):/mobile/i.test(e)?(t.name=Je.Mobile,t.version=/mobile\/([\w]+)/i.exec(e)[1]):/safari/i.test(e)&&(t.name=Je.Safari,t.version=/version\/([\d\.]+)/i.exec(e)[1]),t}(),this.providers.set(new tr),this.providers.set(new nr),this.providers.set(new er),this.providers.set(new rr),this.providers.set(new ir),this.providers.set(new Kn),this.providers.set(new Un),this.providers.set(new hr),this.providers.set(new ur),this.providers.set(new ar),this.providers.set(new fr),this.providers.set(new Ar),this.providers.set(new pr),this.providers.set(new gr),this.providers.set(new br),this.providers.set(new kr),this.providers.set(new Br),this.providers.set(new On)}static isAnotherKey(t){return"object"==typeof t&&"string"==typeof t.type&&"boolean"==typeof t.extractable&&"object"==typeof t.algorithm&&!(t instanceof Ze)}digest(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("digest",...t)}))}importKey(...t){return f(this,void 0,void 0,(function*(){return this.fixFirefoxEcImportPkcs8(t),this.wrapNative("importKey",...t)}))}exportKey(...t){return f(this,void 0,void 0,(function*(){return(yield this.fixFirefoxEcExportPkcs8(t))||(yield this.wrapNative("exportKey",...t))}))}generateKey(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("generateKey",...t)}))}sign(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("sign",...t)}))}verify(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("verify",...t)}))}encrypt(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("encrypt",...t)}))}decrypt(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("decrypt",...t)}))}wrapKey(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("wrapKey",...t)}))}unwrapKey(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("unwrapKey",...t)}))}deriveBits(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("deriveBits",...t)}))}deriveKey(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("deriveKey",...t)}))}wrapNative(r,...n){const i=t=>super[t];return f(this,void 0,void 0,(function*(){~["generateKey","unwrapKey","deriveKey","importKey"].indexOf(r)&&this.fixAlgorithmName(n);try{if("digest"!==r||!n.some(t=>t instanceof Ze)){const e=this.fixNativeArguments(r,n);Le.info(`Call native '${r}' method`,e);const i=yield t.nativeSubtle[r].apply(t.nativeSubtle,e);return this.fixNativeResult(r,n,i)}}catch(s){Le.warn(`Error on native '${r}' calling. ${s.message}`,s)}if("wrapKey"===r)try{Le.info("Trying to wrap key by using native functions",n);const t=yield this.exportKey(n[0],n[1]),e="jwk"===n[0]?a.FromUtf8String(JSON.stringify(t)):t;return yield this.encrypt(n[3],n[2],e)}catch(s){Le.warn("Cannot wrap key by native functions. "+s.message,s)}if("unwrapKey"===r)try{Le.info("Trying to unwrap key by using native functions",n);const t=yield this.decrypt(n[3],n[2],n[1]),e="jwk"===n[0]?JSON.parse(a.ToUtf8String(t)):t;return yield this.importKey(n[0],e,n[4],n[5],n[6])}catch(s){Le.warn("Cannot unwrap key by native functions. "+s.message,s)}if("deriveKey"===r)try{Le.info("Trying to derive key by using native functions",n);const t=yield this.deriveBits(n[0],n[1],n[2].length);return yield this.importKey("raw",t,n[2],n[3],n[4])}catch(s){Le.warn("Cannot derive key by native functions. "+s.message,s)}if("deriveBits"===r||"deriveKey"===r)for(const t of n)"object"==typeof t&&t.public&&e.isAnotherKey(t.public)&&(t.public=yield this.castKey(t.public));for(let t=0;t<n.length;t++){const r=n[t];e.isAnotherKey(r)&&(n[t]=yield this.castKey(r))}return i(r).apply(this,n)}))}fixNativeArguments(t,e){var r,n,i,s,o,c,h,f;const l=[...e];if("importKey"===t&&(this.browserInfo.name!==Je.IE||"jwk"!==(null===(n=null===(r=l[0])||void 0===r?void 0:r.toLowerCase)||void 0===n?void 0:n.call(r))||u.isBufferSource(l[1])||(l[1]=a.FromUtf8String(JSON.stringify(l[1])))),this.browserInfo.name===Je.IE&&e[1]instanceof Tn)switch(t){case"sign":case"verify":case"encrypt":case"decrypt":l[0]=Object.assign(Object.assign({},this.prepareAlgorithm(l[0])),{hash:null===(o=null===(s=null===(i=l[1])||void 0===i?void 0:i.algorithm)||void 0===s?void 0:s.hash)||void 0===o?void 0:o.name});break;case"wrapKey":case"unwrapKey":l[4]=Object.assign(Object.assign({},this.prepareAlgorithm(l[4])),{hash:null===(f=null===(h=null===(c=l[3])||void 0===c?void 0:c.algorithm)||void 0===h?void 0:h.hash)||void 0===f?void 0:f.name})}for(let a=0;a<l.length;a++){const t=l[a];t instanceof Tn&&(l[a]=t.getNative())}return l}fixNativeResult(t,e,r){var n,i;if(this.browserInfo.name===Je.IE){if("exportKey"===t&&"jwk"===(null===(i=null===(n=e[0])||void 0===n?void 0:n.toLowerCase)||void 0===i?void 0:i.call(n))&&r instanceof ArrayBuffer)return JSON.parse(a.ToUtf8String(r));if("privateKey"in r){const t=["sign","decrypt","unwrapKey","deriveKey","deriveBits"],n=["verify","encrypt","wrapKey"];return{privateKey:this.wrapNativeKey(r.privateKey,e[0],e[1],e[2].filter(e=>t.includes(e))),publicKey:this.wrapNativeKey(r.publicKey,e[0],e[1],e[2].filter(t=>n.includes(t)))}}if("extractable"in r){let n,i;switch(t){case"importKey":n=e[2],i=e[4];break;case"unwrapKey":n=e[4],i=e[6];break;case"generateKey":n=e[0],i=e[2];break;default:throw new te("Cannot wrap native key. Unsupported method in use")}return this.wrapNativeKey(r,n,r.extractable,i)}}return r}wrapNativeKey(t,e,r,n){if(this.browserInfo.name===Je.IE){const i=["RSASSA-PKCS1-v1_5","RSA-PSS","RSA-OAEP","AES-CBC","AES-CTR","AES-KW","HMAC"],s=i.map(t=>t.toLowerCase()).indexOf(t.algorithm.name.toLowerCase());if(-1!==s){const o=this.prepareAlgorithm(e),c=Object.assign(Object.assign({},t.algorithm),{name:i[s]});return Se.isHashedAlgorithm(o)&&(c.hash={name:o.hash.name.toUpperCase()}),Le.info(`Wrapping ${i[s]} crypto key to WrappedNativeCryptoKey`),new Tn(c,r,t.type,n,t)}}return t}castKey(t){return f(this,void 0,void 0,(function*(){if(Le.info("Cast native CryptoKey to linter key.",t),!t.extractable)throw new Error("Cannot cast unextractable crypto key");const e=this.getProvider(t.algorithm.name),r=yield this.exportKey("jwk",t);return e.importKey("jwk",r,t.algorithm,!0,t.usages)}))}fixAlgorithmName(t){if(this.browserInfo.name===Je.Edge)for(let e=0;e<t.length;e++){const r=t[0];if("string"==typeof r){for(const n of this.providers.algorithms)if(n.toLowerCase()===r.toLowerCase()){t[e]=n;break}}else if("object"==typeof r&&"string"==typeof r.name)for(const t of this.providers.algorithms)t.toLowerCase()===r.name.toLowerCase()&&(r.name=t),("string"==typeof r.hash&&t.toLowerCase()===r.hash.toLowerCase()||"object"==typeof r.hash&&"string"==typeof r.hash.name&&t.toLowerCase()===r.hash.name.toLowerCase())&&(r.hash={name:t})}}fixFirefoxEcImportPkcs8(t){const e=this.prepareAlgorithm(t[2]),r=e.name.toUpperCase();if(this.browserInfo.name===Je.Firefox&&"pkcs8"===t[0]&&~["ECDSA","ECDH"].indexOf(r)&&~["P-256","P-384","P-521"].indexOf(e.namedCurve)){if(!u.isBufferSource(t[1]))throw new TypeError("data: Is not ArrayBuffer or ArrayBufferView");const r=u.toArrayBuffer(t[1]),n=Ct.parse(r,Me),i=Ct.parse(n.privateKey,ze),s=Ft.toJSON(i);s.ext=!0,s.key_ops=t[4],s.crv=e.namedCurve,s.kty="EC",t[0]="jwk",t[1]=s}}fixFirefoxEcExportPkcs8(t){return f(this,void 0,void 0,(function*(){try{if(this.browserInfo.name===Je.Firefox&&"pkcs8"===t[0]&&~["ECDSA","ECDH"].indexOf(t[1].algorithm.name)&&~["P-256","P-384","P-521"].indexOf(t[1].algorithm.namedCurve)){const e=yield this.exportKey("jwk",t[1]),r=Lt.fromJSON(e,{targetSchema:ze}),n=new Me;return n.privateKeyAlgorithm.algorithm=wr.ASN_ALGORITHM,n.privateKeyAlgorithm.parameters=Ot.serialize(new Re(yr(t[1].algorithm.namedCurve))),n.privateKey=Ot.serialize(r),Ot.serialize(n)}}catch($n){return Le.error($n),null}}))}}return e.methods=["digest","importKey","exportKey","sign","verify","generateKey","encrypt","decrypt","deriveBits","deriveKey","wrapKey","unwrapKey"],e})();class Dn extends class{}{constructor(){super(...arguments),this.subtle=new jn}get nativeCrypto(){return t.nativeCrypto}getRandomValues(e){return t.nativeCrypto.getRandomValues(e)}}function Rn(t,e){const r=t[e];t[e]=function(){const n=arguments;return new Promise((i,s)=>{const o=r.apply(t,n);o.oncomplete=t=>{i(t.target.result)},o.onerror=()=>{s(`Error on running '${e}' function`)}})}}"undefined"!=typeof self&&self.msCrypto&&(Rn(t.nativeSubtle,"generateKey"),Rn(t.nativeSubtle,"digest"),Rn(t.nativeSubtle,"sign"),Rn(t.nativeSubtle,"verify"),Rn(t.nativeSubtle,"encrypt"),Rn(t.nativeSubtle,"decrypt"),Rn(t.nativeSubtle,"importKey"),Rn(t.nativeSubtle,"exportKey"),Rn(t.nativeSubtle,"wrapKey"),Rn(t.nativeSubtle,"unwrapKey"),Rn(t.nativeSubtle,"deriveKey"),Rn(t.nativeSubtle,"deriveBits")),Math.imul||(Math.imul=function(t,e){const r=65535&t,n=65535&e;return r*n+((t>>>16&65535)*n+r*(e>>>16&65535)<<16>>>0)|0});const Pn=self;t.nativeCrypto&&Object.freeze(t.nativeCrypto.getRandomValues);try{delete self.crypto,Pn.crypto=new Dn,Object.freeze(Pn.crypto)}catch(Hn){Le.error(Hn)}const Mn=Pn.crypto;t.Crypto=Dn,t.CryptoKey=Ze,t.crypto=Mn,t.setCrypto=function(e){t.nativeCrypto=e,t.nativeSubtle=e.subtle}}({},self.asmCrypto,self.elliptic);