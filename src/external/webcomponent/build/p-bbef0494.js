var t=function(t,e,r,i){function n(t){return"undefined"!=typeof Buffer&&Buffer.isBuffer(t)?new Uint8Array(t):ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t)}r=r&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r,i=i&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i;class s{static ToString(t,e="utf8"){const r=n(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){const e=n(t);if("undefined"!=typeof btoa){const t=this.ToString(e,"binary");return btoa(t)}return Buffer.from(e).toString("base64")}static FromBase64(t){return t=t.replace(/\n/g,"").replace(/\r/g,"").replace(/\t/g,"").replace(/\s/g,""),"undefined"!=typeof atob?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(t){return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t){const e=unescape(encodeURIComponent(t)),r=new Uint8Array(e.length);for(let i=0;i<e.length;i++)r[i]=e.charCodeAt(i);return r.buffer}static ToUtf8String(t){const e=n(t),r=String.fromCharCode.apply(null,e);return decodeURIComponent(escape(r))}static FromBinary(t){const e=t.length,r=new Uint8Array(e);for(let i=0;i<e;i++)r[i]=t.charCodeAt(i);return r.buffer}static ToBinary(t){const e=n(t);let r="";const i=e.length;for(let n=0;n<i;n++)r+=String.fromCharCode(e[n]);return r}static ToHex(t){const e=n(t),r=[],i=e.length;for(let n=0;n<i;n++){const t=e[n].toString(16);r.push(1===t.length?"0"+t:t)}return r.join("")}static FromHex(t){const e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2){const i=t.slice(r,r+2);e[r/2]=parseInt(i,16)}return e.buffer}static Base64Padding(t){const e=4-t.length%4;if(e<4)for(let r=0;r<e;r++)t+="=";return t}}class o{static toArrayBuffer(t){const e=this.toUint8Array(t);return e.byteOffset||e.length?e.buffer.slice(e.byteOffset,e.byteOffset+e.length):e.buffer}static toUint8Array(t){if("undefined"!=typeof Buffer&&Buffer.isBuffer(t))return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);if(t instanceof ArrayBuffer)return new Uint8Array(t);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return ArrayBuffer.isView(t)||t instanceof ArrayBuffer}}function a(t){const e=arguments[0];for(let r=1;r<arguments.length;r++){const t=arguments[r];for(const r in t)e[r]=t[r]}return e}function c(...t){const e=t.map(t=>t.byteLength).reduce((t,e)=>t+e),r=new Uint8Array(e);let i=0;return t.map(t=>new Uint8Array(t)).forEach(t=>{for(const e of t)r[i++]=e}),r.buffer}function u(t,e){if(!t||!e)return!1;if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),i=new Uint8Array(e);for(let n=0;n<t.byteLength;n++)if(r[n]!==i[n])return!1;return!0}
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */function h(t,e,r,i){var n,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,r,i);else for(var a=t.length-1;a>=0;a--)(n=t[a])&&(o=(s<3?n(o):s>3?n(e,r,o):n(e,r))||o);return s>3&&o&&Object.defineProperty(e,r,o),o}class f{static async set(t){return new Uint8Array(t)}static async get(t){return new Uint8Array(t).buffer}}function l(t){return r=>{const i=r;i.localName=t.name||i.name||i.toString().match(/^function\s*([^\s(]+)/)[1],i.items=i.items||{},i.target=r,i.items=a({},i.items);const n=new e.Type(i.localName);for(const t in i.items){const r=i.items[t];let s=void 0;r.repeated?s="repeated":r.required&&(s="required"),n.add(new e.Field(r.name,r.id,r.type,s))}i.protobuf=n}}function d(t){return(e,r)=>{const i=e.constructor,n=r;i.items=i.items||{},i.target!==i&&(i.items=a({},i.items),i.target=i),i.items[n]={id:t.id,type:t.type||"bytes",defaultValue:t.defaultValue,converter:t.converter||null,parser:t.parser||null},t.name=t.name||n,i.items[n].name=t.name,i.items[n].required=t.required||!1,i.items[n].repeated=t.repeated||!1,function(t,e,r){const i="_"+e,n={set:function(t){this[i]!==t&&(this.raw=null,this[i]=t)},get:function(){if(void 0===this[i]){let t=r.defaultValue;r.parser&&!r.repeated&&(t=new r.parser),this[i]=t}return this[i]},enumerable:!0};Object.defineProperty(t,i,{writable:!0,enumerable:!1}),Object.defineProperty(t,e,n)}(e,n,i.items[n])}}class y{static async importProto(t){const e=new this;return await e.importProto(t),e}isEmpty(){return void 0===this.raw}hasChanged(){if(null===this.raw)return!0;const t=this.constructor,e=this;for(const r in t.items){const i=t.items[r];if(i.repeated){if(i.parser)return e[r].some(t=>t.hasChanged())}else if(i.parser&&e[r]&&e[r].hasChanged())return!0}return!1}async importProto(t){const e=this.constructor,r=this;let i,n;n=t instanceof y?await t.exportProto():t;try{i=e.protobuf.decode(new Uint8Array(n))}catch(s){throw new Error(`Error: Cannot decode message for ${e.localName}.\n$ProtobufError: ${s.message}`)}for(const o in e.items){const t=e.items[o];let n=i[t.name];ArrayBuffer.isView(n)&&(n=new Uint8Array(n)),Array.isArray(n)||(t.repeated?r[o]=n=[]:n=[n]),t.repeated&&!r[o]&&(r[o]=[]);for(const e of n)t.repeated?r[o].push(await this.importItem(t,e)):r[o]=await this.importItem(t,e)}this.raw=n}async exportProto(){if(!this.hasChanged())return this.raw;const t=this.constructor,e=this,r={};for(const i in t.items){const n=t.items[i];let s=e[i];Array.isArray(s)||(s=void 0===s?[]:[s]);for(const t of s){const e=await this.exportItem(n,t);n.repeated?(r[n.name]||(r[n.name]=[]),r[n.name].push(e)):r[n.name]=e}}return this.raw=new Uint8Array(t.protobuf.encode(r).finish()).buffer,this.raw}async exportItem(t,e){const r=this.constructor;let i;if(t.parser){const n=e,s=await n.exportProto();if(t.required&&!s)throw new Error(`Error: Paramter '${t.name}' is required in '${r.localName}' protobuf message.`);s&&(i=new Uint8Array(s))}else{if(t.required&&void 0===e)throw new Error(`Error: Paramter '${t.name}' is required in '${r.localName}' protobuf message.`);t.converter?e&&(i=await t.converter.set(e)):(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),i=e)}return i}async importItem(t,e){const r=this.constructor;let i;if(t.parser){const n=t.parser;if(e&&e.byteLength)i=await n.importProto(new Uint8Array(e).buffer);else if(t.required)throw new Error(`Error: Parameter '${t.name}' is required in '${r.localName}' protobuf message.`)}else if(t.converter){if(e&&e.byteLength)i=await t.converter.get(e);else if(t.required)throw new Error(`Error: Parameter '${t.name}' is required in '${r.localName}' protobuf message.`)}else i=e;return i}}function w(){}function v(){v.init.call(this)}function p(t){return void 0===t._maxListeners?v.defaultMaxListeners:t._maxListeners}function g(t,e,r){if(e)t.call(r);else for(var i=t.length,n=x(t,i),s=0;s<i;++s)n[s].call(r)}function m(t,e,r,i){if(e)t.call(r,i);else for(var n=t.length,s=x(t,n),o=0;o<n;++o)s[o].call(r,i)}function A(t,e,r,i,n){if(e)t.call(r,i,n);else for(var s=t.length,o=x(t,s),a=0;a<s;++a)o[a].call(r,i,n)}function b(t,e,r,i,n,s){if(e)t.call(r,i,n,s);else for(var o=t.length,a=x(t,o),c=0;c<o;++c)a[c].call(r,i,n,s)}function B(t,e,r,i){if(e)t.apply(r,i);else for(var n=t.length,s=x(t,n),o=0;o<n;++o)s[o].apply(r,i)}function S(t,e,r,i){var n,s,o,a;if("function"!=typeof r)throw new TypeError('"listener" argument must be a function');if((s=t._events)?(s.newListener&&(t.emit("newListener",e,r.listener?r.listener:r),s=t._events),o=s[e]):(s=t._events=new w,t._eventsCount=0),o){if("function"==typeof o?o=s[e]=i?[r,o]:[o,r]:i?o.unshift(r):o.push(r),!o.warned&&(n=p(t))&&n>0&&o.length>n){o.warned=!0;var c=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+e+" listeners added. Use emitter.setMaxListeners() to increase limit");c.name="MaxListenersExceededWarning",c.emitter=t,c.type=e,c.count=o.length,a=c,"function"==typeof console.warn?console.warn(a):console.log(a)}}else o=s[e]=r,++t._eventsCount;return t}function k(t,e,r){var i=!1;function n(){t.removeListener(e,n),i||(i=!0,r.apply(t,arguments))}return n.listener=r,n}function E(t){var e=this._events;if(e){var r=e[t];if("function"==typeof r)return 1;if(r)return r.length}return 0}function x(t,e){for(var r=new Array(e);e--;)r[e]=t[e];return r}w.prototype=Object.create(null),v.EventEmitter=v,v.usingDomains=!1,v.prototype.domain=void 0,v.prototype._events=void 0,v.prototype._maxListeners=void 0,v.defaultMaxListeners=10,v.init=function(){this.domain=null,this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=new w,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},v.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||isNaN(t))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=t,this},v.prototype.getMaxListeners=function(){return p(this)},v.prototype.emit=function(t){var e,r,i,n,s,o,a,c="error"===t;if(o=this._events)c=c&&null==o.error;else if(!c)return!1;if(a=this.domain,c){if(e=arguments[1],!a){if(e instanceof Error)throw e;var u=new Error('Uncaught, unspecified "error" event. ('+e+")");throw u.context=e,u}return e||(e=new Error('Uncaught, unspecified "error" event')),e.domainEmitter=this,e.domain=a,e.domainThrown=!1,a.emit("error",e),!1}if(!(r=o[t]))return!1;var h="function"==typeof r;switch(i=arguments.length){case 1:g(r,h,this);break;case 2:m(r,h,this,arguments[1]);break;case 3:A(r,h,this,arguments[1],arguments[2]);break;case 4:b(r,h,this,arguments[1],arguments[2],arguments[3]);break;default:for(n=new Array(i-1),s=1;s<i;s++)n[s-1]=arguments[s];B(r,h,this,n)}return!0},v.prototype.on=v.prototype.addListener=function(t,e){return S(this,t,e,!1)},v.prototype.prependListener=function(t,e){return S(this,t,e,!0)},v.prototype.once=function(t,e){if("function"!=typeof e)throw new TypeError('"listener" argument must be a function');return this.on(t,k(this,t,e)),this},v.prototype.prependOnceListener=function(t,e){if("function"!=typeof e)throw new TypeError('"listener" argument must be a function');return this.prependListener(t,k(this,t,e)),this},v.prototype.removeListener=function(t,e){var r,i,n,s,o;if("function"!=typeof e)throw new TypeError('"listener" argument must be a function');if(!(i=this._events))return this;if(!(r=i[t]))return this;if(r===e||r.listener&&r.listener===e)0==--this._eventsCount?this._events=new w:(delete i[t],i.removeListener&&this.emit("removeListener",t,r.listener||e));else if("function"!=typeof r){for(n=-1,s=r.length;s-- >0;)if(r[s]===e||r[s].listener&&r[s].listener===e){o=r[s].listener,n=s;break}if(n<0)return this;if(1===r.length){if(r[0]=void 0,0==--this._eventsCount)return this._events=new w,this;delete i[t]}else!function(t,e){for(var r=e,i=r+1,n=t.length;i<n;r+=1,i+=1)t[r]=t[i];t.pop()}(r,n);i.removeListener&&this.emit("removeListener",t,o||e)}return this},v.prototype.removeAllListeners=function(t){var e,r;if(!(r=this._events))return this;if(!r.removeListener)return 0===arguments.length?(this._events=new w,this._eventsCount=0):r[t]&&(0==--this._eventsCount?this._events=new w:delete r[t]),this;if(0===arguments.length){for(var i,n=Object.keys(r),s=0;s<n.length;++s)"removeListener"!==(i=n[s])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=new w,this._eventsCount=0,this}if("function"==typeof(e=r[t]))this.removeListener(t,e);else if(e)do{this.removeListener(t,e[e.length-1])}while(e[0]);return this},v.prototype.listeners=function(t){var e,r=this._events;return r&&(e=r[t])?"function"==typeof e?[e.listener||e]:function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(e):[]},v.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):E.call(t,e)},v.prototype.listenerCount=E,v.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};const N=s.FromBinary("InfoText"),U=s.FromBinary("InfoRatchet"),C=s.FromBinary("InfoMessageKeys");let I=null;function O(){if(!I)throw new Error("WebCrypto engine is empty. Use setEngine to resolve it.");return I}"undefined"!=typeof self&&(I={crypto:self.crypto,name:"WebCrypto"});let q=(()=>{class t{static async generateKeyPair(t,e){const r=t,i="ECDSA"===t?["sign","verify"]:["deriveKey","deriveBits"],n=await O().crypto.subtle.generateKey({name:r,namedCurve:this.NAMED_CURVE},e,i),s=await K.create(n.publicKey);return{privateKey:n.privateKey,publicKey:s}}static deriveBytes(t,e){return O().crypto.subtle.deriveBits({name:"ECDH",public:e.key},t,256)}static verify(t,e,r){return O().crypto.subtle.verify({name:"ECDSA",hash:this.DIGEST_ALGORITHM},t.key,r,e)}static async sign(t,e){return O().crypto.subtle.sign({name:"ECDSA",hash:this.DIGEST_ALGORITHM},t,e)}static async ecKeyPairToJson(t){return{privateKey:t.privateKey,publicKey:t.publicKey.key,thumbprint:await t.publicKey.thumbprint()}}static async ecKeyPairFromJson(t){return{privateKey:t.privateKey,publicKey:await K.create(t.publicKey)}}}return t.NAMED_CURVE="P-256",t.DIGEST_ALGORITHM="SHA-512",t})();const R={name:"AES-CBC",length:256};class T{static randomBytes(t){const e=new Uint8Array(t);return O().crypto.getRandomValues(e),e.buffer}static digest(t,e){return O().crypto.subtle.digest(t,e)}static encrypt(t,e,r){return O().crypto.subtle.encrypt({name:"AES-CBC",iv:new Uint8Array(r)},t,e)}static decrypt(t,e,r){return O().crypto.subtle.decrypt({name:"AES-CBC",iv:new Uint8Array(r)},t,e)}static importHMAC(t){return O().crypto.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign","verify"])}static importAES(t){return O().crypto.subtle.importKey("raw",t,R,!1,["encrypt","decrypt"])}static async sign(t,e){return await O().crypto.subtle.sign({name:"HMAC",hash:"SHA-256"},t,e)}static async HKDF(t,e=1,r,i=new ArrayBuffer(0)){r||(r=await this.importHMAC(new Uint8Array(32).buffer));const n=await this.sign(r,t),s=await this.importHMAC(n),o=[new ArrayBuffer(0)];for(let a=0;a<e;a++)o[a+1]=await this.sign(s,c(o[a],i,new Uint8Array([a+1]).buffer));return o.slice(1)}}class K{static async create(t){const e=new this,r=t.algorithm.name.toUpperCase();if("ECDH"!==r&&"ECDSA"!==r)throw new Error("Error: Unsupported asymmetric key algorithm.");if("public"!==t.type)throw new Error("Error: Expected key type to be public but it was not.");e.key=t;const i=await O().crypto.subtle.exportKey("jwk",t);if(!i.x||!i.y)throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const n=s.FromBase64Url(i.x),o=s.FromBase64Url(i.y),a=s.ToBinary(n)+s.ToBinary(o);return e.serialized=s.FromBinary(a),e.id=await e.thumbprint(),e}static async importKey(t,e){const r=s.ToBase64Url(t.slice(0,32)),i=s.ToBase64Url(t.slice(32)),n={crv:q.NAMED_CURVE,kty:"EC",x:r,y:i},o="ECDSA"===e?["verify"]:[],a=await O().crypto.subtle.importKey("jwk",n,{name:e,namedCurve:q.NAMED_CURVE},!0,o);return await K.create(a)}serialize(){return this.serialized}async thumbprint(){const t=await this.serialize(),e=await T.digest("SHA-256",t);return s.ToHex(e)}async isEqual(t){return!!(t&&t instanceof K)&&u(this.serialized,t.serialized)}}class D{constructor(t,e,r){this.id=t,this.signingKey=e,this.exchangeKey=r,this.preKeys=[],this.signedPreKeys=[]}static async fromJSON(t){const e=await q.ecKeyPairFromJson(t.signingKey),r=await q.ecKeyPairFromJson(t.exchangeKey),i=new this(t.id,e,r);return i.createdAt=new Date(t.createdAt),await i.fromJSON(t),i}static async create(t,e=0,r=0,i=!1){const n=await q.generateKeyPair("ECDSA",i),s=await q.generateKeyPair("ECDH",i),o=new D(t,n,s);o.createdAt=new Date;for(let a=0;a<r;a++)o.preKeys.push(await q.generateKeyPair("ECDH",i));for(let a=0;a<e;a++)o.signedPreKeys.push(await q.generateKeyPair("ECDH",i));return o}async toJSON(){const t=[],e=[];for(const r of this.preKeys)t.push(await q.ecKeyPairToJson(r));for(const r of this.signedPreKeys)e.push(await q.ecKeyPairToJson(r));return{createdAt:this.createdAt.toISOString(),exchangeKey:await q.ecKeyPairToJson(this.exchangeKey),id:this.id,preKeys:t,signedPreKeys:e,signingKey:await q.ecKeyPairToJson(this.signingKey)}}async fromJSON(t){this.id=t.id,this.signingKey=await q.ecKeyPairFromJson(t.signingKey),this.exchangeKey=await q.ecKeyPairFromJson(t.exchangeKey),this.preKeys=[];for(const e of t.preKeys)this.preKeys.push(await q.ecKeyPairFromJson(e));this.signedPreKeys=[];for(const e of t.signedPreKeys)this.signedPreKeys.push(await q.ecKeyPairFromJson(e))}}class j{static fill(t){const e=new j;return e.fill(t),e}static async fromJSON(t){const e=new this;return await e.fromJSON(t),e}fill(t){this.signingKey=t.signingKey,this.exchangeKey=t.exchangeKey,this.signature=t.signature,this.createdAt=t.createdAt}verify(){return q.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async toJSON(){return{createdAt:this.createdAt.toISOString(),exchangeKey:await this.exchangeKey.key,id:this.id,signature:this.signature,signingKey:await this.signingKey.key,thumbprint:await this.signingKey.thumbprint()}}async fromJSON(t){if(this.id=t.id,this.signature=t.signature,this.signingKey=await K.create(t.signingKey),this.exchangeKey=await K.create(t.exchangeKey),this.createdAt=new Date(t.createdAt),!(await this.verify()))throw new Error("Error: Wrong signature for RemoteIdentity")}}let P=(()=>{let t=class extends y{};return h([d({id:0,type:"uint32",defaultValue:1})],t.prototype,"version",void 0),t=h([l({name:"Base"})],t),t})();class ${static async set(t){return new Uint8Array(t.serialize())}static async get(t){return K.importKey(t.buffer,"ECDSA")}}class J{static async set(t){return new Uint8Array(t.serialize())}static async get(t){return K.importKey(t.buffer,"ECDH")}}class V{static async set(t){return new Uint8Array(s.FromString(t.toISOString()))}static async get(t){return new Date(s.ToString(t))}}let M=(()=>{var t;let e=t=class extends P{static async fill(e){const r=new t;return await r.fill(e),r}async sign(t){this.signature=await q.sign(t,this.exchangeKey.serialize())}async verify(){return await q.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async fill(t){this.signingKey=t.signingKey.publicKey,this.exchangeKey=t.exchangeKey.publicKey,this.createdAt=t.createdAt,await this.sign(t.signingKey.privateKey)}};return h([d({id:1,converter:$})],e.prototype,"signingKey",void 0),h([d({id:2,converter:J})],e.prototype,"exchangeKey",void 0),h([d({id:3})],e.prototype,"signature",void 0),h([d({id:4,converter:V})],e.prototype,"createdAt",void 0),e=t=h([l({name:"Identity"})],e),e})(),_=(()=>{let t=class extends P{};return h([d({id:1,converter:J,required:!0})],t.prototype,"senderRatchetKey",void 0),h([d({id:2,type:"uint32",required:!0})],t.prototype,"counter",void 0),h([d({id:3,type:"uint32",required:!0})],t.prototype,"previousCounter",void 0),h([d({id:4,converter:f,required:!0})],t.prototype,"cipherText",void 0),t=h([l({name:"Message"})],t),t})(),H=(()=>{let t=class extends P{async sign(t){this.signature=await this.signHMAC(t)}async verify(t){return u(await this.signHMAC(t),this.signature)}async getSignedRaw(){return c(this.receiverKey.serialize(),this.senderKey.serialize(),await this.message.exportProto())}async signHMAC(t){const e=await this.getSignedRaw();return await T.sign(t,e)}};return h([d({id:1,converter:$,required:!0})],t.prototype,"senderKey",void 0),h([d({id:2,parser:_,required:!0})],t.prototype,"message",void 0),h([d({id:3,required:!0})],t.prototype,"signature",void 0),t=h([l({name:"MessageSigned"})],t),t})(),W=(()=>{let t=class extends P{};return h([d({id:1,type:"uint32",required:!0})],t.prototype,"registrationId",void 0),h([d({id:2,type:"uint32"})],t.prototype,"preKeyId",void 0),h([d({id:3,type:"uint32",required:!0})],t.prototype,"preKeySignedId",void 0),h([d({id:4,converter:J,required:!0})],t.prototype,"baseKey",void 0),h([d({id:5,parser:M,required:!0})],t.prototype,"identity",void 0),h([d({id:6,parser:H,required:!0})],t.prototype,"signedMessage",void 0),t=h([l({name:"PreKeyMessage"})],t),t})(),G=(()=>{let t=class extends P{};return h([d({id:1,type:"uint32",required:!0})],t.prototype,"id",void 0),h([d({id:2,converter:J,required:!0})],t.prototype,"key",void 0),t=h([l({name:"PreKey"})],t),t})(),L=(()=>{let t=class extends G{async sign(t){this.signature=await q.sign(t,this.key.serialize())}verify(t){return q.verify(t,this.key.serialize(),this.signature)}};return h([d({id:3,converter:f,required:!0})],t.prototype,"signature",void 0),t=h([l({name:"PreKeySigned"})],t),t})(),z=(()=>{let t=class extends P{};return h([d({id:1,type:"uint32",required:!0})],t.prototype,"registrationId",void 0),h([d({id:2,parser:M,required:!0})],t.prototype,"identity",void 0),h([d({id:3,parser:G})],t.prototype,"preKey",void 0),h([d({id:4,parser:L,required:!0})],t.prototype,"preKeySigned",void 0),t=h([l({name:"PreKeyBundle"})],t),t})();const F=new Uint8Array([1]).buffer,Z=new Uint8Array([2]).buffer;class X{constructor(t){this.counter=0,this.rootKey=t}static async fromJSON(t){const e=new this(t.rootKey);return e.fromJSON(t),e}async toJSON(){return{counter:this.counter,rootKey:this.rootKey}}async fromJSON(t){this.counter=t.counter,this.rootKey=t.rootKey}async calculateKey(t){const e=await T.sign(t,F),r=await T.sign(t,Z);return{cipher:e,rootKey:await T.importHMAC(r)}}async click(){const t=this.rootKey,e=await this.calculateKey(t);return this.rootKey=e.rootKey,this.counter++,e.cipher}}class Q extends X{async encrypt(t){const e=await this.click(),r=await T.HKDF(e,3,void 0,C),i=await T.importAES(r[0]),n=await T.importHMAC(r[1]),s=r[2].slice(0,16);return{cipherText:await T.encrypt(i,t,s),hmacKey:n}}}class Y extends X{constructor(){super(...arguments),this.keys=[]}async toJSON(){const t=await super.toJSON();return t.keys=this.keys,t}async fromJSON(t){await super.fromJSON(t),this.keys=t.keys}async decrypt(t,e){const r=await this.getKey(e),i=await T.HKDF(r,3,void 0,C),n=await T.importAES(i[0]),s=await T.importHMAC(i[1]),o=i[2].slice(0,16);return{cipherText:await T.decrypt(n,t,o),hmacKey:s}}async getKey(t){for(;this.counter<=t;){const t=await this.click();this.keys.push(t)}return this.keys[t]}}class tt extends v{constructor(t={}){super(),this.options=t,this.counter=0,this.currentStep=new et,this.steps=new rt(20),this.promises={}}static async create(t,e,r={}){let i;const n=new tt(r);if(e instanceof z){if(!(await e.identity.verify()))throw new Error("Error: Remote client's identity key is invalid.");if(!(await e.preKeySigned.verify(e.identity.signingKey)))throw new Error("Error: Remote client's signed prekey is invalid.");n.currentRatchetKey=await n.generateRatchetKey(),n.currentStep.remoteRatchetKey=e.preKeySigned.key,n.remoteIdentity=j.fill(e.identity),n.remoteIdentity.id=e.registrationId,n.remotePreKeyId=e.preKey.id,n.remotePreKeySignedId=e.preKeySigned.id,i=await async function(t,e,r,i,n){const s=await q.deriveBytes(t.exchangeKey.privateKey,i),o=await q.deriveBytes(e.privateKey,r),a=await q.deriveBytes(e.privateKey,i);let u=new ArrayBuffer(0);n&&(u=await q.deriveBytes(e.privateKey,n));const h=new Uint8Array(32);for(let c=0;c<h.length;c++)h[c]=255;const f=c(h.buffer,s,o,a,u),l=await T.HKDF(f,1,void 0,N);return await T.importHMAC(l[0])}(t,n.currentRatchetKey,e.identity.exchangeKey,e.preKeySigned.key,e.preKey.key)}else{if(!(await e.identity.verify()))throw new Error("Error: Remote client's identity key is invalid.");const r=t.signedPreKeys[e.preKeySignedId];if(!r)throw new Error(`Error: PreKey with id ${e.preKeySignedId} not found`);let s;void 0!==e.preKeyId&&(s=t.preKeys[e.preKeyId]),n.remoteIdentity=j.fill(e.identity),n.currentRatchetKey=r,i=await async function(t,e,r,i,n){const s=await q.deriveBytes(e.privateKey,r),o=await q.deriveBytes(t.exchangeKey.privateKey,i),a=await q.deriveBytes(e.privateKey,i);let u=new ArrayBuffer(0);n&&(u=await q.deriveBytes(n,i));const h=new Uint8Array(32);for(let c=0;c<h.length;c++)h[c]=255;const f=c(h.buffer,s,o,a,u),l=await T.HKDF(f,1,void 0,N);return await T.importHMAC(l[0])}(t,n.currentRatchetKey,e.identity.exchangeKey,e.signedMessage.message.senderRatchetKey,s&&s.privateKey)}return n.identity=t,n.id=t.id,n.rootKey=i,n}static async fromJSON(t,e,r){const i=new tt;return i.identity=t,i.remoteIdentity=e,await i.fromJSON(r),i}on(t,e){return super.on(t,e)}once(t,e){return super.once(t,e)}async decrypt(t){return this.queuePromise("encrypt",async()=>{const e=t.message.senderRatchetKey,r=t.message;if(t.message.previousCounter<this.counter-20)throw new Error("Error: Too old message");let i=this.steps.getStep(e);if(!i){const t=new et;t.remoteRatchetKey=e,this.steps.push(t),this.currentStep=t,i=t}i.receivingChain||(i.receivingChain=await this.createChain(this.currentRatchetKey.privateKey,e,Y));const n=await i.receivingChain.decrypt(r.cipherText,r.counter);if(this.update(),t.senderKey=this.remoteIdentity.signingKey,t.receiverKey=this.identity.signingKey.publicKey,!(await t.verify(n.hmacKey)))throw new Error("Error: The Message did not successfully verify!");return n.cipherText})}async encrypt(t){return this.queuePromise("encrypt",async()=>{if(this.currentStep.receivingChain&&!this.currentStep.sendingChain&&(this.counter++,this.currentRatchetKey=await this.generateRatchetKey()),!this.currentStep.sendingChain){if(!this.currentStep.remoteRatchetKey)throw new Error("currentStep has empty remoteRatchetKey");this.currentStep.sendingChain=await this.createChain(this.currentRatchetKey.privateKey,this.currentStep.remoteRatchetKey,Q)}const e=await this.currentStep.sendingChain.encrypt(t);let r;this.update(),0!==this.steps.length||this.currentStep.receivingChain||1!==this.currentStep.sendingChain.counter||(r=new W,r.registrationId=this.identity.id,r.preKeyId=this.remotePreKeyId,r.preKeySignedId=this.remotePreKeySignedId,r.baseKey=this.currentRatchetKey.publicKey,await r.identity.fill(this.identity));const i=new H;return i.receiverKey=this.remoteIdentity.signingKey,i.senderKey=this.identity.signingKey.publicKey,i.message.cipherText=e.cipherText,i.message.counter=this.currentStep.sendingChain.counter-1,i.message.previousCounter=this.counter,i.message.senderRatchetKey=this.currentRatchetKey.publicKey,await i.sign(e.hmacKey),r?(r.signedMessage=i,r):i})}async hasRatchetKey(t){let e;e=t instanceof K?t:await K.create(t);for(const r of this.steps.items)if(await r.remoteRatchetKey.isEqual(e))return!0;return!1}async toJSON(){return{counter:this.counter,ratchetKey:await q.ecKeyPairToJson(this.currentRatchetKey),remoteIdentity:await this.remoteIdentity.signingKey.thumbprint(),rootKey:this.rootKey,steps:await this.steps.toJSON()}}async fromJSON(t){this.currentRatchetKey=await q.ecKeyPairFromJson(t.ratchetKey),this.counter=t.counter,this.rootKey=t.rootKey;for(const e of t.steps)this.currentStep=await et.fromJSON(e),this.steps.push(this.currentStep)}update(){this.emit("update")}generateRatchetKey(){return q.generateKeyPair("ECDH",!!this.options.exportableKeys)}async createChain(t,e,r){const i=await q.deriveBytes(t,e),n=await T.HKDF(i,2,this.rootKey,U),s=await T.importHMAC(n[0]),o=new r(await T.importHMAC(n[1]));return this.rootKey=s,o}queuePromise(t,e){const r=this.promises[t]||Promise.resolve(),i=this.promises[t]=r.then(e,e);return i.then(()=>{this.promises[t]===i&&delete this.promises[t]}),i}}class et{static async fromJSON(t){const e=new this;return await e.fromJSON(t),e}async toJSON(){const t={};return this.remoteRatchetKey&&(t.remoteRatchetKey=this.remoteRatchetKey.key),this.sendingChain&&(t.sendingChain=await this.sendingChain.toJSON()),this.receivingChain&&(t.receivingChain=await this.receivingChain.toJSON()),t}async fromJSON(t){t.remoteRatchetKey&&(this.remoteRatchetKey=await K.create(t.remoteRatchetKey)),t.sendingChain&&(this.sendingChain=await Q.fromJSON(t.sendingChain)),t.receivingChain&&(this.receivingChain=await Y.fromJSON(t.receivingChain))}}class rt extends class{constructor(t=20){this.items=[],this.maxSize=t}get length(){return this.items.length}get latest(){return this.items[this.length-1]}push(t){this.length===this.maxSize&&(this.items=this.items.slice(1)),this.items.push(t)}async toJSON(){const t=[];for(const e of this.items)t.push(await e.toJSON());return t}async fromJSON(t){this.items=t}}{getStep(t){let e;return this.items.some(r=>(r.remoteRatchetKey.id===t.id&&(e=r),!!e)),e}}
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */function it(t,e,r,i){var n,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,r,i);else for(var a=t.length-1;a>=0;a--)(n=t[a])&&(o=(s<3?n(o):s>3?n(e,r,o):n(e,r))||o);return s>3&&o&&Object.defineProperty(e,r,o),o}function nt(t,e,r,i){return new(r||(r=Promise))((function(n,s){function o(t){try{c(i.next(t))}catch(e){s(e)}}function a(t){try{c(i.throw(t))}catch(e){s(e)}}function c(t){var e;t.done?n(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(o,a)}c((i=i.apply(t,e||[])).next())}))}class st{static set(t){return nt(this,void 0,void 0,(function*(){return new Uint8Array(s.FromUtf8String(t.toISOString()))}))}static get(t){return nt(this,void 0,void 0,(function*(){return new Date(s.ToUtf8String(t))}))}}class ot{static set(t){return nt(this,void 0,void 0,(function*(){return new Uint8Array(s.FromHex(t))}))}static get(t){return nt(this,void 0,void 0,(function*(){return s.ToHex(t)}))}}let at=(()=>{var t;let e=t=class extends y{constructor(){super(...arguments),this.version=0}};return e.INDEX=1,it([d({id:t.INDEX++,type:"uint32",required:!0,defaultValue:1})],e.prototype,"version",void 0),e=t=it([l({name:"BaseMessage"})],e),e})(),ct=(()=>{var t;let e=t=class extends at{constructor(){super(),this.actionId="",this.action=this.constructor.ACTION}};return e.INDEX=at.INDEX,e.ACTION="action",it([d({id:t.INDEX++,type:"string",required:!0})],e.prototype,"action",void 0),it([d({id:t.INDEX++,type:"string",required:!1})],e.prototype,"actionId",void 0),e=t=it([l({name:"Action"})],e),e})(),ut=(()=>{var t;let e=t=class extends at{constructor(){super(...arguments),this.name=""}toAlgorithm(){return{name:this.name}}fromAlgorithm(t){this.name=t.name}};return e.INDEX=at.INDEX,it([d({id:t.INDEX++,type:"string",required:!0})],e.prototype,"name",void 0),e=t=it([l({name:"BaseAlgorithm"})],e),e})(),ht=(()=>{var t;let e=t=class extends ut{toAlgorithm(){const t={},e=this.constructor;for(const r in e.items){if("version"===r)continue;const e=this[r];"labelStr"!==r?void 0!==e&&(e instanceof ut?e.isEmpty()||(t[r]=e.toAlgorithm()):t[r]=e):t.label=e}return t}fromAlgorithm(e){e instanceof t&&(e=e.toAlgorithm());const r=this.constructor;for(const t in e)if(r.items&&t in r.items){const i=r.items[t];if(i.parser)switch(i.parser){case ut:this[t].fromAlgorithm(e[t]);break;default:throw new Error(`Unsupported parser '${i.parser.name}'`)}else"label"===t&&"string"==typeof e.label?this.labelStr=e.label:this[t]=e[t]}}};return e.INDEX=ut.INDEX,it([d({id:t.INDEX++,type:"bytes",parser:ut})],e.prototype,"hash",void 0),it([d({id:t.INDEX++,type:"bytes"})],e.prototype,"publicExponent",void 0),it([d({id:t.INDEX++,type:"uint32"})],e.prototype,"modulusLength",void 0),it([d({id:t.INDEX++,type:"uint32"})],e.prototype,"saltLength",void 0),it([d({id:t.INDEX++,type:"bytes"})],e.prototype,"label",void 0),it([d({id:t.INDEX++,type:"string"})],e.prototype,"namedCurve",void 0),it([d({id:t.INDEX++,converter:f})],e.prototype,"public",void 0),it([d({id:t.INDEX++,type:"uint32"})],e.prototype,"length",void 0),it([d({id:t.INDEX++})],e.prototype,"iv",void 0),it([d({id:t.INDEX++,type:"bool"})],e.prototype,"token",void 0),it([d({id:t.INDEX++,type:"bool"})],e.prototype,"sensitive",void 0),it([d({id:t.INDEX++,type:"string"})],e.prototype,"labelStr",void 0),e=t=it([l({name:"Algorithm"})],e),e})(),ft=(()=>{var t;let e=t=class extends at{constructor(){super(...arguments),this.providerID="",this.id="",this.type=""}};return e.INDEX=at.INDEX,it([d({id:t.INDEX++,type:"string",required:!0})],e.prototype,"providerID",void 0),it([d({id:t.INDEX++,type:"bytes",required:!0,converter:ot})],e.prototype,"id",void 0),it([d({id:t.INDEX++,type:"string",required:!0})],e.prototype,"type",void 0),e=t=it([l({name:"CryptoItem"})],e),e})(),lt=(()=>{var t;let e=t=class extends ft{constructor(){super(...arguments),this.type="secret",this.algorithm=new ht,this.extractable=!1,this.usages=[]}};return e.INDEX=ft.INDEX,it([d({id:t.INDEX++,type:"bytes",required:!0,parser:ht})],e.prototype,"algorithm",void 0),it([d({id:t.INDEX++,type:"bool"})],e.prototype,"extractable",void 0),it([d({id:t.INDEX++,type:"string",repeated:!0})],e.prototype,"usages",void 0),e=t=it([l({name:"CryptoKey"})],e),e})(),dt=(()=>{var t;let e=t=class extends at{constructor(){super(...arguments),this.privateKey=new lt,this.publicKey=new lt}};return e.INDEX=at.INDEX,it([d({id:t.INDEX++,name:"privateKey",type:"bytes",required:!0,parser:lt})],e.prototype,"privateKey",void 0),it([d({id:t.INDEX++,name:"publicKey",type:"bytes",parser:lt})],e.prototype,"publicKey",void 0),e=t=it([l({name:"CryptoKeyPair"})],e),e})(),yt=(()=>{var t;let e=t=class extends at{constructor(t,e=0,r="error"){super(),this.code=0,this.type="error",this.message="",this.name="Error",this.stack="",t&&(this.message=t,this.code=e,this.type=r)}};return e.INDEX=at.INDEX,it([d({id:t.INDEX++,type:"uint32",defaultValue:0})],e.prototype,"code",void 0),it([d({id:t.INDEX++,type:"string",defaultValue:"error"})],e.prototype,"type",void 0),it([d({id:t.INDEX++,type:"string",defaultValue:""})],e.prototype,"message",void 0),it([d({id:t.INDEX++,type:"string",defaultValue:"Error"})],e.prototype,"name",void 0),it([d({id:t.INDEX++,type:"string",defaultValue:""})],e.prototype,"stack",void 0),e=t=it([l({name:"Error"})],e),e})(),wt=(()=>{var t;let e=t=class extends ct{constructor(t){super(),this.status=!1,t&&(this.actionId=t.actionId,this.action=t.action)}};return e.INDEX=ct.INDEX,it([d({id:t.INDEX++,type:"bool",defaultValue:!1})],e.prototype,"status",void 0),it([d({id:t.INDEX++,type:"bytes",parser:yt})],e.prototype,"error",void 0),it([d({id:t.INDEX++,type:"bytes",converter:f})],e.prototype,"data",void 0),e=t=it([l({name:"Result"})],e),e})(),vt=((()=>{let t=class extends ct{};t.INDEX=ct.INDEX,t.ACTION="auth",t=it([l({name:"AuthRequest"})],t)})(),(()=>{let t=class extends ct{};return t.INDEX=ct.INDEX,t.ACTION="server/login",t=it([l({})],t),t})()),pt=(()=>{let t=class extends ct{};return t.INDEX=ct.INDEX,t.ACTION="server/isLoggedIn",t=it([l({})],t),t})(),gt=(()=>{let t=class extends ct{};return t.INDEX=ct.INDEX,t.ACTION="cardReader",t=it([l({})],t),t})(),mt=(()=>{let t=class extends ct{};return t.INDEX=ct.INDEX,t.ACTION="cardReader/readers",t=it([l({})],t),t})(),At=(()=>{var t;let e=t=class extends gt{constructor(t,e){super(),this.reader="",this.atr="",t&&e&&(this.reader=t,this.atr=e)}};return e.INDEX=gt.INDEX,it([d({id:t.INDEX++,required:!0,type:"string",defaultValue:""})],e.prototype,"reader",void 0),it([d({id:t.INDEX++,required:!0,converter:ot})],e.prototype,"atr",void 0),e=t=it([l({})],e),e})(),bt=(()=>{let t=class extends At{};return t.INDEX=At.INDEX,t.ACTION=At.ACTION+"/insert",t=it([l({})],t),t})(),Bt=(()=>{let t=class extends At{};return t.INDEX=At.INDEX,t.ACTION=At.ACTION+"/remove",t=it([l({})],t),t})(),St=(()=>{var t;let e=t=class extends ct{constructor(){super(...arguments),this.providerID=""}};return e.INDEX=ct.INDEX,e.ACTION="crypto",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"providerID",void 0),e=t=it([l({})],e),e})(),kt=(()=>{let t=class extends St{};return t.INDEX=St.INDEX,t.ACTION="crypto/login",t=it([l({})],t),t})(),Et=(()=>{let t=class extends St{};return t.INDEX=St.INDEX,t.ACTION="crypto/logout",t=it([l({})],t),t})(),xt=(()=>{let t=class extends St{};return t.INDEX=St.INDEX,t.ACTION="crypto/isLoggedIn",t=it([l({})],t),t})(),Nt=(()=>{let t=class extends St{};return t.INDEX=St.INDEX,t.ACTION="crypto/reset",t=it([l({})],t),t})(),Ut=(()=>{var t;let e=t=class extends ft{constructor(){super(...arguments),this.id="",this.publicKey=new lt,this.type="x509",this.label="",this.token=!1,this.sensitive=!1}};return e.INDEX=ft.INDEX,it([d({id:t.INDEX++,required:!0,converter:ot})],e.prototype,"id",void 0),it([d({id:t.INDEX++,required:!0,parser:lt})],e.prototype,"publicKey",void 0),it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"type",void 0),it([d({id:t.INDEX++,type:"string",defaultValue:""})],e.prototype,"label",void 0),it([d({id:t.INDEX++,type:"bool",defaultValue:!1})],e.prototype,"token",void 0),it([d({id:t.INDEX++,type:"bool",defaultValue:!1})],e.prototype,"sensitive",void 0),e=t=it([l({})],e),e})(),Ct=(()=>{var t;let e=t=class extends Ut{constructor(){super(...arguments),this.type="x509",this.serialNumber="",this.issuerName="",this.subjectName="",this.notBefore=new Date,this.notAfter=new Date}};return e.INDEX=Ut.INDEX,it([d({id:t.INDEX++,required:!0,converter:ot})],e.prototype,"serialNumber",void 0),it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"issuerName",void 0),it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"subjectName",void 0),it([d({id:t.INDEX++,required:!0,converter:st})],e.prototype,"notBefore",void 0),it([d({id:t.INDEX++,required:!0,converter:st})],e.prototype,"notAfter",void 0),e=t=it([l({})],e),e})(),It=(()=>{var t;let e=t=class extends Ut{constructor(){super(...arguments),this.type="request",this.subjectName=""}};return e.INDEX=Ut.INDEX,it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"subjectName",void 0),e=t=it([l({})],e),e})(),Ot=(()=>{var t;let e=t=class extends at{constructor(){super(...arguments),this.type="",this.value=new ArrayBuffer(0)}};return e.INDEX=at.INDEX,it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"type",void 0),it([d({id:t.INDEX++,required:!0,converter:f})],e.prototype,"value",void 0),e=t=it([l({})],e),e})(),qt=(()=>{var t;let e=t=class extends at{constructor(){super(...arguments),this.items=[]}};return e.INDEX=at.INDEX,it([d({id:t.INDEX++,required:!0,repeated:!0,parser:Ot})],e.prototype,"items",void 0),e=t=it([l({})],e),e})(),Rt=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.item=new Ut}};return e.INDEX=St.INDEX,e.ACTION="crypto/certificateStorage/setItem",it([d({id:t.INDEX++,required:!0,parser:Ut})],e.prototype,"item",void 0),e=t=it([l({})],e),e})(),Tt=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.key="",this.algorithm=new ht,this.keyUsages=[]}};return e.INDEX=St.INDEX,e.ACTION="crypto/certificateStorage/getItem",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"key",void 0),it([d({id:t.INDEX++,parser:ht})],e.prototype,"algorithm",void 0),it([d({id:t.INDEX++,repeated:!0,type:"string"})],e.prototype,"keyUsages",void 0),e=t=it([l({})],e),e})(),Kt=(()=>{let t=class extends St{};return t.INDEX=St.INDEX,t.ACTION="crypto/certificateStorage/keys",t=it([l({})],t),t})(),Dt=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.key=""}};return e.INDEX=St.INDEX,e.ACTION="crypto/certificateStorage/removeItem",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"key",void 0),e=t=it([l({})],e),e})(),jt=(()=>{let t=class extends St{};return t.INDEX=St.INDEX,t.ACTION="crypto/certificateStorage/clear",t=it([l({})],t),t})(),Pt=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.format="raw",this.data=new ArrayBuffer(0),this.algorithm=new ht,this.keyUsages=[]}};return e.INDEX=St.INDEX,e.ACTION="crypto/certificateStorage/import",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"format",void 0),it([d({id:t.INDEX++,required:!0,converter:f})],e.prototype,"data",void 0),it([d({id:t.INDEX++,required:!0,parser:ht})],e.prototype,"algorithm",void 0),it([d({id:t.INDEX++,repeated:!0,type:"string"})],e.prototype,"keyUsages",void 0),e=t=it([l({})],e),e})(),$t=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.format="raw",this.item=new Ut}};return e.INDEX=St.INDEX,e.ACTION="crypto/certificateStorage/export",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"format",void 0),it([d({id:t.INDEX++,required:!0,parser:Ut})],e.prototype,"item",void 0),e=t=it([l({})],e),e})(),Jt=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.item=new Ut}};return e.INDEX=St.INDEX,e.ACTION="crypto/certificateStorage/indexOf",it([d({id:t.INDEX++,required:!0,parser:Ut})],e.prototype,"item",void 0),e=t=it([l({})],e),e})(),Vt=(()=>{let t=class extends St{constructor(){super(...arguments),this.item=new Ut}};return t.INDEX=St.INDEX,t.ACTION="crypto/certificateStorage/getChain",it([d({id:Rt.INDEX++,required:!0,parser:Ut})],t.prototype,"item",void 0),t=it([l({})],t),t})(),Mt=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.url=""}};return e.INDEX=St.INDEX,e.ACTION="crypto/certificateStorage/getCRL",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"url",void 0),e=t=it([l({})],e),e})(),_t=(()=>{var t;let e=t=class extends at{constructor(){super(...arguments),this.method="get"}};return e.INDEX=at.INDEX,it([d({id:t.INDEX++,required:!1,type:"string",defaultValue:"get"})],e.prototype,"method",void 0),e=t=it([l({})],e),e})(),Ht=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.url="",this.request=new ArrayBuffer(0),this.options=new _t}};return e.INDEX=St.INDEX,e.ACTION="crypto/certificateStorage/getOCSP",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"url",void 0),it([d({id:t.INDEX++,required:!0,converter:f})],e.prototype,"request",void 0),it([d({id:t.INDEX++,required:!1,parser:_t})],e.prototype,"options",void 0),e=t=it([l({})],e),e})(),Wt=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.item=new lt}};return e.INDEX=St.INDEX,e.ACTION="crypto/keyStorage/setItem",it([d({id:t.INDEX++,required:!0,parser:lt})],e.prototype,"item",void 0),e=t=it([l({})],e),e})(),Gt=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.key="",this.algorithm=new ht,this.extractable=!1,this.keyUsages=[]}};return e.INDEX=St.INDEX,e.ACTION="crypto/keyStorage/getItem",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"key",void 0),it([d({id:t.INDEX++,parser:ht})],e.prototype,"algorithm",void 0),it([d({id:t.INDEX++,type:"bool"})],e.prototype,"extractable",void 0),it([d({id:t.INDEX++,repeated:!0,type:"string"})],e.prototype,"keyUsages",void 0),e=t=it([l({})],e),e})(),Lt=(()=>{let t=class extends St{};return t.INDEX=St.INDEX,t.ACTION="crypto/keyStorage/keys",t=it([l({})],t),t})(),zt=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.key=""}};return e.INDEX=St.INDEX,e.ACTION="crypto/keyStorage/removeItem",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"key",void 0),e=t=it([l({})],e),e})(),Ft=(()=>{let t=class extends St{};return t.INDEX=St.INDEX,t.ACTION="crypto/keyStorage/clear",t=it([l({})],t),t})(),Zt=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.item=new lt}};return e.INDEX=St.INDEX,e.ACTION="crypto/keyStorage/indexOf",it([d({id:t.INDEX++,required:!0,parser:lt})],e.prototype,"item",void 0),e=t=it([l({})],e),e})(),Xt=(()=>{var t;let e=t=class extends at{constructor(t){super(),this.id="",this.name="",this.readOnly=!1,this.algorithms=[],this.isRemovable=!1,this.atr="",this.isHardware=!1,this.card="",t&&a(this,t)}};return e.INDEX=at.INDEX,it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"id",void 0),it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"name",void 0),it([d({id:t.INDEX++,type:"bool",defaultValue:!1})],e.prototype,"readOnly",void 0),it([d({id:t.INDEX++,repeated:!0,type:"string"})],e.prototype,"algorithms",void 0),it([d({id:t.INDEX++,type:"bool",defaultValue:!1})],e.prototype,"isRemovable",void 0),it([d({id:t.INDEX++,type:"string"})],e.prototype,"atr",void 0),it([d({id:t.INDEX++,type:"bool",defaultValue:!1})],e.prototype,"isHardware",void 0),it([d({id:t.INDEX++,type:"string"})],e.prototype,"card",void 0),e=t=it([l({})],e),e})(),Qt=(()=>{var t;let e=t=class extends at{constructor(){super(...arguments),this.name="",this.providers=[]}};return e.INDEX=at.INDEX,it([d({id:t.INDEX++,type:"string",required:!0})],e.prototype,"name",void 0),it([d({id:t.INDEX++,repeated:!0,parser:Xt})],e.prototype,"providers",void 0),e=t=it([l({})],e),e})(),Yt=(()=>{let t=class extends ct{};return t.INDEX=ct.INDEX,t.ACTION="provider/action/info",t=it([l({})],t),t})(),te=(()=>{var t;let e=t=class extends ct{constructor(){super(...arguments),this.cryptoID=""}};return e.INDEX=ct.INDEX,e.ACTION="provider/action/getCrypto",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"cryptoID",void 0),e=t=it([l({})],e),e})(),ee=(()=>{let t=class extends ct{};return t.INDEX=ct.INDEX,t.ACTION="provider/event/authorized",t=it([l({})],t),t})(),re=(()=>{var t;let e=t=class extends ct{constructor(t){super(),this.added=[],this.removed=[],t&&a(this,t)}};return e.INDEX=ct.INDEX,e.ACTION="provider/event/token",it([d({id:t.INDEX++,repeated:!0,parser:Xt})],e.prototype,"added",void 0),it([d({id:t.INDEX++,repeated:!0,parser:Xt})],e.prototype,"removed",void 0),it([d({id:t.INDEX++,type:"bytes",parser:yt})],e.prototype,"error",void 0),e=t=it([l({name:"ProviderTokenEvent"})],e),e})(),ie=((()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.algorithm=new ht,this.data=new ArrayBuffer(0)}};e.INDEX=St.INDEX,e.ACTION="crypto/subtle/digest",it([d({id:t.INDEX++,required:!0,parser:ht})],e.prototype,"algorithm",void 0),it([d({id:t.INDEX++,required:!0,converter:f})],e.prototype,"data",void 0),e=t=it([l({})],e)})(),(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.algorithm=new ht,this.extractable=!1,this.usage=[]}};return e.INDEX=St.INDEX,e.ACTION="crypto/subtle/generateKey",it([d({id:t.INDEX++,type:"bytes",required:!0,parser:ht})],e.prototype,"algorithm",void 0),it([d({id:t.INDEX++,type:"bool",required:!0})],e.prototype,"extractable",void 0),it([d({id:t.INDEX++,type:"string",repeated:!0})],e.prototype,"usage",void 0),e=t=it([l({})],e),e})()),ne=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.algorithm=new ht,this.key=new lt,this.data=new ArrayBuffer(0)}};return e.INDEX=St.INDEX,e.ACTION="crypto/subtle/sign",it([d({id:t.INDEX++,required:!0,parser:ht})],e.prototype,"algorithm",void 0),it([d({id:t.INDEX++,required:!0,parser:lt})],e.prototype,"key",void 0),it([d({id:t.INDEX++,required:!0,converter:f})],e.prototype,"data",void 0),e=t=it([l({})],e),e})(),se=(()=>{var t;let e=t=class extends ne{constructor(){super(...arguments),this.signature=new ArrayBuffer(0)}};return e.INDEX=ne.INDEX,e.ACTION="crypto/subtle/verify",it([d({id:t.INDEX++,required:!0,converter:f})],e.prototype,"signature",void 0),e=t=it([l({})],e),e})(),oe=(()=>{let t=class extends ne{};return t.INDEX=ne.INDEX,t.ACTION="crypto/subtle/encrypt",t=it([l({})],t),t})(),ae=(()=>{let t=class extends ne{};return t.INDEX=ne.INDEX,t.ACTION="crypto/subtle/decrypt",t=it([l({})],t),t})(),ce=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.algorithm=new ht,this.key=new lt,this.length=0}};return e.INDEX=St.INDEX,e.ACTION="crypto/subtle/deriveBits",it([d({id:t.INDEX++,required:!0,parser:ht})],e.prototype,"algorithm",void 0),it([d({id:t.INDEX++,required:!0,parser:lt})],e.prototype,"key",void 0),it([d({id:t.INDEX++,required:!0,type:"uint32"})],e.prototype,"length",void 0),e=t=it([l({})],e),e})(),ue=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.algorithm=new ht,this.key=new lt,this.derivedKeyType=new ht,this.extractable=!1,this.usage=[]}};return e.INDEX=St.INDEX,e.ACTION="crypto/subtle/deriveKey",it([d({id:t.INDEX++,required:!0,parser:ht})],e.prototype,"algorithm",void 0),it([d({id:t.INDEX++,required:!0,parser:lt})],e.prototype,"key",void 0),it([d({id:t.INDEX++,required:!0,parser:ht})],e.prototype,"derivedKeyType",void 0),it([d({id:t.INDEX++,type:"bool"})],e.prototype,"extractable",void 0),it([d({id:t.INDEX++,type:"string",repeated:!0})],e.prototype,"usage",void 0),e=t=it([l({})],e),e})(),he=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.format="",this.wrappedKey=new ArrayBuffer(0),this.unwrappingKey=new lt,this.unwrapAlgorithm=new ht,this.unwrappedKeyAlgorithm=new ht,this.extractable=!1,this.keyUsage=[]}};return e.INDEX=St.INDEX,e.ACTION="crypto/subtle/unwrapKey",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"format",void 0),it([d({id:t.INDEX++,required:!0,converter:f})],e.prototype,"wrappedKey",void 0),it([d({id:t.INDEX++,required:!0,parser:lt})],e.prototype,"unwrappingKey",void 0),it([d({id:t.INDEX++,required:!0,parser:ht})],e.prototype,"unwrapAlgorithm",void 0),it([d({id:t.INDEX++,required:!0,parser:ht})],e.prototype,"unwrappedKeyAlgorithm",void 0),it([d({id:t.INDEX++,type:"bool"})],e.prototype,"extractable",void 0),it([d({id:t.INDEX++,type:"string",repeated:!0})],e.prototype,"keyUsage",void 0),e=t=it([l({})],e),e})(),fe=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.format="",this.key=new lt,this.wrappingKey=new lt,this.wrapAlgorithm=new ht}};return e.INDEX=St.INDEX,e.ACTION="crypto/subtle/wrapKey",it([d({id:t.INDEX++,required:!0,type:"string"})],e.prototype,"format",void 0),it([d({id:t.INDEX++,required:!0,parser:lt})],e.prototype,"key",void 0),it([d({id:t.INDEX++,required:!0,parser:lt})],e.prototype,"wrappingKey",void 0),it([d({id:t.INDEX++,required:!0,parser:ht})],e.prototype,"wrapAlgorithm",void 0),e=t=it([l({})],e),e})(),le=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.format="",this.key=new lt}};return e.INDEX=St.INDEX,e.ACTION="crypto/subtle/exportKey",it([d({id:t.INDEX++,type:"string",required:!0})],e.prototype,"format",void 0),it([d({id:t.INDEX++,required:!0,parser:lt})],e.prototype,"key",void 0),e=t=it([l({})],e),e})(),de=(()=>{var t;let e=t=class extends St{constructor(){super(...arguments),this.format="",this.keyData=new ArrayBuffer(0),this.algorithm=new ht,this.extractable=!1,this.keyUsages=[]}};return e.INDEX=St.INDEX,e.ACTION="crypto/subtle/importKey",it([d({id:t.INDEX++,type:"string",required:!0})],e.prototype,"format",void 0),it([d({id:t.INDEX++,required:!0,converter:f})],e.prototype,"keyData",void 0),it([d({id:t.INDEX++,required:!0,parser:ht})],e.prototype,"algorithm",void 0),it([d({id:t.INDEX++,required:!0,type:"bool"})],e.prototype,"extractable",void 0),it([d({id:t.INDEX++,type:"string",repeated:!0})],e.prototype,"keyUsages",void 0),e=t=it([l({})],e),e})();class ye extends v{constructor(t){super(),this.client=t,this.onEvent=this.onEvent.bind(this),this.client.on("listening",()=>{this.client.on("event",this.onEvent)}).on("close",()=>{this.client.removeListener("event",this.onEvent)})}readers(){return nt(this,void 0,void 0,(function*(){const t=yield this.client.send(new mt);return JSON.parse(s.ToString(t))}))}on(t,e){return super.on(t,e)}emit(t,...e){return super.emit(t,...e)}onEvent(t){(()=>nt(this,void 0,void 0,(function*(){switch(t.action){case bt.ACTION:this.onInsert(yield bt.importProto(t));break;case Bt.ACTION:this.onRemove(yield Bt.importProto(t))}})))().catch(t=>this.emit("error",t))}onInsert(t){this.emit("insert",t)}onRemove(t){this.emit("remove",t)}}class we extends Error{constructor(t){super(t.message),this.name="CryptoServerError",this.code=t.code,this.type=t.type}}class ve extends class{constructor(t,e){this.target=t,this.event=e}}{}class pe extends ve{constructor(t,e,r,i){super(t,"close"),this.remoteAddress=e,this.reasonCode=r,this.description=i}}class ge extends ve{constructor(t,e){super(t,"error"),this.error=e}}class me extends ve{constructor(t,e){super(t,"listening"),this.address=e}}function Ae(){return/firefox/i.test(self.navigator.userAgent)}function be(){return/edge\/([\d\.]+)/i.test(self.navigator.userAgent)}function Be(){return!!window.document.documentMode}const Se={name:"ECDH",namedCurve:"P-256"},ke={name:"ECDSA",namedCurve:"P-256"},Ee={name:"AES-CBC",iv:new ArrayBuffer(16)};function xe(t,e){return nt(this,void 0,void 0,(function*(){const r=yield function(t){return nt(this,void 0,void 0,(function*(){const e=t.algorithm.name.toUpperCase();if("ECDH"!==e&&"ECDSA"!==e)throw new Error("Error: Unsupported asymmetric key algorithm.");if("public"!==t.type)throw new Error("Error: Expected key type to be public but it was not.");const r=yield O().crypto.subtle.exportKey("jwk",t);if(!r.x||!r.y)throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const i=s.FromBase64Url(r.x),n=s.FromBase64Url(r.y),o=s.ToBinary(i)+s.ToBinary(n),a=t,c=s.FromBinary(o);return{id:s.ToHex(yield O().crypto.subtle.digest("SHA-256",c)),key:a,serialized:c}}))}(e);t.id=r.id,t.key=r.key,t.serialized=r.serialized}))}var Ne;!function(t){t[t.connecting=0]="connecting",t[t.open=1]="open",t[t.closing=2]="closing",t[t.closed=3]="closed"}(Ne||(Ne={}));class Ue extends v{constructor(t){super(),this.stack={},this.messageCounter=0,this.storage=t}get state(){return this.socket?this.socket.readyState:Ne.closed}connect(t,e){return this.getServerInfo(t).then(r=>{this.serviceInfo=r;const n="wss://"+t;this.socket=e?new i(n,void 0,e):new i(n),this.socket.binaryType="arraybuffer",this.socket.onerror=t=>{this.emit("error",new ge(this,t.error))},this.socket.onopen=()=>{(()=>nt(this,void 0,void 0,(function*(){let e=yield this.storage.loadIdentity();e||(e=yield D.create(1,0,0,Be()||be()||Ae()),yield this.storage.saveIdentity(e));const i=yield z.importProto(s.FromBase64(r.preKey));this.cipher=yield tt.create(e,i),yield this.storage.saveRemoteIdentity("0",this.cipher.remoteIdentity),this.emit("listening",new me(this,t))})))().catch(t=>this.emit("error",new ge(this,t)))},this.socket.onclose=e=>{for(const t in this.stack)this.stack[t].reject(new Error("Cannot finish operation. Session was closed"));this.emit("close",new pe(this,t,e.code,e.reason))},this.socket.onmessage=t=>{t.data instanceof ArrayBuffer&&H.importProto(t.data).then(t=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.decrypt(t)}).then(t=>{this.onMessage(t)}).catch(t=>{this.emit("error",new ge(this,t))})}}).catch(t=>{this.emit("error",new ge(this,t))}),this}close(){this.socket&&this.socket.close()}on(t,e){return super.on(t,e)}once(t,e){return super.once(t,e)}challenge(){return nt(this,void 0,void 0,(function*(){if(!this.cipher)throw new Error("Client cipher is not initialized");return function(t,e){return nt(this,void 0,void 0,(function*(){const r=yield t.thumbprint(),i=yield e.thumbprint(),n=s.FromHex(r+i),o=yield O().crypto.subtle.digest("SHA-256",n);return parseInt(s.ToHex(o),16).toString().substr(2,6)}))}(this.cipher.remoteIdentity.signingKey,this.cipher.identity.signingKey.publicKey)}))}isLoggedIn(){return nt(this,void 0,void 0,(function*(){const t=new pt,e=yield this.send(t);return!!e&&!!new Uint8Array(e)[0]}))}login(){return nt(this,void 0,void 0,(function*(){const t=new vt;yield this.send(t)}))}send(t){return new Promise((e,r)=>{this.checkSocketState(),t||(t=new ct),t.action=t.action,t.actionId=(this.messageCounter++).toString(),t.exportProto().then(t=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.encrypt(t).then(t=>t.exportProto())}).then(i=>{if(!this.socket)throw new Error("Client socket is not initialized");this.stack[t.actionId]={resolve:e,reject:r},this.socket.send(i)}).catch(r)})}getServerInfo(t){return nt(this,void 0,void 0,(function*(){const e=`https://${t}/.well-known/webcrypto-socket`,i=yield r(e);if(200!==i.status)throw new Error("Cannot get wellknown link");return yield i.json()}))}checkSocketState(){if(this.state!==Ne.open)throw new Error("Socket connection is not open")}onMessage(t){return nt(this,void 0,void 0,(function*(){const e=yield ct.importProto(t),r=this.stack[e.actionId];if(r){delete this.stack[e.actionId];const t=yield wt.importProto(yield e.exportProto());if(t.error&&t.error.message){const e=new we(t.error);r.reject(e)}else r.resolve(t.data)}else this.emit("event",e)}))}}
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */function Ce(t,e,r,i){var n,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,r,i);else for(var a=t.length-1;a>=0;a--)(n=t[a])&&(o=(s<3?n(o):s>3?n(e,r,o):n(e,r))||o);return s>3&&o&&Object.defineProperty(e,r,o),o}function Ie(t,e){return t(e={exports:{}},e.exports),e.exports}function Oe(t,e){let r=0;if(1===t.length)return t[0];for(let i=t.length-1;i>=0;i--)r+=t[t.length-1-i]*Math.pow(2,e*i);return r}function qe(t,e,r=-1){const i=r;let n=t,s=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(t<o){let t;if(i<0)t=new ArrayBuffer(a),s=a;else{if(i<a)return new ArrayBuffer(0);t=new ArrayBuffer(i),s=i}const r=new Uint8Array(t);for(let i=a-1;i>=0;i--){const t=Math.pow(2,i*e);r[s-i-1]=Math.floor(n/t),n-=r[s-i-1]*t}return t}o*=Math.pow(2,e)}return new ArrayBuffer(0)}const Re="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",Te="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",Ke=Math.log(2);var De,je=Object.freeze({__proto__:null,getUTCDate:function(t){return new Date(t.getTime()+6e4*t.getTimezoneOffset())},getParametersValue:function(t,e,r){return t instanceof Object==0?r:e in t?t[e]:r},bufferToHexCodes:function(t,e=0,r=t.byteLength-e,i=!1){let n="";for(const s of new Uint8Array(t,e,r)){const t=s.toString(16).toUpperCase();1===t.length&&(n+="0"),n+=t,i&&(n+=" ")}return n.trim()},checkBufferParams:function(t,e,r,i){return e instanceof ArrayBuffer==0?(t.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===e.byteLength?(t.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(t.error="Wrong parameter: inputOffset less than zero",!1):i<0?(t.error="Wrong parameter: inputLength less than zero",!1):!(e.byteLength-r-i<0&&(t.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1))},utilFromBase:Oe,utilToBase:qe,utilConcatBuf:function(...t){let e=0,r=0;for(const s of t)e+=s.byteLength;const i=new ArrayBuffer(e),n=new Uint8Array(i);for(const s of t)n.set(new Uint8Array(s),r),r+=s.byteLength;return i},utilConcatView:function(...t){let e=0,r=0;for(const s of t)e+=s.length;const i=new ArrayBuffer(e),n=new Uint8Array(i);for(const s of t)n.set(s,r),r+=s.length;return n},utilDecodeTC:function(){const t=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const e=0===t[0]&&0==(128&t[1]);(255===t[0]&&128&t[1]||e)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(e);for(let o=0;o<this.valueHex.byteLength;o++)r[o]=0;r[0]=128&t[0];const i=Oe(r,8),n=new ArrayBuffer(this.valueHex.byteLength),s=new Uint8Array(n);for(let o=0;o<this.valueHex.byteLength;o++)s[o]=t[o];return s[0]&=127,Oe(s,8)-i},utilEncodeTC:function(t){const e=t<0?-1*t:t;let r=128;for(let i=1;i<8;i++){if(e<=r){if(t<0){const t=qe(r-e,8,i);return new Uint8Array(t)[0]|=128,t}let n=qe(e,8,i),s=new Uint8Array(n);if(128&s[0]){const t=n.slice(0),e=new Uint8Array(t);n=new ArrayBuffer(n.byteLength+1),s=new Uint8Array(n);for(let r=0;r<t.byteLength;r++)s[r+1]=e[r];s[0]=0}return n}r*=Math.pow(2,8)}return new ArrayBuffer(0)},isEqualBuffer:function(t,e){if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),i=new Uint8Array(e);for(let n=0;n<r.length;n++)if(r[n]!==i[n])return!1;return!0},padNumber:function(t,e){const r=t.toString(10);if(e<r.length)return"";const i=e-r.length,n=new Array(i);for(let s=0;s<i;s++)n[s]="0";return n.join("").concat(r)},toBase64:function(t,e=!1,r=!1,i=!1){let n=0,s=0,o=0,a="";const c=e?Te:Re;if(i){let e=0;for(let r=0;r<t.length;r++)if(0!==t.charCodeAt(r)){e=r;break}t=t.slice(e)}for(;n<t.length;){const e=t.charCodeAt(n++);n>=t.length&&(s=1);const i=t.charCodeAt(n++);n>=t.length&&(o=1);const u=t.charCodeAt(n++),h=e>>2,f=(3&e)<<4|i>>4;let l=(15&i)<<2|u>>6,d=63&u;1===s?l=d=64:1===o&&(d=64),a+=r?64===l?`${c.charAt(h)}${c.charAt(f)}`:64===d?`${c.charAt(h)}${c.charAt(f)}${c.charAt(l)}`:`${c.charAt(h)}${c.charAt(f)}${c.charAt(l)}${c.charAt(d)}`:`${c.charAt(h)}${c.charAt(f)}${c.charAt(l)}${c.charAt(d)}`}return a},fromBase64:function(t,e=!1,r=!1){const i=e?Te:Re;function n(t){for(let e=0;e<64;e++)if(i.charAt(e)===t)return e;return 64}function s(t){return 64===t?0:t}let o=0,a="";for(;o<t.length;){const e=n(t.charAt(o++)),r=o>=t.length?0:n(t.charAt(o++)),i=o>=t.length?0:n(t.charAt(o++)),c=o>=t.length?0:n(t.charAt(o++)),u=s(e)<<2|s(r)>>4,h=(15&s(r))<<4|s(i)>>2,f=(3&s(i))<<6|s(c);a+=String.fromCharCode(u),64!==i&&(a+=String.fromCharCode(h)),64!==c&&(a+=String.fromCharCode(f))}if(r){let t=-1;for(let e=a.length-1;e>=0;e--)if(0!==a.charCodeAt(e)){t=e;break}a=-1!==t?a.slice(0,t+1):""}return a},arrayBufferToString:function(t){let e="";const r=new Uint8Array(t);for(const i of r)e+=String.fromCharCode(i);return e},stringToArrayBuffer:function(t){const e=t.length,r=new ArrayBuffer(e),i=new Uint8Array(r);for(let n=0;n<e;n++)i[n]=t.charCodeAt(n);return r},nearestPowerOf2:function(t){const e=Math.log(t)/Ke,r=Math.floor(e),i=Math.round(e);return r===i?r:i},clearProps:function(t,e){for(const r of e)delete t[r]}}),Pe=Ie((function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.fromBER=at,e.compareSchema=ct,e.verifySchema=function(t,e){if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const r=at(t);return-1===r.offset?{verified:!1,result:r.result}:ct(r.result,r.result,e)},e.fromJSON=function(){},e.RawData=e.Repeated=e.Any=e.Choice=e.TIME=e.Duration=e.DateTime=e.TimeOfDay=e.DATE=e.GeneralizedTime=e.UTCTime=e.CharacterString=e.GeneralString=e.VisibleString=e.GraphicString=e.IA5String=e.VideotexString=e.TeletexString=e.PrintableString=e.NumericString=e.UniversalString=e.BmpString=e.RelativeObjectIdentifier=e.Utf8String=e.ObjectIdentifier=e.Enumerated=e.Integer=e.BitString=e.OctetString=e.Null=e.Set=e.Sequence=e.Boolean=e.EndOfContent=e.Constructed=e.Primitive=e.BaseBlock=e.ValueBlock=e.HexBlock=void 0;const r=[new Uint8Array([1])];class i{constructor(t={}){this.blockLength=(0,je.getParametersValue)(t,"blockLength",0),this.error=(0,je.getParametersValue)(t,"error",""),this.warnings=(0,je.getParametersValue)(t,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in t?t.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:(0,je.bufferToHexCodes)(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const n=t=>class extends t{constructor(t={}){super(t),this.isHexOnly=(0,je.getParametersValue)(t,"isHexOnly",!1),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(t,e,r){return!1===(0,je.checkBufferParams)(this,t,e,r)?-1:0===new Uint8Array(t,e,r).length?(this.warnings.push("Zero buffer length"),e):(this.valueHex=t.slice(e,e+r),this.blockLength=r,e+r)}toBER(t=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===t?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isHexOnly=this.isHexOnly,t.valueHex=(0,je.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}};e.HexBlock=n;class s extends(n(i)){constructor(t={}){super(),"idBlock"in t?(this.isHexOnly=(0,je.getParametersValue)(t.idBlock,"isHexOnly",!1),this.valueHex=(0,je.getParametersValue)(t.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=(0,je.getParametersValue)(t.idBlock,"tagClass",-1),this.tagNumber=(0,je.getParametersValue)(t.idBlock,"tagNumber",-1),this.isConstructed=(0,je.getParametersValue)(t.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(t=!1){let e,r,i=0;switch(this.tagClass){case 1:i|=0;break;case 2:i|=64;break;case 3:i|=128;break;case 4:i|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(i|=32),this.tagNumber<31&&!this.isHexOnly){if(e=new ArrayBuffer(1),r=new Uint8Array(e),!t){let t=this.tagNumber;t&=31,i|=t,r[0]=i}return e}if(!1===this.isHexOnly){const n=(0,je.utilToBase)(this.tagNumber,7),s=new Uint8Array(n),o=n.byteLength;if(e=new ArrayBuffer(o+1),r=new Uint8Array(e),r[0]=31|i,!t){for(let t=0;t<o-1;t++)r[t+1]=128|s[t];r[o]=s[o-1]}return e}if(e=new ArrayBuffer(this.valueHex.byteLength+1),r=new Uint8Array(e),r[0]=31|i,!1===t){const t=new Uint8Array(this.valueHex);for(let e=0;e<t.length-1;e++)r[e+1]=128|t[e];r[this.valueHex.byteLength]=t[t.length-1]}return e}fromBER(t,e,r){if(!1===(0,je.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(0===i.length)return this.error="Zero buffer length",-1;switch(192&i[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&i[0]),this.isHexOnly=!1;const n=31&i[0];if(31!==n)this.tagNumber=n,this.blockLength=1;else{let t=1;this.valueHex=new ArrayBuffer(255);let e=255,r=new Uint8Array(this.valueHex);for(;128&i[t];){if(r[t-1]=127&i[t],t++,t>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(t===e){e+=255;const t=new ArrayBuffer(e),i=new Uint8Array(t);for(let e=0;e<r.length;e++)i[e]=r[e];this.valueHex=new ArrayBuffer(e),r=new Uint8Array(this.valueHex)}}this.blockLength=t+1,r[t-1]=127&i[t];const n=new ArrayBuffer(t),s=new Uint8Array(n);for(let i=0;i<t;i++)s[i]=r[i];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex),r.set(s),this.blockLength<=9?this.tagNumber=(0,je.utilFromBase)(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.tagClass=this.tagClass,t.tagNumber=this.tagNumber,t.isConstructed=this.isConstructed,t}}class o extends i{constructor(t={}){super(),"lenBlock"in t?(this.isIndefiniteForm=(0,je.getParametersValue)(t.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=(0,je.getParametersValue)(t.lenBlock,"longFormUsed",!1),this.length=(0,je.getParametersValue)(t.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(t,e,r){if(!1===(0,je.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(0===i.length)return this.error="Zero buffer length",-1;if(255===i[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===i[0],!0===this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(128&i[0]),!1===this.longFormUsed)return this.length=i[0],this.blockLength=1,e+this.blockLength;const n=127&i[0];if(n>8)return this.error="Too big integer",-1;if(n+1>i.length)return this.error="End of input reached before message was fully decoded",-1;const s=new Uint8Array(n);for(let o=0;o<n;o++)s[o]=i[o+1];return 0===s[n-1]&&this.warnings.push("Needlessly long encoded length"),this.length=(0,je.utilFromBase)(s,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=n+1,e+this.blockLength}toBER(t=!1){let e,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=128),e;if(!0===this.longFormUsed){const i=(0,je.utilToBase)(this.length,8);if(i.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(e=new ArrayBuffer(i.byteLength+1),!0===t)return e;const n=new Uint8Array(i);r=new Uint8Array(e),r[0]=128|i.byteLength;for(let t=0;t<i.byteLength;t++)r[t+1]=n[t];return e}return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=this.length),e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isIndefiniteForm=this.isIndefiniteForm,t.longFormUsed=this.longFormUsed,t.length=this.length,t}}class a extends i{constructor(t={}){super(t)}static blockName(){return"valueBlock"}fromBER(t,e,r){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(t=!1){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}e.ValueBlock=a;class c extends i{constructor(t={},e=a){super(t),"name"in t&&(this.name=t.name),"optional"in t&&(this.optional=t.optional),"primitiveSchema"in t&&(this.primitiveSchema=t.primitiveSchema),this.idBlock=new s(t),this.lenBlock=new o(t),this.valueBlock=new e(t)}static blockName(){return"BaseBlock"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}toBER(t=!1){let e;const r=this.idBlock.toBER(t),i=this.valueBlock.toBER(!0);this.lenBlock.length=i.byteLength;const n=this.lenBlock.toBER(t);let s;if(e=(0,je.utilConcatBuf)(r,n),s=!1===t?this.valueBlock.toBER(t):new ArrayBuffer(this.lenBlock.length),e=(0,je.utilConcatBuf)(e,s),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===t){const t=new Uint8Array(r);t[0]=0,t[1]=0}e=(0,je.utilConcatBuf)(e,r)}return e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.idBlock=this.idBlock.toJSON(),t.lenBlock=this.lenBlock.toJSON(),t.valueBlock=this.valueBlock.toJSON(),"name"in this&&(t.name=this.name),"optional"in this&&(t.optional=this.optional),"primitiveSchema"in this&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}}e.BaseBlock=c;class u extends a{constructor(t={}){super(t),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=(0,je.getParametersValue)(t,"isHexOnly",!0)}fromBER(t,e,r){if(!1===(0,je.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(0===i.length)return this.warnings.push("Zero buffer length"),e;this.valueHex=new ArrayBuffer(i.length);const n=new Uint8Array(this.valueHex);for(let s=0;s<i.length;s++)n[s]=i[s];return this.blockLength=r,e+r}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueHex=(0,je.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t.isHexOnly=this.isHexOnly,t}}class h extends c{constructor(t={}){super(t,u),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}e.Primitive=h;class f extends a{constructor(t={}){super(t),this.value=(0,je.getParametersValue)(t,"value",[]),this.isIndefiniteForm=(0,je.getParametersValue)(t,"isIndefiniteForm",!1)}fromBER(t,e,r){const i=e,n=r;if(!1===(0,je.checkBufferParams)(this,t,e,r))return-1;if(0===new Uint8Array(t,e,r).length)return this.warnings.push("Zero buffer length"),e;let s=e;for(;(!0===this.isIndefiniteForm?1:r)>0;){const e=ot(t,s,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(s=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),!0===this.isIndefiniteForm&&e.result.constructor.blockName()===y.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===y.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=t.slice(i,i+n),s}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const i=this.value[r].toBER(t);e=(0,je.utilConcatBuf)(e,i)}return e}static blockName(){return"ConstructedValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.isIndefiniteForm=this.isIndefiniteForm,t.value=[];for(let r=0;r<this.value.length;r++)t.value.push(this.value[r].toJSON());return t}}class l extends c{constructor(t={}){super(t,f),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(t,e,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}}e.Constructed=l;class d extends a{constructor(t={}){super(t)}fromBER(t,e,r){return e}toBER(t=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class y extends c{constructor(t={}){super(t,d),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}e.EndOfContent=y;class w extends a{constructor(t={}){super(t),this.value=(0,je.getParametersValue)(t,"value",!1),this.isHexOnly=(0,je.getParametersValue)(t,"isHexOnly",!1),"valueHex"in t?this.valueHex=t.valueHex.slice(0):(this.valueHex=new ArrayBuffer(1),!0===this.value&&(new Uint8Array(this.valueHex)[0]=255))}fromBER(t,e,r){if(!1===(0,je.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(i.length);const n=new Uint8Array(this.valueHex);for(let s=0;s<i.length;s++)n[s]=i[s];return this.value=0!==je.utilDecodeTC.call(this),this.blockLength=r,e+r}toBER(t=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t.isHexOnly=this.isHexOnly,t.valueHex=(0,je.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class v extends c{constructor(t={}){super(t,w),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}e.Boolean=v;class p extends l{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}e.Sequence=p;class g extends l{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}e.Set=g;class m extends c{constructor(t={}){super(t,i),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(t,e,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,e+r>t.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):e+r}toBER(t=!1){const e=new ArrayBuffer(2);if(!0===t)return e;const r=new Uint8Array(e);return r[0]=5,r[1]=0,e}}e.Null=m;class A extends(n(f)){constructor(t={}){super(t),this.isConstructed=(0,je.getParametersValue)(t,"isConstructed",!1)}fromBER(t,e,r){let i=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,i=f.prototype.fromBER.call(this,t,e,r),-1===i)return i;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===y.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(e!==b.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,i=super.fromBER(t,e,r),this.blockLength=r;return i}toBER(t=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,t);let e=new ArrayBuffer(this.valueHex.byteLength);return!0===t||0===this.valueHex.byteLength||(e=this.valueHex.slice(0)),e}static blockName(){return"OctetStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=(0,je.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class b extends c{constructor(t={}){super(t,A),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(t,e,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),e):super.fromBER(t,e,r)}static blockName(){return"OctetString"}isEqual(t){return t instanceof b!=0&&JSON.stringify(this)===JSON.stringify(t)}}e.OctetString=b;class B extends(n(f)){constructor(t={}){super(t),this.unusedBits=(0,je.getParametersValue)(t,"unusedBits",0),this.isConstructed=(0,je.getParametersValue)(t,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(t,e,r){if(0===r)return e;let i=-1;if(!0===this.isConstructed){if(i=f.prototype.fromBER.call(this,t,e,r),-1===i)return i;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===y.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(e!==S.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[t].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[t].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return i}if(!1===(0,je.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);if(this.unusedBits=n[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(n.length-1);const s=new Uint8Array(this.valueHex);for(let o=0;o<r-1;o++)s[o]=n[o+1];return this.blockLength=n.length,e+r}toBER(t=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,t);if(!0===t)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const e=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),i=new Uint8Array(r);i[0]=this.unusedBits;for(let n=0;n<this.valueHex.byteLength;n++)i[n+1]=e[n];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.unusedBits=this.unusedBits,t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=(0,je.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class S extends c{constructor(t={}){super(t,B),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(t,e,r){return 0===r?e:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(t,e,r))}isEqual(t){return t instanceof S!=0&&JSON.stringify(this)===JSON.stringify(t)}}e.BitString=S;class k extends(n(a)){constructor(t={}){super(t),"value"in t&&(this.valueDec=t.value)}set valueHex(t){this._valueHex=t.slice(0),t.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,t.byteLength>0&&(this._valueDec=je.utilDecodeTC.call(this)))}get valueHex(){return this._valueHex}set valueDec(t){this._valueDec=t,this.isHexOnly=!1,this._valueHex=(0,je.utilEncodeTC)(t)}get valueDec(){return this._valueDec}fromDER(t,e,r,i=0){const n=this.fromBER(t,e,r);if(-1===n)return n;const s=new Uint8Array(this._valueHex);if(0===s[0]&&0!=(128&s[1])){const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}else if(0!==i&&this._valueHex.byteLength<i){i-this._valueHex.byteLength>1&&(i=this._valueHex.byteLength+1);const t=new ArrayBuffer(i);new Uint8Array(t).set(s,i-this._valueHex.byteLength),this._valueHex=t.slice(0)}return n}toDER(t=!1){const e=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&e[0]):{const t=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(t);r[0]=0,r.set(e,1),this._valueHex=t.slice(0)}break;case 0===e[0]&&0==(128&e[1]):{const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}}return this.toBER(t)}fromBER(t,e,r){const i=super.fromBER(t,e,r);return-1===i?i:(this.blockLength=r,e+r)}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}toString(){function t(t,e){const r=new Uint8Array([0]);let i=new Uint8Array(t),n=new Uint8Array(e),s=i.slice(0);const o=s.length-1;let a=n.slice(0);const c=a.length-1;let u=0,h=0;for(let f=c<o?o:c;f>=0;f--,h++){switch(!0){case h<a.length:u=s[o-h]+a[c-h]+r[0];break;default:u=s[o-h]+r[0]}switch(r[0]=u/10,!0){case h>=s.length:s=(0,je.utilConcatView)(new Uint8Array([u%10]),s);break;default:s[o-h]=u%10}}return r[0]>0&&(s=(0,je.utilConcatView)(r,s)),s.slice(0)}function e(t){if(t>=r.length)for(let e=r.length;e<=t;e++){const t=new Uint8Array([0]);let i=r[e-1].slice(0);for(let e=i.length-1;e>=0;e--){const r=new Uint8Array([(i[e]<<1)+t[0]]);t[0]=r[0]/10,i[e]=r[0]%10}t[0]>0&&(i=(0,je.utilConcatView)(t,i)),r.push(i)}return r[t]}function i(t,e){let r=0,i=new Uint8Array(t),n=new Uint8Array(e),s=i.slice(0);const o=s.length-1;let a=n.slice(0);const c=a.length-1;let u,h=0;for(let f=c;f>=0;f--,h++)switch(u=s[o-h]-a[c-h]-r,!0){case u<0:r=1,s[o-h]=u+10;break;default:r=0,s[o-h]=u}if(r>0)for(let f=o-c+1;f>=0;f--,h++){if(u=s[o-h]-r,!(u<0)){r=0,s[o-h]=u;break}r=1,s[o-h]=u+10}return s.slice()}const n=8*this._valueHex.byteLength-1;let s,o=new Uint8Array(8*this._valueHex.byteLength/3),a=0;const c=new Uint8Array(this._valueHex);let u="",h=!1;for(let r=this._valueHex.byteLength-1;r>=0;r--){s=c[r];for(let r=0;r<8;r++){if(1==(1&s))switch(a){case n:o=i(e(a),o),u="-";break;default:o=t(o,e(a))}a++,s>>=1}}for(let r=0;r<o.length;r++)o[r]&&(h=!0),h&&(u+="0123456789".charAt(o[r]));return!1===h&&(u+="0123456789".charAt(0)),u}}class E extends c{constructor(t={}){super(t,k),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(t){return t instanceof E?this.valueBlock.isHexOnly&&t.valueBlock.isHexOnly?(0,je.isEqualBuffer)(this.valueBlock.valueHex,t.valueBlock.valueHex):this.valueBlock.isHexOnly===t.valueBlock.isHexOnly&&this.valueBlock.valueDec===t.valueBlock.valueDec:t instanceof ArrayBuffer&&(0,je.isEqualBuffer)(this.valueBlock.valueHex,t)}convertToDER(){const t=new E({valueHex:this.valueBlock.valueHex});return t.valueBlock.toDER(),t}convertFromDER(){const t=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,e=new E({valueHex:this.valueBlock.valueHex});return e.valueBlock.fromDER(e.valueBlock.valueHex,0,e.valueBlock.valueHex.byteLength,t),e}}e.Integer=E;class x extends E{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}e.Enumerated=x;class N extends(n(i)){constructor(t={}){super(t),this.valueDec=(0,je.getParametersValue)(t,"valueDec",-1),this.isFirstSid=(0,je.getParametersValue)(t,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===(0,je.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let n=new Uint8Array(this.valueHex);for(let a=0;a<r&&(n[a]=127&i[a],this.blockLength++,0!=(128&i[a]));a++);const s=new ArrayBuffer(this.blockLength),o=new Uint8Array(s);for(let a=0;a<this.blockLength;a++)o[a]=n[a];return this.valueHex=s.slice(0),n=new Uint8Array(this.valueHex),0!=(128&i[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===n[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,je.utilFromBase)(n,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const i=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|i[t];return r[this.blockLength-1]=i[this.blockLength-1],e}const i=(0,je.utilToBase)(this.valueDec,7);if(0===i.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(i.byteLength),!1===t){const t=new Uint8Array(i);r=new Uint8Array(e);for(let e=0;e<i.byteLength-1;e++)r[e]=128|t[e];r[i.byteLength-1]=t[i.byteLength-1]}return e}toString(){let t="";if(!0===this.isHexOnly)t=(0,je.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let e=this.valueDec;this.valueDec<=39?t="0.":this.valueDec<=79?(t="1.",e-=40):(t="2.",e-=80),t+=e.toString()}else t=this.valueDec.toString();return t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t.isFirstSid=this.isFirstSid,t}}class U extends a{constructor(t={}){super(t),this.fromString((0,je.getParametersValue)(t,"value",""))}fromBER(t,e,r){let i=e;for(;r>0;){const e=new N;if(i=e.fromBER(t,i,r),-1===i)return this.blockLength=0,this.error=e.error,i;0===this.value.length&&(e.isFirstSid=!0),this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return i}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const i=this.value[r].toBER(t);if(0===i.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=(0,je.utilConcatBuf)(e,i)}return e}fromString(t){this.value=[];let e=0,r=0,i="",n=!1;do{if(r=t.indexOf(".",e),i=-1===r?t.substr(e):t.substr(e,r-e),e=r+1,n){const t=this.value[0];let e=0;switch(t.valueDec){case 0:break;case 1:e=40;break;case 2:e=80;break;default:return this.value=[],!1}const r=parseInt(i,10);if(isNaN(r))return!0;t.valueDec=r+e,n=!1}else{const t=new N;if(t.valueDec=parseInt(i,10),isNaN(t.valueDec))return!0;0===this.value.length&&(t.isFirstSid=!0,n=!0),this.value.push(t)}}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let i=this.value[r].toString();0!==r&&(t+="."),e?(i=`{${i}}`,this.value[r].isFirstSid?t=`2.{${i} - 80}`:t+=i):t+=i}return t}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class C extends c{constructor(t={}){super(t,U),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}e.ObjectIdentifier=C;class I extends(n(i)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class O extends c{constructor(t={}){super(t,I),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(t){const e=unescape(encodeURIComponent(t)),r=e.length;this.valueBlock.valueHex=new ArrayBuffer(r);const i=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<r;n++)i[n]=e.charCodeAt(n);this.valueBlock.value=t}}e.Utf8String=O;class q extends(n(i)){constructor(t={}){super(t),this.valueDec=(0,je.getParametersValue)(t,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===(0,je.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let n=new Uint8Array(this.valueHex);for(let a=0;a<r&&(n[a]=127&i[a],this.blockLength++,0!=(128&i[a]));a++);const s=new ArrayBuffer(this.blockLength),o=new Uint8Array(s);for(let a=0;a<this.blockLength;a++)o[a]=n[a];return this.valueHex=s.slice(0),n=new Uint8Array(this.valueHex),0!=(128&i[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===n[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,je.utilFromBase)(n,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const i=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|i[t];return r[this.blockLength-1]=i[this.blockLength-1],e}const i=(0,je.utilToBase)(this.valueDec,7);if(0===i.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(i.byteLength),!1===t){const t=new Uint8Array(i);r=new Uint8Array(e);for(let e=0;e<i.byteLength-1;e++)r[e]=128|t[e];r[i.byteLength-1]=t[i.byteLength-1]}return e}toString(){let t="";return t=!0===this.isHexOnly?(0,je.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength):this.valueDec.toString(),t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}}class R extends a{constructor(t={}){super(t),this.fromString((0,je.getParametersValue)(t,"value",""))}fromBER(t,e,r){let i=e;for(;r>0;){const e=new q;if(i=e.fromBER(t,i,r),-1===i)return this.blockLength=0,this.error=e.error,i;this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return i}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const i=this.value[r].toBER(t);if(0===i.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=(0,je.utilConcatBuf)(e,i)}return e}fromString(t){this.value=[];let e=0,r=0,i="";do{r=t.indexOf(".",e),i=-1===r?t.substr(e):t.substr(e,r-e),e=r+1;const n=new q;if(n.valueDec=parseInt(i,10),isNaN(n.valueDec))return!0;this.value.push(n)}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let i=this.value[r].toString();0!==r&&(t+="."),e?(i=`{${i}}`,t+=i):t+=i}return t}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class T extends c{constructor(t={}){super(t,R),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}e.RelativeObjectIdentifier=T;class K extends(n(i)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class D extends c{constructor(t={}){super(t,K),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let i=0;i<r.length;i+=2){const t=r[i];r[i]=r[i+1],r[i+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(2*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e;i++){const e=(0,je.utilToBase)(t.charCodeAt(i),8),n=new Uint8Array(e);if(n.length>2)continue;const s=2-n.length;for(let t=n.length-1;t>=0;t--)r[2*i+t+s]=n[t]}this.valueBlock.value=t}}e.BmpString=D;class j extends(n(i)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class P extends c{constructor(t={}){super(t,j),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let i=0;i<r.length;i+=4)r[i]=r[i+3],r[i+1]=r[i+2],r[i+2]=0,r[i+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(4*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e;i++){const e=(0,je.utilToBase)(t.charCodeAt(i),8),n=new Uint8Array(e);if(n.length>4)continue;const s=4-n.length;for(let t=n.length-1;t>=0;t--)r[4*i+t+s]=n[t]}this.valueBlock.value=t}}e.UniversalString=P;class $ extends(n(i)){constructor(t={}){super(t),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class J extends c{constructor(t={}){super(t,$),"value"in t&&this.fromString(t.value)}static blockName(){return"SIMPLESTRING"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(e);const r=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e;i++)r[i]=t.charCodeAt(i);this.valueBlock.value=t}}class V extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}e.NumericString=V;class M extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}e.PrintableString=M;class _ extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}e.TeletexString=_;class H extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}e.VideotexString=H;class W extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}e.IA5String=W;class G extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}e.GraphicString=G;class L extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}e.VisibleString=L;class z extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}e.GeneralString=z;class F extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}e.CharacterString=F;class Z extends L{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(t){const e=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(t);if(null===e)return void(this.error="Wrong input string for convertion");const r=parseInt(e[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(e[2],10),this.day=parseInt(e[3],10),this.hour=parseInt(e[4],10),this.minute=parseInt(e[5],10),this.second=parseInt(e[6],10)}toString(){const t=new Array(7);return t[0]=(0,je.padNumber)(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=(0,je.padNumber)(this.month,2),t[2]=(0,je.padNumber)(this.day,2),t[3]=(0,je.padNumber)(this.hour,2),t[4]=(0,je.padNumber)(this.minute,2),t[5]=(0,je.padNumber)(this.second,2),t[6]="Z",t.join("")}static blockName(){return"UTCTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t}}e.UTCTime=Z;class X extends L{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(t){let e,r=!1,i="",n="",s=0,o=0,a=0;if("Z"===t[t.length-1])i=t.substr(0,t.length-1),r=!0;else{const e=new Number(t[t.length-1]);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");i=t}if(r){if(-1!==i.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==i.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let t=1,e=i.indexOf("+"),r="";if(-1===e&&(e=i.indexOf("-"),t=-1),-1!==e){if(r=i.substr(e+1),i=i.substr(0,e),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let n=new Number(r.substr(0,2));if(isNaN(n.valueOf()))throw new Error("Wrong input string for convertion");if(o=t*n,4===r.length){if(n=new Number(r.substr(2,2)),isNaN(n.valueOf()))throw new Error("Wrong input string for convertion");a=t*n}}}let c=i.indexOf(".");if(-1===c&&(c=i.indexOf(",")),-1!==c){const t=new Number("0"+i.substr(c));if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=t.valueOf(),n=i.substr(0,c)}else n=i;switch(!0){case 8===n.length:if(e=/(\d{4})(\d{2})(\d{2})/gi,-1!==c)throw new Error("Wrong input string for convertion");break;case 10===n.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let t=60*s;this.minute=Math.floor(t),t=60*(t-this.minute),this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 12===n.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let t=60*s;this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 14===n.length:e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c&&(this.millisecond=Math.floor(1e3*s));break;default:throw new Error("Wrong input string for convertion")}const u=e.exec(n);if(null===u)throw new Error("Wrong input string for convertion");for(let h=1;h<u.length;h++)switch(h){case 1:this.year=parseInt(u[h],10);break;case 2:this.month=parseInt(u[h],10);break;case 3:this.day=parseInt(u[h],10);break;case 4:this.hour=parseInt(u[h],10)+o;break;case 5:this.minute=parseInt(u[h],10)+a;break;case 6:this.second=parseInt(u[h],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const t=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=t.getUTCFullYear(),this.month=t.getUTCMonth(),this.day=t.getUTCDay(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}}toString(){const t=[];return t.push((0,je.padNumber)(this.year,4)),t.push((0,je.padNumber)(this.month,2)),t.push((0,je.padNumber)(this.day,2)),t.push((0,je.padNumber)(this.hour,2)),t.push((0,je.padNumber)(this.minute,2)),t.push((0,je.padNumber)(this.second,2)),0!==this.millisecond&&(t.push("."),t.push((0,je.padNumber)(this.millisecond,3))),t.push("Z"),t.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t.millisecond=this.millisecond,t}}e.GeneralizedTime=X;class Q extends O{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}e.DATE=Q;class Y extends O{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}e.TimeOfDay=Y;class tt extends O{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}e.DateTime=tt;class et extends O{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}e.Duration=et;class rt extends O{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}e.TIME=rt;class it{constructor(t={}){this.value=(0,je.getParametersValue)(t,"value",[]),this.optional=(0,je.getParametersValue)(t,"optional",!1)}}e.Choice=it;class nt{constructor(t={}){this.name=(0,je.getParametersValue)(t,"name",""),this.optional=(0,je.getParametersValue)(t,"optional",!1)}}e.Any=nt;class st{constructor(t={}){this.name=(0,je.getParametersValue)(t,"name",""),this.optional=(0,je.getParametersValue)(t,"optional",!1),this.value=(0,je.getParametersValue)(t,"value",new nt),this.local=(0,je.getParametersValue)(t,"local",!1)}}function ot(t,e,r){const n=e;let s=new c({},Object);const o=new i;if(!1===(0,je.checkBufferParams)(o,t,e,r))return s.error=o.error,{offset:-1,result:s};if(0===new Uint8Array(t,e,r).length)return this.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(t,e,r);if(s.warnings.concat(s.idBlock.warnings),-1===a)return s.error=s.idBlock.error,{offset:-1,result:s};if(a=s.lenBlock.fromBER(t,e=a,r-=s.idBlock.blockLength),s.warnings.concat(s.lenBlock.warnings),-1===a)return s.error=s.lenBlock.error,{offset:-1,result:s};if(e=a,r-=s.lenBlock.blockLength,!1===s.idBlock.isConstructed&&!0===s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let u=c;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&!1===s.idBlock.isHexOnly)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(!0===s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};u=y;break;case 1:u=v;break;case 2:u=E;break;case 3:u=S;break;case 4:u=b;break;case 5:u=m;break;case 6:u=C;break;case 10:u=x;break;case 12:u=O;break;case 13:u=T;break;case 14:u=rt;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:u=p;break;case 17:u=g;break;case 18:u=V;break;case 19:u=M;break;case 20:u=_;break;case 21:u=H;break;case 22:u=W;break;case 23:u=Z;break;case 24:u=X;break;case 25:u=G;break;case 26:u=L;break;case 27:u=z;break;case 28:u=P;break;case 29:u=F;break;case 30:u=D;break;case 31:u=Q;break;case 32:u=Y;break;case 33:u=tt;break;case 34:u=et;break;default:{let i;i=!0===s.idBlock.isConstructed?new l:new h,i.idBlock=s.idBlock,i.lenBlock=s.lenBlock,i.warnings=s.warnings,s=i,a=s.fromBER(t,e,r)}}break;case 2:case 3:case 4:default:u=!0===s.idBlock.isConstructed?l:h}return s=function(t,e){if(t instanceof e)return t;const r=new e;return r.idBlock=t.idBlock,r.lenBlock=t.lenBlock,r.warnings=t.warnings,r.valueBeforeDecode=t.valueBeforeDecode.slice(0),r}(s,u),a=s.fromBER(t,e,!0===s.lenBlock.isIndefiniteForm?r:s.lenBlock.length),s.valueBeforeDecode=t.slice(n,n+s.blockLength),{offset:a,result:s}}function at(t){if(0===t.byteLength){const t=new c({},Object);return t.error="Input buffer has zero length",{offset:-1,result:t}}return ot(t,0,t.byteLength)}function ct(t,e,r){if(r instanceof it){for(let i=0;i<r.value.length;i++)if(!0===ct(t,e,r.value[i]).verified)return{verified:!0,result:t};{const t={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(t.name=r.name),t}}if(r instanceof nt)return r.hasOwnProperty("name")&&(t[r.name]=e),{verified:!0,result:t};if(t instanceof Object==0)return{verified:!1,result:{error:"Wrong root object"}};if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const i=r.idBlock.toBER(!1);if(0===i.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(i,0,i.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:t};if("isHexOnly"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:t};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const i=new Uint8Array(r.idBlock.valueHex),n=new Uint8Array(e.idBlock.valueHex);if(i.length!==n.length)return{verified:!1,result:t};for(let e=0;e<i.length;e++)if(i[e]!==n[1])return{verified:!1,result:t}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(t[r.name]=e)),!0===r.idBlock.isConstructed){let i=0,n={verified:!1},s=r.valueBlock.value.length;if(s>0&&r.valueBlock.value[0]instanceof st&&(s=e.valueBlock.value.length),0===s)return{verified:!0,result:t};if(0===e.valueBlock.value.length&&0!==r.valueBlock.value.length){let e=!0;for(let t=0;t<r.valueBlock.value.length;t++)e=e&&(r.valueBlock.value[t].optional||!1);return!0===e?{verified:!0,result:t}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),t.error="Inconsistent object length",{verified:!1,result:t})}for(let o=0;o<s;o++)if(o-i>=e.valueBlock.value.length){if(!1===r.valueBlock.value[o].optional){const e={verified:!1,result:t};return t.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}}else if(r.valueBlock.value[0]instanceof st){if(n=ct(t,e.valueBlock.value[o],r.valueBlock.value[0].value),!1===n.verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),n;i++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let i={};i="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?e:t,void 0===i[r.valueBlock.value[0].name]&&(i[r.valueBlock.value[0].name]=[]),i[r.valueBlock.value[0].name].push(e.valueBlock.value[o])}}else if(n=ct(t,e.valueBlock.value[o-i],r.valueBlock.value[o]),!1===n.verified){if(!0!==r.valueBlock.value[o].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),n;i++}if(!1===n.verified){const e={verified:!1,result:t};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return{verified:!0,result:t}}if("primitiveSchema"in r&&"valueHex"in e.valueBlock){const i=at(e.valueBlock.valueHex);if(-1===i.offset){const e={verified:!1,result:i.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return ct(t,i.result,r.primitiveSchema)}return{verified:!0,result:t}}e.Repeated=st,e.RawData=class{constructor(t={}){this.data=(0,je.getParametersValue)(t,"data",new ArrayBuffer(0))}fromBER(t,e,r){return this.data=t.slice(e,r),e+r}toBER(t=!1){return this.data}}})),$e=(De=Pe)&&De.__esModule&&Object.prototype.hasOwnProperty.call(De,"default")?De.default:De,Je=Pe.fromBER,Ve=Pe.Repeated,Me=Pe.Any,_e=Pe.Choice,He=Pe.GeneralizedTime,We=Pe.UTCTime,Ge=Pe.CharacterString,Le=Pe.GeneralString,ze=Pe.VisibleString,Fe=Pe.GraphicString,Ze=Pe.IA5String,Xe=Pe.VideotexString,Qe=Pe.TeletexString,Ye=Pe.PrintableString,tr=Pe.NumericString,er=Pe.UniversalString,rr=Pe.BmpString,ir=Pe.Utf8String,nr=Pe.ObjectIdentifier,sr=Pe.Enumerated,or=Pe.Integer,ar=Pe.BitString,cr=Pe.OctetString,ur=Pe.Null,hr=Pe.Set,fr=Pe.Sequence,lr=Pe.Boolean,dr=Pe.Constructed,yr=Pe.Primitive,wr=Pe.BaseBlock,vr=Object.freeze({__proto__:null,default:$e,__moduleExports:Pe,fromBER:Je,compareSchema:Pe.compareSchema,verifySchema:Pe.verifySchema,fromJSON:Pe.fromJSON,RawData:Pe.RawData,Repeated:Ve,Any:Me,Choice:_e,TIME:Pe.TIME,Duration:Pe.Duration,DateTime:Pe.DateTime,TimeOfDay:Pe.TimeOfDay,DATE:Pe.DATE,GeneralizedTime:He,UTCTime:We,CharacterString:Ge,GeneralString:Le,VisibleString:ze,GraphicString:Fe,IA5String:Ze,VideotexString:Xe,TeletexString:Qe,PrintableString:Ye,NumericString:tr,UniversalString:er,BmpString:rr,RelativeObjectIdentifier:Pe.RelativeObjectIdentifier,Utf8String:ir,ObjectIdentifier:nr,Enumerated:sr,Integer:or,BitString:ar,OctetString:cr,Null:ur,Set:hr,Sequence:fr,Boolean:lr,EndOfContent:Pe.EndOfContent,Constructed:dr,Primitive:yr,BaseBlock:wr,ValueBlock:Pe.ValueBlock,HexBlock:Pe.HexBlock});const pr={fromASN:t=>t instanceof ur?null:t.valueBeforeDecode,toASN:t=>{if(null===t)return new ur;const e=Je(t);if(e.result.error)throw new Error(e.result.error);return e.result}},gr={fromASN:t=>!t.valueBlock.valueDec&&t.valueBlock.valueHex.byteLength>0?t.valueBlock.toString():t.valueBlock.valueDec,toASN:t=>new or({value:t})},mr={fromASN:t=>t.valueBlock.valueDec,toASN:t=>new sr({value:t})},Ar={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new or({valueHex:t})},br={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new ar({valueHex:t})},Br={fromASN:t=>t.valueBlock.toString(),toASN:t=>new nr({value:t})},Sr={fromASN:t=>t.valueBlock.value,toASN:t=>new lr({value:t})},kr={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new cr({valueHex:t})};function Er(t){return{fromASN:t=>t.valueBlock.value,toASN:e=>new t({value:e})}}const xr=Er(ir),Nr=Er(rr),Ur=Er(er),Cr=Er(tr),Ir=Er(Ye),Or=Er(Qe),qr=Er(Xe),Rr=Er(Ze),Tr=Er(Fe),Kr=Er(ze),Dr=Er(Le),jr=Er(Ge);var Pr,$r,Jr=Object.freeze({__proto__:null,AsnAnyConverter:pr,AsnIntegerConverter:gr,AsnEnumeratedConverter:mr,AsnIntegerArrayBufferConverter:Ar,AsnBitStringConverter:br,AsnObjectIdentifierConverter:Br,AsnBooleanConverter:Sr,AsnOctetStringConverter:kr,AsnUtf8StringConverter:xr,AsnBmpStringConverter:Nr,AsnUniversalStringConverter:Ur,AsnNumericStringConverter:Cr,AsnPrintableStringConverter:Ir,AsnTeletexStringConverter:Or,AsnVideotexStringConverter:qr,AsnIA5StringConverter:Rr,AsnGraphicStringConverter:Tr,AsnVisibleStringConverter:Kr,AsnGeneralStringConverter:Dr,AsnCharacterStringConverter:jr,AsnUTCTimeConverter:{fromASN:t=>t.toDate(),toASN:t=>new We({valueDate:t})},AsnGeneralizedTimeConverter:{fromASN:t=>t.toDate(),toASN:t=>new He({valueDate:t})},AsnNullConverter:{fromASN:()=>null,toASN:()=>new ur}});function Vr(t){return t&&t.prototype?!(!t.prototype.toASN||!t.prototype.fromASN)||Vr(t.prototype):!!(t&&t.toASN&&t.fromASN)}function Mr(t,e){if(!t||!e)return!1;if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),i=new Uint8Array(e);for(let n=0;n<t.byteLength;n++)if(r[n]!==i[n])return!1;return!0}!function(t){t[t.Sequence=0]="Sequence",t[t.Set=1]="Set",t[t.Choice=2]="Choice"}(Pr||(Pr={})),function(t){t[t.Any=1]="Any",t[t.Boolean=2]="Boolean",t[t.OctetString=3]="OctetString",t[t.BitString=4]="BitString",t[t.Integer=5]="Integer",t[t.Enumerated=6]="Enumerated",t[t.ObjectIdentifier=7]="ObjectIdentifier",t[t.Utf8String=8]="Utf8String",t[t.BmpString=9]="BmpString",t[t.UniversalString=10]="UniversalString",t[t.NumericString=11]="NumericString",t[t.PrintableString=12]="PrintableString",t[t.TeletexString=13]="TeletexString",t[t.VideotexString=14]="VideotexString",t[t.IA5String=15]="IA5String",t[t.GraphicString=16]="GraphicString",t[t.VisibleString=17]="VisibleString",t[t.GeneralString=18]="GeneralString",t[t.CharacterString=19]="CharacterString",t[t.UTCTime=20]="UTCTime",t[t.GeneralizedTime=21]="GeneralizedTime",t[t.DATE=22]="DATE",t[t.TimeOfDay=23]="TimeOfDay",t[t.DateTime=24]="DateTime",t[t.Duration=25]="Duration",t[t.TIME=26]="TIME",t[t.Null=27]="Null"}($r||($r={}));const _r=new class{constructor(){this.items=new WeakMap}has(t){return this.items.has(t)}get(t){var e,r,i,n;const s=this.items.get(t);if(!s)throw new Error(`Cannot get schema for '${null!==(n=null===(i=null===(r=null===(e=t)||void 0===e?void 0:e.prototype)||void 0===r?void 0:r.constructor)||void 0===i?void 0:i.name)&&void 0!==n?n:t}' target`);return s}cache(t){const e=this.get(t);e.schema||(e.schema=this.create(t,!0))}createDefault(t){const e={type:Pr.Sequence,items:{}},r=this.findParentSchema(t);return r&&(Object.assign(e,r),e.items=Object.assign({},e.items,r.items)),e}create(t,e){const r=this.items.get(t)||this.createDefault(t),i=[];for(const n in r.items){const t=r.items[n],s=e?n:"";let o;if("number"==typeof t.type){const e=$r[t.type],r=vr[e];if(!r)throw new Error(`Cannot get ASN1 class by name '${e}'`);o=new r({name:s})}else o=Vr(t.type)?(new t.type).toSchema(s):new Me({name:s});const a=!!t.optional||void 0!==t.defaultValue;if(t.repeated&&(o.name="",o=new("set"===t.repeated?hr:fr)({name:"",value:[new Ve({name:s,value:o})]})),null!=t.context)if(t.implicit)if("number"==typeof t.type||Vr(t.type))i.push(new(t.repeated?dr:yr)({name:s,optional:a,idBlock:{tagClass:3,tagNumber:t.context}}));else{this.cache(t.type);const e=!!t.repeated;let r=e?o:this.get(t.type).schema;r=r.valueBlock?r.valueBlock.value:r.value,i.push(new dr({name:e?"":s,optional:a,idBlock:{tagClass:3,tagNumber:t.context},value:r}))}else i.push(new dr({optional:a,idBlock:{tagClass:3,tagNumber:t.context},value:[o]}));else o.optional=a,i.push(o)}switch(r.type){case Pr.Sequence:return new fr({value:i,name:""});case Pr.Set:return new hr({value:i,name:""});case Pr.Choice:return new _e({value:i,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(t,e){return this.items.set(t,e),this}findParentSchema(t){const e=t.__proto__;return e?this.items.get(e)||this.findParentSchema(e):null}},Hr=t=>e=>{let r;_r.has(e)?r=_r.get(e):(r=_r.createDefault(e),_r.set(e,r)),Object.assign(r,t)},Wr=t=>(e,r)=>{let i;_r.has(e.constructor)?i=_r.get(e.constructor):(i=_r.createDefault(e.constructor),_r.set(e.constructor,i));const n=Object.assign({},t);if("number"==typeof n.type&&!n.converter){const i=`Asn${$r[t.type]}Converter`,s=Jr[i];if(!s)throw new Error(`Cannot get '${i}' for property '${r}' of ${e.constructor.name}`);n.converter=s}i.items[r]=n};class Gr{static serialize(t){return t instanceof wr?t.toBER(!1):this.toASN(t).toBER(!1)}static toASN(t){if(t&&Vr(t.constructor))return t.toASN();const e=t.constructor,r=_r.get(e);_r.cache(e);let i,n=[];if(r.itemType)n=t.map(t=>this.toAsnItem({type:r.itemType},"[]",e,t));else for(const s in r.items){const i=r.items[s],o=t[s];if(void 0===o||i.defaultValue===o||"object"==typeof i.defaultValue&&"object"==typeof o&&Mr(this.serialize(i.defaultValue),this.serialize(o)))continue;let a=Gr.toAsnItem(i,s,e,o);if("number"==typeof i.context)if(i.implicit)if(i.repeated||"number"!=typeof i.type&&!Vr(i.type))n.push(new dr({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:a.valueBlock.value}));else{const t={};t.valueHex=a.valueBlock.toBER(),n.push(new yr(Object.assign({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context}},t)))}else n.push(new dr({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:[a]}));else i.repeated?n=n.concat(a):n.push(a)}switch(r.type){case Pr.Sequence:i=new fr({value:n});break;case Pr.Set:i=new hr({value:n});break;case Pr.Choice:if(!n[0])throw new Error(`Schema '${e.name}' has wrong data. Choice cannot be empty.`);i=n[0]}return i}static toAsnItem(t,e,r,i){let n;if("number"==typeof t.type){const s=t.converter;if(!s)throw new Error(`Property '${e}' doesn't have converter for type ${$r[t.type]} in schema '${r.name}'`);if(t.repeated){const e=Array.from(i,t=>s.toASN(t));n=new("sequence"===t.repeated?fr:hr)({value:e})}else n=s.toASN(i)}else if(t.repeated){const e=Array.from(i,t=>this.toASN(t));n=new("sequence"===t.repeated?fr:hr)({value:e})}else n=this.toASN(i);return n}}class Lr extends Error{constructor(t,e){super(e?t+". See the inner exception for more details.":t),this.message=t,this.innerError=e}}class zr extends Lr{}var Fr;function Zr(t,e){if(!function(t,e){switch(e){case Fr.Boolean:return"boolean"==typeof t;case Fr.Number:return"number"==typeof t;case Fr.String:return"string"==typeof t}return!0}(t,e))throw new TypeError("Value must be "+Fr[e])}!function(t){t[t.Any=0]="Any",t[t.Boolean=1]="Boolean",t[t.Number=2]="Number",t[t.String=3]="String"}(Fr||(Fr={}));const Xr=new class{constructor(){this.items=new Map}has(t){return this.items.has(t)||!!this.findParentSchema(t)}get(t){const e=this.items.get(t)||this.findParentSchema(t);if(!e)throw new Error("Cannot get schema for current target");return e}create(t){const e={names:{}},r=this.findParentSchema(t);if(r){Object.assign(e,r),e.names={};for(const t in r.names)e.names[t]=Object.assign({},r.names[t])}return e.target=t,e}set(t,e){return this.items.set(t,e),this}findParentSchema(t){const e=t.__proto__;return e?this.items.get(e)||this.findParentSchema(e):null}};class Qr{constructor(t){this.pattern=new RegExp(t)}validate(t){const e=new RegExp(this.pattern.source,this.pattern.flags);if("string"!=typeof t)throw new zr("Incoming value must be string");if(!e.exec(t))throw new zr(`Value doesn't match to pattern '${e.toString()}'`)}}class Yr{constructor(t=Number.MIN_VALUE,e=Number.MAX_VALUE){this.min=t,this.max=e}validate(t){if(Zr(t,Fr.Number),!(this.min<=t&&t<=this.max))throw new zr(`Value doesn't match to diapason [${this.min===Number.MIN_VALUE?"MIN":this.min},${this.max===Number.MAX_VALUE?"MAX":this.max}]`)}}class ti{constructor(t=Number.MIN_VALUE,e=Number.MAX_VALUE){this.min=t,this.max=e}validate(t){if(Zr(t,Fr.Number),!(this.min<t&&t<this.max))throw new zr(`Value doesn't match to diapason (${this.min===Number.MIN_VALUE?"MIN":this.min},${this.max===Number.MAX_VALUE?"MAX":this.max})`)}}class ei{constructor(t,e,r){this.length=t,this.minLength=e,this.maxLength=r}validate(t){if(void 0===this.length){if(void 0!==this.minLength&&t.length<this.minLength)throw new zr(`Value length must be more than ${this.minLength}.`);if(void 0!==this.maxLength&&t.length>this.maxLength)throw new zr(`Value length must be less than ${this.maxLength}.`)}else if(t.length!==this.length)throw new zr(`Value length must be exactly ${this.length}.`)}}class ri{constructor(t){this.enumeration=t}validate(t){if(Zr(t,Fr.String),!this.enumeration.includes(t))throw new zr("Value must be one of "+this.enumeration.map(t=>`'${t}'`).join(", "))}}const ii=(t={})=>(e,r)=>{const i=`Cannot set type for ${r} property of ${e.constructor.name} schema`;let n;Xr.has(e.constructor)?(n=Xr.get(e.constructor),n.target!==e.constructor&&(n=Xr.create(e.constructor),Xr.set(e.constructor,n))):(n=Xr.create(e.constructor),Xr.set(e.constructor,n));const s=Object.assign({type:Fr.Any,validations:[]},t);if(s.validations=function(t){const e=[];return t.pattern&&e.push(new Qr(t.pattern)),t.type!==Fr.Number&&t.type!==Fr.Any||(void 0===t.minInclusive&&void 0===t.maxInclusive||e.push(new Yr(t.minInclusive,t.maxInclusive)),void 0===t.minExclusive&&void 0===t.maxExclusive||e.push(new ti(t.minExclusive,t.maxExclusive)),void 0!==t.enumeration&&e.push(new ri(t.enumeration))),(t.type===Fr.String||t.repeated||t.type===Fr.Any)&&(void 0===t.length&&void 0===t.minLength&&void 0===t.maxLength||e.push(new ei(t.length,t.minLength,t.maxLength))),e}(s),"number"!=typeof s.type&&!Xr.has(s.type)&&!function t(e){return e&&e.prototype?!(!e.prototype.toJSON||!e.prototype.fromJSON)||t(e.prototype):!!(e&&e.toJSON&&e.fromJSON)}(s.type))throw new Error(i+". Assigning type doesn't have schema.");let o;o=Array.isArray(t.schema)?t.schema:[t.schema||"default"];for(const t of o)n.names[t]||(n.names[t]={}),n.names[t][r]=s};class ni extends Error{}class si{static toArrayBuffer(t){const e=t.replace(/-{5}(BEGIN|END) .*-{5}/g,"").replace("\r","").replace("\n","");return s.FromBase64(e)}static toUint8Array(t){const e=this.toArrayBuffer(t);return new Uint8Array(e)}static fromBufferSource(t,e){const r=s.ToBase64(t);let i,n=0;const o=[];for(;i=r.slice(n,n+=64),i.length&&(o.push(i),!(i.length<64)););const a=e.toUpperCase();return`-----BEGIN ${a}-----\n${o.join("\n")}\n-----END ${a}-----`}static isPEM(t){return/-----BEGIN .+-----[A-Za-z0-9+\/\+\=\s\n]+-----END .+-----/i.test(t)}static getTagName(t){if(!this.isPEM(t))throw new Error("Bad parameter. Incoming data is not right PEM");const e=/-----BEGIN (.+)-----/.exec(t);if(!e)throw new Error("Cannot get tag from PEM");return e[1]}static hasTagName(t,e){const r=this.getTagName(t);return e.toLowerCase()===r.toLowerCase()}static isCertificate(t){return this.hasTagName(t,"certificate")}static isCertificateRequest(t){return this.hasTagName(t,"certificate request")}static isCRL(t){return this.hasTagName(t,"x509 crl")}static isPublicKey(t){return this.hasTagName(t,"public key")}}let oi=class{constructor(t){t&&(this.value=t)}};Ce([Wr({type:$r.ObjectIdentifier})],oi.prototype,"value",void 0),oi=Ce([Hr({type:Pr.Choice})],oi);class ai{constructor(t){Object.assign(this,t)}}Ce([Wr({type:$r.ObjectIdentifier})],ai.prototype,"algorithm",void 0),Ce([Wr({type:$r.Any,optional:!0})],ai.prototype,"parameters",void 0);class ci{constructor(){this.version=0,this.privateKeyAlgorithm=new ai,this.privateKey=new ArrayBuffer(0)}}Ce([Wr({type:$r.Integer})],ci.prototype,"version",void 0),Ce([Wr({type:ai})],ci.prototype,"privateKeyAlgorithm",void 0),Ce([Wr({type:$r.OctetString})],ci.prototype,"privateKey",void 0),Ce([Wr({type:$r.Any,optional:!0})],ci.prototype,"attributes",void 0);class ui{constructor(){this.publicKeyAlgorithm=new ai,this.publicKey=new ArrayBuffer(0)}}Ce([Wr({type:ai})],ui.prototype,"publicKeyAlgorithm",void 0),Ce([Wr({type:$r.BitString})],ui.prototype,"publicKey",void 0);const hi={fromJSON:t=>s.FromBase64Url(t),toJSON:t=>s.ToBase64Url(new Uint8Array(t))},fi={fromASN:t=>new Uint8Array(t.valueBlock.valueHex)[0]?t.valueBlock.valueHex:t.valueBlock.valueHex.slice(1),toASN:t=>{const e=new Uint8Array(t)[0]>127?Buffer.concat([Buffer.from([0]),Buffer.from(t)]):Buffer.from(t);return new or({valueHex:new Uint8Array(e).buffer})}};var li=Object.freeze({__proto__:null,JsonBase64UrlArrayBufferConverter:hi,AsnIntegerArrayBufferConverter:fi});class di{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}Ce([Wr({type:$r.Integer,converter:gr})],di.prototype,"version",void 0),Ce([Wr({type:$r.Integer,converter:fi}),ii({name:"n",converter:hi})],di.prototype,"modulus",void 0),Ce([Wr({type:$r.Integer,converter:fi}),ii({name:"e",converter:hi})],di.prototype,"publicExponent",void 0),Ce([Wr({type:$r.Integer,converter:fi}),ii({name:"d",converter:hi})],di.prototype,"privateExponent",void 0),Ce([Wr({type:$r.Integer,converter:fi}),ii({name:"p",converter:hi})],di.prototype,"prime1",void 0),Ce([Wr({type:$r.Integer,converter:fi}),ii({name:"q",converter:hi})],di.prototype,"prime2",void 0),Ce([Wr({type:$r.Integer,converter:fi}),ii({name:"dp",converter:hi})],di.prototype,"exponent1",void 0),Ce([Wr({type:$r.Integer,converter:fi}),ii({name:"dq",converter:hi})],di.prototype,"exponent2",void 0),Ce([Wr({type:$r.Integer,converter:fi}),ii({name:"qi",converter:hi})],di.prototype,"coefficient",void 0),Ce([Wr({type:$r.Any,optional:!0})],di.prototype,"otherPrimeInfos",void 0);class yi{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}Ce([Wr({type:$r.Integer,converter:fi}),ii({name:"n",converter:hi})],yi.prototype,"modulus",void 0),Ce([Wr({type:$r.Integer,converter:fi}),ii({name:"e",converter:hi})],yi.prototype,"publicExponent",void 0);let wi=class{constructor(t){this.value=new ArrayBuffer(0),t&&(this.value=t)}toJSON(){let t=new Uint8Array(this.value);if(4!==t[0])throw new ni("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");t=new Uint8Array(this.value.slice(1));const e=t.length/2;return{x:s.ToBase64Url(t.buffer.slice(0,0+e)),y:s.ToBase64Url(t.buffer.slice(0+e,0+e+e))}}fromJSON(t){if(!("x"in t))throw new Error("x: Missing required property");if(!("y"in t))throw new Error("y: Missing required property");const e=s.FromBase64Url(t.x),r=s.FromBase64Url(t.y),i=Buffer.concat([new Uint8Array([4]),new Uint8Array(e),new Uint8Array(r)]);return this.value=new Uint8Array(i).buffer,this}};Ce([Wr({type:$r.OctetString})],wi.prototype,"value",void 0),wi=Ce([Hr({type:Pr.Choice})],wi);class vi{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(t){if(!("d"in t))throw new Error("d: Missing required property");if(this.privateKey=s.FromBase64Url(t.d),"x"in t){const e=new wi;e.fromJSON(t),this.publicKey=Gr.toASN(e).valueBlock.valueHex}return this}toJSON(){const t={};return t.d=s.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(t,new wi(this.publicKey).toJSON()),t}}Ce([Wr({type:$r.Integer,converter:gr})],vi.prototype,"version",void 0),Ce([Wr({type:$r.OctetString})],vi.prototype,"privateKey",void 0),Ce([Wr({context:0,type:$r.Any,optional:!0})],vi.prototype,"parameters",void 0),Ce([Wr({context:1,type:$r.BitString,optional:!0})],vi.prototype,"publicKey",void 0);const pi={fromASN:t=>{const e=new Uint8Array(t.valueBlock.valueHex);return 0===e[0]?e.buffer.slice(1):e.buffer},toASN:t=>{const e=new Uint8Array(t);if(e[0]>127){const t=new Uint8Array(e.length+1);return t.set(e,1),new or({valueHex:t.buffer})}return new or({valueHex:t})}};var gi=Object.freeze({__proto__:null,AsnIntegerWithoutPaddingConverter:pi});class mi{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(t){const e=o.toUint8Array(t),r=e.byteLength/2,i=new this;return i.r=i.removePadding(e.slice(0,r)),i.s=i.removePadding(e.slice(r,2*r)),i}toWebCryptoSignature(t){t=this.getPointSize();const e=this.addPadding(t,o.toUint8Array(this.r)),r=this.addPadding(t,o.toUint8Array(this.s)),i=new Uint8Array(e.byteLength+r.byteLength);return i.set(e,0),i.set(r,e.length),i.buffer}getPointSize(){switch(Math.max(this.r.byteLength,this.s.byteLength)){case 31:case 32:return 32;case 47:case 48:return 48;case 65:case 66:return 66}throw new Error("Unsupported EC point size")}addPadding(t,e){const r=new Uint8Array(t),i=o.toUint8Array(e);return r.set(i,t-i.length),r}removePadding(t){const e=o.toUint8Array(t);for(let r=0;r<e.length;r++)if(e[r])return e.slice(r);return new Uint8Array(0)}}function Ai(t){if(t instanceof ht)return t;const e=new ht;if("string"==typeof t)e.fromAlgorithm({name:t});else if((r=t)instanceof Object&&"name"in r&&"hash"in r){const r=Object.assign({},t);r.hash=Ai(t.hash),e.fromAlgorithm(r)}else e.fromAlgorithm(Object.assign({},t));var r;return e}function bi(t,e){if(!t||"object"!=typeof t&&"string"!=typeof t)throw new TypeError(e+": Is wrong type. Must be Object or String");if("object"==typeof t&&!("name"in t))throw new TypeError(e+": Required property 'name' is missed")}function Bi(t,e){if(!function(t){return t instanceof lt}(t))throw new TypeError(e+": Is not type CryptoKey")}function Si(t,e){if(!function(t){return t instanceof Ut}(t))throw new TypeError(e+": Is not type CryptoCertificate")}function ki(t,e){if(!o.isBufferSource(t))throw new TypeError(e+": Is wrong type. Must be ArrayBuffer or ArrayBuffer view")}function Ei(t,e){if(!Array.isArray(t))throw new TypeError(e+": Is not type Array")}function xi(t,e,r){if(typeof t!==e)throw new TypeError(`${r}: Is not type '${e}'`)}Ce([Wr({type:$r.Integer,converter:pi})],mi.prototype,"r",void 0),Ce([Wr({type:$r.Integer,converter:pi})],mi.prototype,"s",void 0),Object.freeze({__proto__:null,converters:gi,get ObjectIdentifier(){return oi},AlgorithmIdentifier:ai,PrivateKeyInfo:ci,PublicKeyInfo:ui,RsaPrivateKey:di,RsaPublicKey:yi,EcPrivateKey:vi,get EcPublicKey(){return wi},EcDsaSignature:mi}),Object.freeze({__proto__:null,converters:li});const Ni=["raw","pem","x509","request"];class Ui{constructor(t){this.provider=t}static isX509Certificate(t){return t instanceof Ct}static isCertificateRequest(t){return t instanceof It}indexOf(t){return nt(this,void 0,void 0,(function*(){Si(t,"item");const e=new Jt;e.providerID=this.provider.id,e.item=t;const r=yield this.provider.client.send(e);return r?s.ToUtf8String(r):null}))}hasItem(t){return nt(this,void 0,void 0,(function*(){return!!(yield this.indexOf(t))}))}exportCert(t,e){return nt(this,void 0,void 0,(function*(){xi(t,"string","format"),Si(e,"item");const r=new $t;r.providerID=this.provider.id,r.format="raw",r.item=e;const i=yield this.provider.client.send(r);if("raw"===t)return i;{let t="";switch(e.type){case"x509":t="CERTIFICATE";break;case"request":t="CERTIFICATE REQUEST";break;default:throw new Error("Cannot create PEM for unknown type of certificate item")}return si.fromBufferSource(i,t)}}))}importCert(t,e,r,i){return nt(this,void 0,void 0,(function*(){if(xi(t,"string","format"),!~Ni.indexOf(t))throw new TypeError("format: Is invalid value. Must be "+Ni.join(", "));"pem"===t?xi(e,"string","data"):ki(e,"data"),bi(r,"algorithm"),Ei(i,"keyUsages");const n=Ai(r);let s;if(o.isBufferSource(e))s=o.toArrayBuffer(e);else{if("string"!=typeof e)throw new TypeError("data: Is not type String, ArrayBuffer or ArrayBufferView");s=si.toArrayBuffer(e)}const a=new Pt;a.providerID=this.provider.id,a.format="raw",a.data=s,a.algorithm=n,a.keyUsages=i;const c=yield this.provider.client.send(a),u=yield Ut.importProto(c);if(("request"===t||"x509"===t)&&u.type!==t)throw new TypeError("Imported item is not "+t);return this.prepareCertItem(u)}))}keys(){return nt(this,void 0,void 0,(function*(){const t=new Kt;t.providerID=this.provider.id;const e=yield this.provider.client.send(t);return e?s.ToUtf8String(e).split(","):[]}))}getItem(t,e,r){return nt(this,void 0,void 0,(function*(){xi(t,"string","key"),e&&(bi(e,"algorithm"),Ei(r,"keyUsages"));const i=new Tt;i.providerID=this.provider.id,i.key=t,e&&(i.algorithm=Ai(e),i.keyUsages=r);const n=yield this.provider.client.send(i);if(n&&n.byteLength){const t=yield Ut.importProto(n);return this.prepareCertItem(t)}throw new Error("Cannot get CryptoCertificate from storage by index")}))}setItem(t){return nt(this,void 0,void 0,(function*(){Si(t,"value");const e=new Rt;e.providerID=this.provider.id,e.item=t;const r=yield this.provider.client.send(e);return s.ToUtf8String(r)}))}removeItem(t){return nt(this,void 0,void 0,(function*(){xi(t,"string","key");const e=new Dt;e.providerID=this.provider.id,e.key=t,yield this.provider.client.send(e)}))}clear(){return nt(this,void 0,void 0,(function*(){const t=new jt;t.providerID=this.provider.id,yield this.provider.client.send(t)}))}getChain(t){return nt(this,void 0,void 0,(function*(){Si(t,"value");const e=new Vt;e.providerID=this.provider.id,e.item=t;const r=yield this.provider.client.send(e);return(yield qt.importProto(r)).items}))}getCRL(t){return nt(this,void 0,void 0,(function*(){xi(t,"string","url");const e=new Mt;return e.providerID=this.provider.id,e.url=t,yield this.provider.client.send(e)}))}getOCSP(t,e,r){return nt(this,void 0,void 0,(function*(){xi(t,"string","url"),ki(e,"request");const i=new Ht;if(i.providerID=this.provider.id,i.url=t,i.request=o.toArrayBuffer(e),r)for(const t in r)i.options[t]=r[t];return yield this.provider.client.send(i)}))}findPrivateKey(t){return nt(this,void 0,void 0,(function*(){let e="string"==typeof t?t:yield this.provider.certStorage.indexOf(t);e||(e="");const[,,r]=e.split("-"),i=(yield this.provider.keyStorage.keys()).find(t=>{const[e,,i]=t.split("-");return"private"===e&&i===r});return i?yield this.provider.keyStorage.getItem(i):null}))}prepareCertItem(t){return nt(this,void 0,void 0,(function*(){const e=yield t.exportProto();let r;switch(t.type){case"x509":r=yield Ct.importProto(e);break;case"request":r=yield It.importProto(e);break;default:throw new Error(`Unsupported CertificateItem type '${t.type}'`)}return r.provider=this.provider,r}))}}class Ci{constructor(t){this.service=t}keys(){return nt(this,void 0,void 0,(function*(){const t=new Lt;t.providerID=this.service.id;const e=yield this.service.client.send(t);return e?s.ToUtf8String(e).split(","):[]}))}indexOf(t){return nt(this,void 0,void 0,(function*(){Bi(t,"item");const e=new Zt;e.providerID=this.service.id,e.item=t;const r=yield this.service.client.send(e);return r?s.ToUtf8String(r):null}))}hasItem(t){return nt(this,void 0,void 0,(function*(){return!!(yield this.indexOf(t))}))}getItem(t,e,r,i){return nt(this,void 0,void 0,(function*(){xi(t,"string","key"),e&&(bi(e,"algorithm"),xi(r,"boolean","extractable"),Ei(i,"usages"));const n=new Gt;n.providerID=this.service.id,n.key=t,e&&(n.algorithm=Ai(e),n.extractable=r,n.keyUsages=i);const s=yield this.service.client.send(n);let o;if(!s||!s.byteLength)throw new Error("Cannot get CryptoKey from key storage by index");return o=yield lt.importProto(s),o}))}setItem(t){return nt(this,void 0,void 0,(function*(){Bi(t,"value");const e=new Wt;e.providerID=this.service.id,e.item=t;const r=yield this.service.client.send(e);return s.ToUtf8String(r)}))}removeItem(t){return nt(this,void 0,void 0,(function*(){xi(t,"string","key");const e=new zt;e.providerID=this.service.id,e.key=t,yield this.service.client.send(e)}))}clear(){return nt(this,void 0,void 0,(function*(){const t=new Ft;t.providerID=this.service.id,yield this.service.client.send(t)}))}}class Ii{constructor(t){this.service=t}encrypt(t,e,r){return nt(this,void 0,void 0,(function*(){return this.encryptData(t,e,r,"encrypt")}))}decrypt(t,e,r){return nt(this,void 0,void 0,(function*(){return this.encryptData(t,e,r,"decrypt")}))}deriveBits(t,e,r){return nt(this,void 0,void 0,(function*(){bi(t,"algorithm"),Bi(e,"baseKey"),xi(r,"number","length");const i=Ai(t);Bi(i.public,"algorithm.public"),i.public=yield i.public.exportProto();const n=new ce;return n.providerID=this.service.id,n.algorithm=i,n.key=e,n.length=r,yield this.service.client.send(n)}))}deriveKey(t,e,r,i,n){return nt(this,void 0,void 0,(function*(){bi(t,"algorithm"),Bi(e,"baseKey"),bi(r,"algorithm"),xi(i,"boolean","extractable"),Ei(n,"keyUsages");const s=Ai(t);Bi(s.public,"algorithm.public"),s.public=yield s.public.exportProto();const o=Ai(r),a=new ue;a.providerID=this.service.id,a.algorithm=s,a.derivedKeyType.fromAlgorithm(o),a.key=e,a.extractable=i,a.usage=n;const c=yield this.service.client.send(a);return yield lt.importProto(c)}))}digest(t,e){return nt(this,void 0,void 0,(function*(){return O().crypto.subtle.digest(t,e)}))}generateKey(t,e,r){return nt(this,void 0,void 0,(function*(){bi(t,"algorithm"),xi(e,"boolean","extractable"),Ei(r,"keyUsages");const i=Ai(t),n=new ie;n.providerID=this.service.id,n.algorithm=i,n.extractable=e,n.usage=r;const s=yield this.service.client.send(n);try{return yield dt.importProto(s)}catch(o){return yield lt.importProto(s)}}))}exportKey(t,e){return nt(this,void 0,void 0,(function*(){xi(t,"string","format"),Bi(e,"key");const r=new le;r.providerID=this.service.id,r.format=t,r.key=e;const i=yield this.service.client.send(r);return"jwk"===t?JSON.parse(s.ToBinary(i)):i}))}importKey(t,e,r,i,n){return nt(this,void 0,void 0,(function*(){xi(t,"string","format"),bi(r,"algorithm"),xi(i,"boolean","extractable"),Ei(n,"keyUsages");const a=Ai(r);let c;"jwk"===t?c=s.FromUtf8String(JSON.stringify(e)):(ki(e,"keyData"),c=o.toArrayBuffer(e));const u=new de;u.providerID=this.service.id,u.algorithm=a,u.keyData=c,u.format=t,u.extractable=i,u.keyUsages=n;const h=yield this.service.client.send(u);return yield lt.importProto(h)}))}sign(t,e,r){return nt(this,void 0,void 0,(function*(){bi(t,"algorithm"),Bi(e,"key"),ki(r,"data");const i=Ai(t),n=o.toArrayBuffer(r),s=new ne;return s.providerID=this.service.id,s.algorithm=i,s.key=e,s.data=n,yield this.service.client.send(s)}))}verify(t,e,r,i){return nt(this,void 0,void 0,(function*(){bi(t,"algorithm"),Bi(e,"key"),ki(r,"signature"),ki(i,"data");const n=Ai(t),s=o.toArrayBuffer(r),a=o.toArrayBuffer(i),c=new se;c.providerID=this.service.id,c.algorithm=n,c.key=e,c.data=a,c.signature=s;const u=yield this.service.client.send(c);return!!new Uint8Array(u)[0]}))}wrapKey(t,e,r,i){return nt(this,void 0,void 0,(function*(){xi(t,"string","format"),Bi(e,"key"),Bi(r,"wrappingKey"),bi(i,"wrapAlgorithm");const n=Ai(i),s=new fe;return s.providerID=this.service.id,s.wrapAlgorithm=n,s.key=e,s.wrappingKey=r,s.format=t,yield this.service.client.send(s)}))}unwrapKey(t,e,r,i,n,s,a){return nt(this,void 0,void 0,(function*(){xi(t,"string","format"),ki(e,"wrappedKey"),Bi(r,"unwrappingKey"),bi(i,"unwrapAlgorithm"),bi(n,"unwrappedKeyAlgorithm"),xi(s,"boolean","extractable"),Ei(a,"keyUsages");const c=Ai(i),u=Ai(n),h=o.toArrayBuffer(e),f=new he;f.providerID=this.service.id,f.format=t,f.unwrapAlgorithm=c,f.unwrappedKeyAlgorithm=u,f.unwrappingKey=r,f.wrappedKey=h,f.extractable=s,f.keyUsage=a;const l=yield this.service.client.send(f);return yield lt.importProto(l)}))}encryptData(t,e,r,i){return nt(this,void 0,void 0,(function*(){bi(t,"algorithm"),Bi(e,"key"),ki(r,"data");const n=Ai(t),s=o.toArrayBuffer(r);let a;a="encrypt"===i?oe:ae;const c=new a;return c.providerID=this.service.id,c.algorithm=n,c.key=e,c.data=s,yield this.service.client.send(c)}))}}class Oi{constructor(t,e){this.client=t,this.id=e,this.subtle=new Ii(this),this.keyStorage=new Ci(this),this.certStorage=new Ui(this)}getRandomValues(t){return O().crypto.getRandomValues(t)}login(){return nt(this,void 0,void 0,(function*(){const t=new kt;return t.providerID=this.id,this.client.send(t)}))}logout(){return nt(this,void 0,void 0,(function*(){const t=new Et;return t.providerID=this.id,this.client.send(t)}))}reset(){return nt(this,void 0,void 0,(function*(){const t=new Nt;return t.providerID=this.id,this.client.send(t)}))}isLoggedIn(){return nt(this,void 0,void 0,(function*(){const t=new xt;t.providerID=this.id;const e=yield this.client.send(t);return!!new Uint8Array(e)[0]}))}}let qi=(()=>{class t extends v{constructor(t){super(),this.client=new Ue(t.storage),this.cardReader=new ye(this.client)}get state(){return this.client.state}connect(e=t.FORTIFY,r){return this.removeAllListeners(),this.client.connect(e,r).on("error",t=>{this.emit("error",t.error)}).on("event",t=>{(()=>{nt(this,void 0,void 0,(function*(){switch(t.action){case re.ACTION:{const e=yield re.importProto(yield t.exportProto());this.emit("token",e)}case ee.ACTION:{const e=yield ee.importProto(yield t.exportProto());this.emit("auth",e)}}}))})()}).on("listening",()=>{this.emit("listening",e)}).on("close",t=>{this.emit("close",t.remoteAddress)}),this}close(){this.client.close()}on(t,e){return console.log("SocketProvider:on",t),super.on(t,e)}once(t,e){return super.once(t,e)}info(){return nt(this,void 0,void 0,(function*(){const t=new Yt,e=yield this.client.send(t);return yield Qt.importProto(e)}))}challenge(){return nt(this,void 0,void 0,(function*(){return this.client.challenge()}))}isLoggedIn(){return nt(this,void 0,void 0,(function*(){return this.client.isLoggedIn()}))}login(){return nt(this,void 0,void 0,(function*(){return this.client.login()}))}getCrypto(t){return nt(this,void 0,void 0,(function*(){const e=new te;return e.cryptoID=t,yield this.client.send(e),new Oi(this.client,t)}))}}return t.FORTIFY="127.0.0.1:31337",t})();class Ri{}var Ti=Ie((function(t){!function(){function e(t){return Array.prototype.slice.call(t)}function r(t){return new Promise((function(e,r){t.onsuccess=function(){e(t.result)},t.onerror=function(){r(t.error)}}))}function i(t,e,i){var n,s=new Promise((function(s,o){r(n=t[e].apply(t,i)).then(s,o)}));return s.request=n,s}function n(t,e,r){var n=i(t,e,r);return n.then((function(t){if(t)return new h(t,n.request)}))}function s(t,e,r){r.forEach((function(r){Object.defineProperty(t.prototype,r,{get:function(){return this[e][r]},set:function(t){this[e][r]=t}})}))}function o(t,e,r,n){n.forEach((function(n){n in r.prototype&&(t.prototype[n]=function(){return i(this[e],n,arguments)})}))}function a(t,e,r,i){i.forEach((function(i){i in r.prototype&&(t.prototype[i]=function(){return this[e][i].apply(this[e],arguments)})}))}function c(t,e,r,i){i.forEach((function(i){i in r.prototype&&(t.prototype[i]=function(){return n(this[e],i,arguments)})}))}function u(t){this._index=t}function h(t,e){this._cursor=t,this._request=e}function f(t){this._store=t}function l(t){this._tx=t,this.complete=new Promise((function(e,r){t.oncomplete=function(){e()},t.onerror=function(){r(t.error)},t.onabort=function(){r(t.error)}}))}function d(t,e,r){this._db=t,this.oldVersion=e,this.transaction=new l(r)}function y(t){this._db=t}s(u,"_index",["name","keyPath","multiEntry","unique"]),o(u,"_index",IDBIndex,["get","getKey","getAll","getAllKeys","count"]),c(u,"_index",IDBIndex,["openCursor","openKeyCursor"]),s(h,"_cursor",["direction","key","primaryKey","value"]),o(h,"_cursor",IDBCursor,["update","delete"]),["advance","continue","continuePrimaryKey"].forEach((function(t){t in IDBCursor.prototype&&(h.prototype[t]=function(){var e=this,i=arguments;return Promise.resolve().then((function(){return e._cursor[t].apply(e._cursor,i),r(e._request).then((function(t){if(t)return new h(t,e._request)}))}))})})),f.prototype.createIndex=function(){return new u(this._store.createIndex.apply(this._store,arguments))},f.prototype.index=function(){return new u(this._store.index.apply(this._store,arguments))},s(f,"_store",["name","keyPath","indexNames","autoIncrement"]),o(f,"_store",IDBObjectStore,["put","add","delete","clear","get","getAll","getKey","getAllKeys","count"]),c(f,"_store",IDBObjectStore,["openCursor","openKeyCursor"]),a(f,"_store",IDBObjectStore,["deleteIndex"]),l.prototype.objectStore=function(){return new f(this._tx.objectStore.apply(this._tx,arguments))},s(l,"_tx",["objectStoreNames","mode"]),a(l,"_tx",IDBTransaction,["abort"]),d.prototype.createObjectStore=function(){return new f(this._db.createObjectStore.apply(this._db,arguments))},s(d,"_db",["name","version","objectStoreNames"]),a(d,"_db",IDBDatabase,["deleteObjectStore","close"]),y.prototype.transaction=function(){return new l(this._db.transaction.apply(this._db,arguments))},s(y,"_db",["name","version","objectStoreNames"]),a(y,"_db",IDBDatabase,["close"]),["openCursor","openKeyCursor"].forEach((function(t){[f,u].forEach((function(r){t in r.prototype&&(r.prototype[t.replace("open","iterate")]=function(){var r=e(arguments),i=r[r.length-1],n=this._store||this._index,s=n[t].apply(n,r.slice(0,-1));s.onsuccess=function(){i(s.result)}})}))})),[u,f].forEach((function(t){t.prototype.getAll||(t.prototype.getAll=function(t,e){var r=this,i=[];return new Promise((function(n){r.iterateCursor(t,(function(t){t?(i.push(t.value),void 0===e||i.length!=e?t.continue():n(i)):n(i)}))}))})})),t.exports={open:function(t,e,r){var n=i(indexedDB,"open",[t,e]),s=n.request;return s&&(s.onupgradeneeded=function(t){r&&r(new d(s.result,t.oldVersion,s.transaction))}),n.then((function(t){return new y(t)}))},delete:function(t){return i(indexedDB,"deleteDatabase",[t])}},t.exports.default=t.exports}()})),Ki=Ie((function(t){t.exports="undefined"!=typeof indexedDB?Ti:{open:function(){return Promise.reject("IDB requires a browser environment")},delete:function(){return Promise.reject("IDB requires a browser environment")}}}));let Di=(()=>{class t extends Ri{constructor(t){super(),this.db=t}static create(){return nt(this,void 0,void 0,(function*(){const e=yield Ki.open(this.STORAGE_NAME,2,t=>{1===t.oldVersion&&(t.deleteObjectStore(this.SESSION_STORAGE),t.deleteObjectStore(this.IDENTITY_STORAGE),t.deleteObjectStore(this.REMOTE_STORAGE)),t.createObjectStore(this.SESSION_STORAGE),t.createObjectStore(this.IDENTITY_STORAGE),t.createObjectStore(this.REMOTE_STORAGE)});return new t(e)}))}loadWrapKey(){return nt(this,void 0,void 0,(function*(){const e=yield this.db.transaction(t.IDENTITY_STORAGE).objectStore(t.IDENTITY_STORAGE).get(t.WRAP_KEY);return e?(Ee.iv=e.iv,e.key instanceof ArrayBuffer?{key:yield O().crypto.subtle.importKey("raw",e.key,{name:Ee.name,length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"]),iv:e.iv}:{key:e.key,iv:e.iv}):null}))}saveWrapKey(e){return nt(this,void 0,void 0,(function*(){let r;r=be()||Be()?{key:yield O().crypto.subtle.exportKey("raw",e.key),iv:e.iv}:Object.assign({},e),yield this.db.transaction(t.IDENTITY_STORAGE,"readwrite").objectStore(t.IDENTITY_STORAGE).put(r,t.WRAP_KEY)}))}loadIdentity(){return nt(this,void 0,void 0,(function*(){const e=yield this.db.transaction(t.IDENTITY_STORAGE).objectStore(t.IDENTITY_STORAGE).get(t.IDENTITY);let r=null;if(e){if(Ae()||be()||Be()){const t=yield this.loadWrapKey();if(!(t&&t.key.usages.some(t=>"encrypt"===t)&&e.exchangeKey.privateKey instanceof ArrayBuffer))return null;e.exchangeKey.privateKey=yield O().crypto.subtle.unwrapKey("jwk",e.exchangeKey.privateKey,t.key,Ee,Se,!1,["deriveKey","deriveBits"]),e.signingKey.privateKey=yield O().crypto.subtle.unwrapKey("jwk",e.signingKey.privateKey,t.key,Ee,ke,!1,["sign"]),e.exchangeKey.publicKey=yield O().crypto.subtle.unwrapKey("jwk",e.exchangeKey.publicKey,t.key,Ee,Se,!0,[]),e.signingKey.publicKey=yield O().crypto.subtle.unwrapKey("jwk",e.signingKey.publicKey,t.key,Ee,ke,!0,["verify"])}r=yield D.fromJSON(e)}return r}))}saveIdentity(e){return nt(this,void 0,void 0,(function*(){let r;if(Ae()||be()||Be()){r={key:yield O().crypto.subtle.generateKey({name:Ee.name,length:256},be()||Be(),["wrapKey","unwrapKey","encrypt","decrypt"]),iv:O().crypto.getRandomValues(new Uint8Array(Ee.iv)).buffer},yield this.saveWrapKey(r);const t=yield O().crypto.subtle.generateKey(e.exchangeKey.privateKey.algorithm,!0,["deriveKey","deriveBits"]);e.exchangeKey.privateKey=t.privateKey,yield xe(e.exchangeKey.publicKey,t.publicKey);const i=yield O().crypto.subtle.generateKey(e.signingKey.privateKey.algorithm,!0,["sign","verify"]);e.signingKey.privateKey=i.privateKey,yield xe(e.signingKey.publicKey,i.publicKey)}const i=yield e.toJSON();r&&(i.exchangeKey.privateKey=yield O().crypto.subtle.wrapKey("jwk",e.exchangeKey.privateKey,r.key,Ee),i.signingKey.privateKey=yield O().crypto.subtle.wrapKey("jwk",e.signingKey.privateKey,r.key,Ee),i.exchangeKey.publicKey=yield O().crypto.subtle.wrapKey("jwk",e.exchangeKey.publicKey.key,r.key,Ee),i.signingKey.publicKey=yield O().crypto.subtle.wrapKey("jwk",e.signingKey.publicKey.key,r.key,Ee)),yield this.db.transaction(t.IDENTITY_STORAGE,"readwrite").objectStore(t.IDENTITY_STORAGE).put(i,t.IDENTITY)}))}loadRemoteIdentity(e){return nt(this,void 0,void 0,(function*(){const r=yield this.db.transaction(t.REMOTE_STORAGE).objectStore(t.REMOTE_STORAGE).get(e);let i=null;if(r){const t=yield this.loadWrapKey();t&&(r.exchangeKey=yield O().crypto.subtle.unwrapKey("jwk",r.exchangeKey,t.key,Ee,Se,!0,[]),r.signingKey=yield O().crypto.subtle.unwrapKey("jwk",r.signingKey,t.key,Ee,ke,!0,["verify"])),i=yield j.fromJSON(r)}return i}))}saveRemoteIdentity(e,r){return nt(this,void 0,void 0,(function*(){const i=yield r.toJSON(),n=yield this.loadWrapKey();n&&(i.exchangeKey=yield O().crypto.subtle.wrapKey("jwk",i.exchangeKey,n.key,Ee),i.signingKey=yield O().crypto.subtle.wrapKey("jwk",i.signingKey,n.key,Ee)),yield this.db.transaction(t.REMOTE_STORAGE,"readwrite").objectStore(t.REMOTE_STORAGE).put(i,e)}))}loadSession(e){return nt(this,void 0,void 0,(function*(){const r=yield this.db.transaction(t.SESSION_STORAGE).objectStore(t.SESSION_STORAGE).get(e);let i=null;if(r){const t=yield this.loadIdentity();if(!t)throw new Error("Identity is empty");const n=yield this.loadRemoteIdentity(e);if(!n)throw new Error("Remote identity is not found");i=yield tt.fromJSON(t,n,r)}return i}))}saveSession(e,r){return nt(this,void 0,void 0,(function*(){const i=yield r.toJSON();yield this.db.transaction(t.SESSION_STORAGE,"readwrite").objectStore(t.SESSION_STORAGE).put(i,e)}))}}return t.STORAGE_NAME="webcrypto-remote",t.IDENTITY_STORAGE="identity",t.SESSION_STORAGE="sessions",t.REMOTE_STORAGE="remoteIdentity",t.WRAP_KEY="wkey",t.IDENTITY="identity",t})();return t.BrowserStorage=Di,t.CertificateStorage=Ui,t.CryptoServerError=we,t.KeyStorage=Ci,t.MemoryStorage=class extends Ri{constructor(){super(...arguments),this.remoteIdentities={},this.sessions={}}loadIdentity(){return nt(this,void 0,void 0,(function*(){return this.identity||null}))}saveIdentity(t){return nt(this,void 0,void 0,(function*(){this.identity=t}))}loadRemoteIdentity(t){return nt(this,void 0,void 0,(function*(){return this.remoteIdentities[t]||null}))}saveRemoteIdentity(t,e){return nt(this,void 0,void 0,(function*(){this.remoteIdentities[t]=e}))}loadSession(t){return nt(this,void 0,void 0,(function*(){return this.sessions[t]||null}))}saveSession(t,e){return nt(this,void 0,void 0,(function*(){this.sessions[t]=e}))}},t.RatchetStorage=Ri,t.SocketCrypto=Oi,t.SocketProvider=qi,t.getEngine=O,t.setEngine=function(t,e){I={crypto:e,name:t}},t}({},protobuf,fetch,WebSocket);self.WebcryptoSocket=t;